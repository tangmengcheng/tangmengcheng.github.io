<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. 说说你对 Webpack 的理解？它解决了什么问题？ | 技术博客文章总结</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.c45b4ff4.js" as="script"><link rel="preload" href="/assets/js/77.1304118a.js" as="script"><link rel="prefetch" href="/assets/js/10.9cdf722f.js"><link rel="prefetch" href="/assets/js/100.9b45b75e.js"><link rel="prefetch" href="/assets/js/101.95c4d653.js"><link rel="prefetch" href="/assets/js/102.09cdc274.js"><link rel="prefetch" href="/assets/js/103.985d4863.js"><link rel="prefetch" href="/assets/js/104.66cfb550.js"><link rel="prefetch" href="/assets/js/105.78c4c309.js"><link rel="prefetch" href="/assets/js/106.34be9d25.js"><link rel="prefetch" href="/assets/js/107.0df352d3.js"><link rel="prefetch" href="/assets/js/108.901d6014.js"><link rel="prefetch" href="/assets/js/109.76339f5d.js"><link rel="prefetch" href="/assets/js/11.d22cc24d.js"><link rel="prefetch" href="/assets/js/110.c6e9ec88.js"><link rel="prefetch" href="/assets/js/111.d390a797.js"><link rel="prefetch" href="/assets/js/112.cf502784.js"><link rel="prefetch" href="/assets/js/113.aa449169.js"><link rel="prefetch" href="/assets/js/114.fc2133ce.js"><link rel="prefetch" href="/assets/js/115.523542e3.js"><link rel="prefetch" href="/assets/js/116.c3507815.js"><link rel="prefetch" href="/assets/js/117.23b5b1f0.js"><link rel="prefetch" href="/assets/js/118.5df8c262.js"><link rel="prefetch" href="/assets/js/119.8e1342c2.js"><link rel="prefetch" href="/assets/js/12.636890c7.js"><link rel="prefetch" href="/assets/js/120.01f21153.js"><link rel="prefetch" href="/assets/js/121.7b546d27.js"><link rel="prefetch" href="/assets/js/122.bd8c0286.js"><link rel="prefetch" href="/assets/js/123.f4f16ed2.js"><link rel="prefetch" href="/assets/js/124.ab5935d4.js"><link rel="prefetch" href="/assets/js/125.b29cf321.js"><link rel="prefetch" href="/assets/js/126.ddf1b9eb.js"><link rel="prefetch" href="/assets/js/127.4d63b823.js"><link rel="prefetch" href="/assets/js/128.f63c61cb.js"><link rel="prefetch" href="/assets/js/129.e74fb4b4.js"><link rel="prefetch" href="/assets/js/13.74a454d8.js"><link rel="prefetch" href="/assets/js/130.05f02f04.js"><link rel="prefetch" href="/assets/js/131.bac5f9b9.js"><link rel="prefetch" href="/assets/js/132.a98fffcf.js"><link rel="prefetch" href="/assets/js/133.5b34ebb6.js"><link rel="prefetch" href="/assets/js/14.ffe8d211.js"><link rel="prefetch" href="/assets/js/15.1bcc034f.js"><link rel="prefetch" href="/assets/js/16.87d6c8f3.js"><link rel="prefetch" href="/assets/js/17.576aa97e.js"><link rel="prefetch" href="/assets/js/18.8c80ffa6.js"><link rel="prefetch" href="/assets/js/19.bd2abc77.js"><link rel="prefetch" href="/assets/js/2.0379b669.js"><link rel="prefetch" href="/assets/js/20.56b31195.js"><link rel="prefetch" href="/assets/js/21.81d1d011.js"><link rel="prefetch" href="/assets/js/22.b52a1bed.js"><link rel="prefetch" href="/assets/js/23.76785e7d.js"><link rel="prefetch" href="/assets/js/24.4bcce340.js"><link rel="prefetch" href="/assets/js/25.b2de599f.js"><link rel="prefetch" href="/assets/js/26.944ed78e.js"><link rel="prefetch" href="/assets/js/27.0bbcee1a.js"><link rel="prefetch" href="/assets/js/28.223ed5b6.js"><link rel="prefetch" href="/assets/js/29.b88c0c25.js"><link rel="prefetch" href="/assets/js/3.b3231975.js"><link rel="prefetch" href="/assets/js/30.5754e2d0.js"><link rel="prefetch" href="/assets/js/31.038ca76a.js"><link rel="prefetch" href="/assets/js/32.7f0c55a6.js"><link rel="prefetch" href="/assets/js/33.7fd80664.js"><link rel="prefetch" href="/assets/js/34.8dcb3109.js"><link rel="prefetch" href="/assets/js/35.8b1fdc43.js"><link rel="prefetch" href="/assets/js/36.cf886fc0.js"><link rel="prefetch" href="/assets/js/37.f7abfe5d.js"><link rel="prefetch" href="/assets/js/38.f63c0deb.js"><link rel="prefetch" href="/assets/js/39.9b06b340.js"><link rel="prefetch" href="/assets/js/4.c1de1412.js"><link rel="prefetch" href="/assets/js/40.490eed30.js"><link rel="prefetch" href="/assets/js/41.b5abbdbc.js"><link rel="prefetch" href="/assets/js/42.1f6e4a3a.js"><link rel="prefetch" href="/assets/js/43.5e85acae.js"><link rel="prefetch" href="/assets/js/44.11b7ef0a.js"><link rel="prefetch" href="/assets/js/45.9774ff29.js"><link rel="prefetch" href="/assets/js/46.2cf4bc5b.js"><link rel="prefetch" href="/assets/js/47.bc79b4ef.js"><link rel="prefetch" href="/assets/js/48.0d80c17f.js"><link rel="prefetch" href="/assets/js/49.4fcabf82.js"><link rel="prefetch" href="/assets/js/5.1d97952d.js"><link rel="prefetch" href="/assets/js/50.7d65f488.js"><link rel="prefetch" href="/assets/js/51.2545cb57.js"><link rel="prefetch" href="/assets/js/52.36a2cca1.js"><link rel="prefetch" href="/assets/js/53.64484c50.js"><link rel="prefetch" href="/assets/js/54.52e5411a.js"><link rel="prefetch" href="/assets/js/55.4f773e83.js"><link rel="prefetch" href="/assets/js/56.a5437204.js"><link rel="prefetch" href="/assets/js/57.24dd7861.js"><link rel="prefetch" href="/assets/js/58.86388619.js"><link rel="prefetch" href="/assets/js/59.c9912d49.js"><link rel="prefetch" href="/assets/js/6.210e38ca.js"><link rel="prefetch" href="/assets/js/60.b29d00e8.js"><link rel="prefetch" href="/assets/js/61.13ff4966.js"><link rel="prefetch" href="/assets/js/62.8efcf596.js"><link rel="prefetch" href="/assets/js/63.5fa9582a.js"><link rel="prefetch" href="/assets/js/64.bbd14fec.js"><link rel="prefetch" href="/assets/js/65.bae7fd4f.js"><link rel="prefetch" href="/assets/js/66.8e3958d7.js"><link rel="prefetch" href="/assets/js/67.dac9beaa.js"><link rel="prefetch" href="/assets/js/68.1c7432eb.js"><link rel="prefetch" href="/assets/js/69.363a3505.js"><link rel="prefetch" href="/assets/js/7.1b6e0d8a.js"><link rel="prefetch" href="/assets/js/70.e4e45ab1.js"><link rel="prefetch" href="/assets/js/71.e941d084.js"><link rel="prefetch" href="/assets/js/72.6c657f6c.js"><link rel="prefetch" href="/assets/js/73.910ec668.js"><link rel="prefetch" href="/assets/js/74.92f12f63.js"><link rel="prefetch" href="/assets/js/75.984c2f19.js"><link rel="prefetch" href="/assets/js/76.e4dddf5f.js"><link rel="prefetch" href="/assets/js/78.36d67468.js"><link rel="prefetch" href="/assets/js/79.bebe2f90.js"><link rel="prefetch" href="/assets/js/8.23102c69.js"><link rel="prefetch" href="/assets/js/80.4f2da588.js"><link rel="prefetch" href="/assets/js/81.666e12e9.js"><link rel="prefetch" href="/assets/js/82.00e1d25e.js"><link rel="prefetch" href="/assets/js/83.6f17555a.js"><link rel="prefetch" href="/assets/js/84.71aca979.js"><link rel="prefetch" href="/assets/js/85.5da240e9.js"><link rel="prefetch" href="/assets/js/86.e9b29015.js"><link rel="prefetch" href="/assets/js/87.0c138ef2.js"><link rel="prefetch" href="/assets/js/88.d122fecd.js"><link rel="prefetch" href="/assets/js/89.ccb42cfb.js"><link rel="prefetch" href="/assets/js/9.7477a4ab.js"><link rel="prefetch" href="/assets/js/90.620b4440.js"><link rel="prefetch" href="/assets/js/91.a231af75.js"><link rel="prefetch" href="/assets/js/92.0bb536ea.js"><link rel="prefetch" href="/assets/js/93.a8d3b09d.js"><link rel="prefetch" href="/assets/js/94.4e3d0336.js"><link rel="prefetch" href="/assets/js/95.263fdc93.js"><link rel="prefetch" href="/assets/js/96.2886b194.js"><link rel="prefetch" href="/assets/js/97.d085eef0.js"><link rel="prefetch" href="/assets/js/98.eaf95a18.js"><link rel="prefetch" href="/assets/js/99.fbafbf7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术博客文章总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Vue 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6+</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>H5</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端设计模式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>面试总结</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级进阶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>源码手写</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>高级面试题汇总</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/chapter16/" class="sidebar-link">前端面试大纲</a></li><li><a href="/chapter16/html.html" class="sidebar-link">HTML 部分</a></li><li><a href="/chapter16/css.html" class="sidebar-link">CSS 部分</a></li><li><a href="/chapter16/js.html" class="sidebar-link">JS 部分</a></li><li><a href="/chapter16/vue.html" class="sidebar-link">Vue 部分</a></li><li><a href="/chapter16/react.html" class="sidebar-link">React 部分</a></li><li><a href="/chapter16/webpack.html" class="active sidebar-link">Webpack 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_1-说说你对-webpack-的理解？它解决了什么问题？" class="sidebar-link">1. 说说你对 Webpack 的理解？它解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_2-webpack-的构建流程？" class="sidebar-link">2. Webpack 的构建流程？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_3-常见的-loader、plugin-有哪些？能手写吗？" class="sidebar-link">3. 常见的 Loader、Plugin 有哪些？能手写吗？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_4-如何提高-webpack-的构建速度？" class="sidebar-link">4. 如何提高 Webpack 的构建速度？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_5-webpack4-和-webpack5-有哪些区别？" class="sidebar-link">5. Webpack4 和 Webpack5 有哪些区别？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_6-grunt、gulp、webpack、rollup、vite-的比较？" class="sidebar-link">6. Grunt、Gulp、Webpack、Rollup、Vite 的比较？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_7-了解热更新原理吗？它是如何做到的？说说其原理？" class="sidebar-link">7. 了解热更新原理吗？它是如何做到的？说说其原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_8-sourcemap-有哪些？对应的作用是什么？" class="sidebar-link">8. sourceMap 有哪些？对应的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_9-babel-的原理？" class="sidebar-link">9. Babel 的原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_10-module、chunk、bundle-分别是什么意思，有何区别？" class="sidebar-link">10. module、chunk、bundle 分别是什么意思，有何区别？</a></li><li class="sidebar-sub-header"><a href="/chapter16/webpack.html#_11-webpack-optimize-有配置过吗-可以简单说说吗" class="sidebar-link">11. Webpack optimize 有配置过吗?可以简单说说吗?</a></li></ul></li><li><a href="/chapter16/http.html" class="sidebar-link">HTTP 部分</a></li><li><a href="/chapter16/algorithm.html" class="sidebar-link">算法部分</a></li><li><a href="/chapter16/optimize.html" class="sidebar-link">优化部分</a></li><li><a href="/chapter16/performance.html" class="sidebar-link">开放性</a></li><li><a href="/chapter16/inter.html" class="sidebar-link">2022</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="_1-说说你对-webpack-的理解？它解决了什么问题？"><a href="#_1-说说你对-webpack-的理解？它解决了什么问题？" aria-hidden="true" class="header-anchor">#</a> 1. 说说你对 Webpack 的理解？它解决了什么问题？</h2> <p><code>Webpack</code> 是一个现代的 <code>JS</code> 应用程序的静态<code>模块打包器</code>。它主要做的事情就是：分析你的项目结构，找到 <code>JavaScript</code> 模块以及其他的一些浏览器不能直接运行的扩展语言（<code>Sass</code> <code>TS</code> 等）。并将其打包为合适的格式以供浏览器使用。</p> <ul><li>Webpack 的主要功能:
<ol><li>代码转换</li> <li>文件优化</li> <li>代码分割</li> <li>模块合并</li> <li>自动刷新</li> <li>代码校验</li> <li>自动发布等等</li></ol></li></ul> <blockquote><p>早期模块化？</p></blockquote> <ul><li><p>把单独的功能抽离到单独的 <code>js</code> 文件，通过 <code>script</code> 引入。</p> <p><strong>出现的问题</strong>：模块都在全局中，大量模块污染环境，并且模块与模块之间没有依赖关系，维护困难，没有私有空间等问题</p> <p><strong>解决方案</strong>：出现了 <code>命名空间</code> 方式，规定每个模块只暴露一个全局对象，模块的内容都挂载在这个对象中; ---》还是没有解决第一种方式的 <code>依赖</code> 等问题。再后来，使用 <code>立即执行函数</code> 模块提供私有空间，通过 <code>参数</code> 的形式作为依赖声明; ---》这种方式还是存在一些问题。比如：通过 script 引入模块，这些<strong>模块的加载并不受代码的控制</strong></p> <p><strong>理想的解决方式</strong>：在页面中引入一个 <code>JS</code> 入口文件，其余用到的模块可以通过代码控制，按需加载进来</p></li> <li><p>除了 <strong>模块加载</strong> 的问题以外，还需要规定<code>模块化的规范</code>。如今流行的：<code>CommonJS</code>、<code>ES Module</code></p> <p>从前后端渲染的 JSP、PHP。到前端原生 JavaScript。再到 jQuery 开发。再到目前三大框架 Vue, React, Angular 开发。也从 JavaScript 到后面的 es5,6,7,8...。再到 TypeScript。有些编写的 CSS 预处理器 less、sass 等。如今的前端变得十分复杂，所以我们开发过程中会遇到以下问题：</p> <ol><li>项目需要通过模块化的方式来开发</li> <li>使用一些高级的特性来加快我们的开发效率，如：ES6+、TypeScript 开发脚本逻辑，通过 Less、Sass 等方式来编写 css 样式代码</li> <li>监听文件的变化并且反映到浏览器上，提高开发效率</li> <li>JS 代码需要模块化，HTML 和 CSS 这些资源文件有些也需要模块化</li> <li>开发完后我们需要将代码压缩、合并以及一些优化等问题</li></ol></li></ul> <p><strong>综合</strong>：Webpack 恰巧可以解决以上问题！</p> <blockquote><p>扩展：webpack -&gt; 垫片 Shimming</p></blockquote> <p>比如，我们使用 <code>jQuery</code> 中的$符号时，浏览器不认识(<code>$ is not defined</code>)。我们可以使用 <code>webpack</code> 内置插件 <code>ProvidePlugin({\$: 'jquery'})</code>。模块中使用了<code>$</code>就自动引入<code>jquery</code>，并将<code>jquery</code>赋值给<code>$</code>.这种方式就叫垫片 <code>Shimming</code></p> <h2 id="_2-webpack-的构建流程？"><a href="#_2-webpack-的构建流程？" aria-hidden="true" class="header-anchor">#</a> 2. Webpack 的构建流程？</h2> <ul><li><strong>初始化参数</strong>：解析 <code>webpack</code> 配置参数，合并 <code>shell</code> 传入和 <code>webpack.config.js</code> 文件配置的参数, 形成最后的配置结果</li> <li><strong>开始编译</strong>：上一步得到的参数初始化 <code>Compiler</code> 对象，注册所有配置的插件，插件会监听 <code>webpack</code> 构建生命周期的事件节点，做出相应的反应。然后执行 <code>run</code> 方法开始执行编译</li> <li><strong>确认入口</strong>：根据配置的 <code>entry</code> 入口，开始解析文件构建 <code>AST</code>（抽象语法树），找出依赖，递归下去</li> <li><strong>编译模块</strong>：递归中根据文件类型和 <code>loader</code> 配置，调用所有配置的 <code>loader</code> 对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li> <li><strong>完成模块编译并输出资源</strong>：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据 <code>entry</code> 或分包配置生成代码块 <code>chunk</code></li> <li><strong>输出完成</strong>：输出所有的 <code>chunk</code> 到文件系统</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-7229962/kl8mmit2al.png?imageView2/2/w/1620" alt></p> <h2 id="_3-常见的-loader、plugin-有哪些？能手写吗？"><a href="#_3-常见的-loader、plugin-有哪些？能手写吗？" aria-hidden="true" class="header-anchor">#</a> 3. 常见的 Loader、Plugin 有哪些？能手写吗？</h2> <blockquote><p>Plugin 的理解</p></blockquote> <p><code>Plugin</code> 就是一个扩展器，它比 <code>Loader</code> 更加灵活，因为它可以接触到 <code>Webpack</code> 编译器。在 <code>Webpack</code> 运行的生命周期中会广播出许多的事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。这样 <code>Plugin</code> 就可以通过一些 hook 函数来拦截 <code>Webpack</code> 的执行，做一些 <code>Webpack</code> 打包之外的事情。像：<code>打包优化</code>、<code>资源管理</code>、<code>注入环境变量</code>等等。</p> <p>插件实例上都会有个 <code>apply</code> 方法，并将 <code>compiler</code> 作为其参数。（类似于：<code>Vue</code> 插件都有个 <code>install</code> 方法）</p> <p>在开发 <code>Plugin</code> 时最常用的两个对象 <code>Compiler</code> 和 <code>Compilation</code>，它们都继承自<code>Tapable</code>，是 <code>Plugin</code> 和 <code>Webpack</code> 之间的桥梁。类似于 <code>react-redux</code> 是连接 <code>React</code> 和 <code>Redux</code> 的桥梁。（<code>Tapable</code> 有同步钩子和异步钩子（<code>异步串行钩子</code> 和 <code>异步并行钩子</code>））</p> <p>注册钩子的方式：同步（<code>tap</code> 注册 -》 <code>call</code> 执行）；异步（<code>tap -》call</code>、<code>tapAsync -》callAsync</code>、<code>tapPromise -》promise</code>）</p> <p>通过 <code>schema-utils</code> 验证 <code>options</code> 的合法性</p> <ul><li><p>常见的 <code>Plugin</code>:</p> <ol><li><strong>html-webpack-plugin</strong>：可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件</li> <li><strong>extract-text-webpack-plugin</strong>：将 js 文件中引用的样式单独抽离成 css 文件（webpack4 推荐使用 mini-css-extract-plugin）
<ul><li>两者有啥区别？
<ol><li>后者：更容易使用、异步加载、而且只针对 CSS，并且不重复编译，性能更好</li> <li>该插件一般在（生产环境）使用。代替 loaders 中的 style-loader，暂时不支持 HMR</li></ol></li></ul></li> <li><strong>clean-webpack-plugin</strong>: 清理每次打包的文件</li> <li><strong>speed-measure-webpack-plugin</strong>: 可以看每个 Loader 和 Plugin 执行耗时（webpack5 使用 speed-measure-webpack5-plugin）</li> <li><strong>webpack-bundle-analyzer</strong>: 可视化 Webpack 输出文件的体积</li> <li><strong>copy-webpack-plugin</strong>：拷贝插件</li> <li><strong>friendly-errors-webpack-plugin</strong>： 识别某些类别的 webpack 错误，并清理，聚合和优先级，以提供更好的开发人员体验
<ul><li>webpack 中提供了 stats 选项显示打包信息（只展示错误信息、都展示等等）</li></ul></li> <li><strong>optimize-css-assets-webpack-plugin</strong>：压缩 css</li> <li><strong>purgecss-webpack-plugin</strong>: 去除无用的 css</li> <li><strong>uglifyJs-webpack-plugin</strong>：压缩 js
（压缩 es6 的代码不是很友好；并且是单线程压缩代码，打包时间慢，所以开发环境将其关闭，生产环境打开（parallelUglifyPlugin 开启多个子进程打包，每个子进程还是 UglifyJS 打包，但并行执行）-》webpack4 推荐用 terser-webpack-plugin（开启 parallel 参数【一般是电脑的 CPU 核数减 1】，使用进程压缩）；此插件 webpack5 中内置了）</li> <li><strong>compression-webpack-plugin</strong>：（生产环境可采用）gzip 压缩 JS 和 CSS【需要后台配置 nginx】</li> <li><strong>HotModuleReplacementPlugin</strong>：热更新（自带的）</li> <li><strong>happypack</strong>：开启多进程打包，提高打包速度（不维护了）</li> <li><strong>ProvidePlugin</strong>：自动加载模块，代替 require 和 import（自带的）</li> <li><strong>DefinePlugin</strong>：定义全局变量（浏览器获取的值，需使用 JSON.stringify 包裹）</li> <li><strong>IgnorePlugin</strong>：忽略或排除（moment 不用全部加载，只加载中文）</li> <li><strong>DllPlugin</strong>：动态链接库，配合 DllReferencePlugin 一起使用（自带的）</li></ol></li></ul> <blockquote><p>Loader 的理解</p></blockquote> <p>就是一个 <code>代码转码器</code>，对各种资源进行转换。它的特点：单一原则，每个 <code>loader</code> 只做对应的事情。它的执行顺序：<code>从右到左</code>，<code>从下到上</code>。有几种分类：<code>pr</code>e、<code>normal</code>（默认）、<code>inline</code>、<code>post</code>。<code>Loader</code> 就是一个函数，接受原始资源作为<code>参数</code>，输出进行转换后的内容。</p> <p><code>loader</code> 的执行分为两个阶段：<code>Pitch</code> 阶段和 <code>Normal</code> 阶段。<code>loader</code> 会先执行 <code>pitch</code>，然后获取资源再执行 <code>normal loader</code>。如果 <code>pitch</code> 有返回值时，就不会走之后的 <code>loader</code>，并将返回值返回给之前的 <code>loader</code>。这就是为什么 <code>pitch</code> 有 <strong>熔断</strong> 的作用！</p> <p><code>loader-utils</code> 中 <code>getOptions(this)</code> 方法用来获取 <code>loader</code> 中 <code>options</code> 的配置</p> <p><code>schema-utils</code> 中 <code>validate</code> 方法用来验证 <code>loader</code> 中 <code>options</code> 的配置是否合法 <code>{type: 'object', properties: {}, additionalProperties: true}</code></p> <p><code>loader</code> 分为<strong>同步</strong>（<code>return</code> 或 <code>this.callback(null, source, map, meta)</code>两种方式）和 <strong>异步</strong>（<code>this.async()</code>）</p> <ul><li><p>常见的 Loader:</p> <ol><li>file-loader：</li> <li>url-loader：</li> <li>babel-loader：</li> <li>css-loader：</li> <li>style-loader：</li> <li>eslint-loader：</li> <li>cache-loader：</li> <li>less-loader、sass-loader、styles-loader：</li> <li>image-webpack-loader：压缩图片</li> <li>postcss-loader、autoprefixer-loader</li></ol></li> <li><p><code>Compiler</code> 上有哪些钩子？
environment、run、make、emit、afterEmit、done、thisCompilation(初始化 compilation 时调用) 等等</p></li> <li><p><code>Compilation</code> 上有哪些钩子？</p></li></ul> <h2 id="_4-如何提高-webpack-的构建速度？"><a href="#_4-如何提高-webpack-的构建速度？" aria-hidden="true" class="header-anchor">#</a> 4. 如何提高 Webpack 的构建速度？</h2> <p>优化<code>webpack</code>构建的方式有很多，主要可以从<code>优化搜索时间</code>、<code>缩小文件搜索范围</code>、<code>减少不必要的编译</code>等方面入手：</p> <ul><li>多线程/多实例构建：<code>HappyPack</code>(不维护了)、<code>thread-loader</code></li> <li>优化 <code>loader</code> 的配置
<ol><li><code>include</code> 和 <code>exclude</code></li> <li>配置 <code>babel-loader</code> 时，可以配置 <code>cacheDirectory</code> 开启缓存</li></ol></li> <li>合理的使用 <code>resolve.extensions</code> <ol><li><code>extensions</code>: [&quot;.js&quot;,&quot;.json&quot;]</li></ol></li> <li>优化 <code>resolve.modules</code> <ol><li>用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>['node_modules']</code>，配置了可以减少查找路径</li></ol></li> <li>优化 <code>resolve.alias</code> <ol><li><code>&quot;@&quot;:path.resolve(\_\_dirname,'./src')</code> 减少查找过程</li></ol></li> <li>使用 <code>DllPlugin</code> 插件
<ol><li>打包成一个 <code>Dll</code> 库，<code>webpack.DllPlugin()</code> -&gt; 生成 <code>mainfest.json</code> 文件</li> <li>引入 <code>Dll</code> 库，<code>webpack.DllReferencePlugin()</code></li></ol></li> <li>使用 <code>cache-loader</code> <ol><li>针对一些开销较大的 <code>loader</code> 前添加 <code>cache-loader</code>，将其结果缓存到磁盘里，显著提升二次构建速度（保存和读取这些缓存文件会有一些时间开销，只针对一些开销大的 <code>loader</code>）</li> <li><code>use</code>: <code>['cache-loader', ...loaders]</code></li></ol></li> <li><code>terser</code> 开启多线程
<ol><li>使用多进程并行运行来提高构建速度</li> <li><code>optimization</code>: <code>{ minimizer: [new TerserPlugin({ parallel: true })] }</code></li></ol></li> <li>合理使用 <code>sourceMap</code></li></ul> <h2 id="_5-webpack4-和-webpack5-有哪些区别？"><a href="#_5-webpack4-和-webpack5-有哪些区别？" aria-hidden="true" class="header-anchor">#</a> 5. Webpack4 和 Webpack5 有哪些区别？</h2> <ul><li><p><strong>压缩代码</strong></p> <p>内部自带 <code>terser-webpack-plugin</code> 插件（生产环境自动开启压缩）【<code>webpack4</code> 需要独立安装】</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack5开发环境启动压缩</span>
<span class="token keyword">const</span> TerserPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'terser-webpack-plugini'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    usedExports<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 只导出被使用的模块</span>
    minimize<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 启动压缩</span>
    minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">TerserPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>扩展</strong>：开发模块开启 <code>Tree Shaking</code> 的方式？【生产环境自动开启】</p> <ul><li><p><code>optimization.sideEffects: true</code>; // 开启
（<code>package.json</code> 里也要配置：<code>'sideEffects: false | true | []'</code>）</p></li> <li><p><code>Tree-shaking</code> 机制的原理？</p> <ol><li><code>treeShaking</code> 也叫<code>摇树优化</code>，是指在打包中去除那些引入了，但是在代码中没有被用到的<code>死代码</code>。从而来优化打包体积。<code>生产环境默认开启</code></li> <li>它可以在<code>代码不运行</code>的状态下，分析出<code>不需要的代码</code></li> <li>利用<code>es6模块</code>的规范
<code>ES6 Module</code> 引入进行<code>静态分析</code>，故而<code>编译的时候正确判断到底加载了那些模块</code></li> <li><code>Tree-shaking</code> 的实现：
<ol><li>先<strong>标记</strong>出模块导出值中哪些没有被用过</li> <li>使用 <code>Terser</code> 删掉这些没被用到的导出语句</li> <li>标记过程大致可划分为三个步骤：
<ol><li><code>Make 阶段</code>，收集模块导出变量并记录到模块依赖关系图 <code>ModuleGraph</code> 变量中</li> <li><code>Seal 阶段</code>，遍历 <code>ModuleGraph</code> 标记模块导出变量有没有被使用</li> <li><code>生成产物时</code>，若变量没有被其它模块使用则删除对应的导出语句</li></ol></li></ol></li></ol> <p><strong>扩展</strong>：<code>CSS</code> 可以 <code>Tree-Shaking</code> 吗？</p> <p>在 <code>webpack</code> 中 <code>Tree-Shaking</code> 是通过 <code>uglifyJSPlugin</code> 来 <code>Tree-Shaking JS</code> 的。<code>CSS</code> 需要使用 <code>Purify-CSS</code>[<strong>不在维护</strong>]，使用 <code>purgecss-webpack-plugin</code>，<code>mini-css-extract-plugin</code> 提取 css 插件配合使用。</p></li></ul></li> <li><p><strong>缓存配置</strong></p> <ol><li><code>webpack4</code> 通过 <code>hard-source-webpack-plugin</code> 缓存</li> <li><code>webpack5</code> 内置了 <code>cache</code> 缓存机制</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用持久化缓存</span>
  cache<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token string">'filesystem'</span><span class="token punctuation">,</span>
    cacheDirectory<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'node_modules/.cache/webpack'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>扩展</strong>：什么是长缓存？</p> <p>在 <code>webpack</code> 中可以在 <code>output</code> 选项中指定 <code>hash</code>, 通过 <code>HashedModuleIdsPlugin</code> 或者 <code>NamedModulesPlugin</code> 来生成唯一的 <code>moduleId</code>，保证没有改动的文件 <code>hash</code> 值不变</p> <p><strong>注意</strong>：<code>cache</code> 在开发模式默认设置成 <code>type: memory</code>; 【生产模块把 <code>cache</code> 给禁用掉了】</p></li> <li><p><strong>启动服务的差别</strong></p> <ol><li><code>webpack4</code> 启动服务 -&gt; <code>webpack-dev-server</code></li> <li><code>webpack5</code> 启动服务使用内置的 <code>webpack serve</code> 启动</li></ol></li> <li><p><strong>输出代码</strong></p> <ol><li><code>webpack4</code> 只能输出 <code>es5</code> 的代码</li> <li><code>webpack5</code> 新增属性 <code>output.ecmaVersion</code>，可以生成 <code>es5</code> 和 <code>es6</code> 的代码</li></ol></li> <li><p><strong>代码分割</strong></p> <ol><li><code>webpack4</code> 将超过 <code>30kb</code> 文件单独提为一个 <code>chunk</code>（<code>minSize: 30000</code>）</li> <li><code>webpack5</code> 可以区分是 <code>js</code> 还是 <code>css</code>，精准划分（<code>minSize: {javascript: 30000, css: 50000}</code>）</li></ol></li> <li><p><strong>模块联邦</strong> <code>Module Federation</code></p></li> <li><p><strong>devtool 差别</strong></p> <ol><li><p><code>webpack4</code> 有 13 种</p></li> <li><p><code>webpack5</code> 有 26 种</p> <p><strong>扩展</strong>：<code>webpack4</code> 一般开发环境配置 <code>cheap-eval-module-source-map</code>，在生产用 <code>none</code>；webpack5 使用 <code>eval-cheap-module-source-map</code></p></li></ol></li></ul> <h2 id="_6-grunt、gulp、webpack、rollup、vite-的比较？"><a href="#_6-grunt、gulp、webpack、rollup、vite-的比较？" aria-hidden="true" class="header-anchor">#</a> 6. Grunt、Gulp、Webpack、Rollup、Vite 的比较？</h2> <p><strong>模块化管理工具</strong> 和 <strong>自动化构建工具</strong> 是不同的。两者主要的侧重点不一样。<strong>自动化构建工具</strong> 则侧重于 <strong>前端开发的整个过程</strong> 的控制管理（像流水线）。而<strong>模块化管理工具</strong>更侧重于 <strong>模块打包</strong>。可以把开发中的所有资源（图片、js、css 文件等）都当成 <strong>模块</strong></p> <ul><li><p><strong>Webpack</strong>: 是当前最流行的 <code>模块化管理工具</code> 和 <code>打包工具</code>。其通过 loader 的转换，可以将任何形式的资源都当成模块。它还可以将各个模块通过其 <strong>依赖关系</strong> 打包成符合生产环境部署的前端资源。它还可以将应用程序分解成可管理的代码块，可以按需加载</p> <p><strong>打包原理</strong>：解析各个模块的依赖关系，使用 loader 转换文件，使用 plugin 注入钩子，打包合并模块，最终生成 bundle 文件，使用 express 开启本地服务器，浏览器请求的是 bundle 文件</p> <ul><li><strong>优点</strong>：
<ol><li>基本之前 gulp 可以操作的，webpack 都可以做</li> <li>同时支持<code>热更新</code>、<code>tree-shaking</code>、<code>Scope Hoisting</code>、<code>动态加载</code>、<code>代码拆分</code>、<code>文件指纹</code>、<code>代码压缩</code>、<code>静态资源处理</code>等</li> <li>支持多种打包方式</li></ol></li> <li><strong>缺点</strong>：
<ol><li>各个模块之间的依赖关系过于复杂 会导致打包速度很慢</li> <li>使用热更新时，改动一个模块，其他有依赖关系的模块也会重新打包</li> <li>不支持打包出 esm 格式的代码（打包后的代码再次被引用时 tree shaking 困难），打包后亢余代码较多</li></ol></li></ul></li> <li><p><strong>Vite</strong>：和 webpack 差不多，vite 是当下新型的 <code>模块化管理工具</code> 和 <code>打包工具</code>。它本地启动速度比 webpack 快了很多。但是 vite 还完成没有替换 webpack 的能力，不管是从社区还是从能力来说，vite 本身还是太过脆弱，它的产生和火热完成依赖于 vue 本身的热度</p> <p><strong>打包原理</strong>：就是启动一个 <code>koa</code> 服务器拦截由浏览器请求的 ESM 的请求，通过请求的路径找到目录下对应的文件做一定的处理，最终以 ESM 的格式返回给客户端</p> <p><img src="https://pic2.zhimg.com/80/v2-e3852ed76ec402c75f06c8d6ec8921d1_720w.jpg" alt></p> <p><code>Vite1.x</code> 使用 <code>koa</code>, <code>Vite2.x</code> 使用 <code>connect</code></p> <p>Vite 作为一个基于浏览器原生的 ESM 的构建工具，它省略了开发环境的打包过程，利用浏览器去解析 import，在服务端按需编译返回。同时，开发环境模块热更新也非常快，不会随着模块的增多而变慢。</p> <ul><li><p>Vite 的主要特性：</p> <ol><li>Instant Server Start —— 即时服务启动</li> <li>Lightning Fast HMR —— 闪电般快速的热更新</li> <li>Rich Features —— 丰富的功能</li> <li>Optimized Build —— 经过优化的构建</li> <li>Universal Plugin Interface —— 通用的 Plugin 接口</li> <li>Fully Typed APIs —— 类型齐全的 API</li></ol></li> <li><p><strong>缺点</strong>：</p> <ol><li>项目的开发浏览器要支持 <code>es module</code>, 要求浏览器比较新【<code>@vitejs/plugin-legacy</code>a】插件打包出一个兼容性比较好的版本</li> <li>生产环境使用 rollup 打包会造成开大环境与生产环境不一致</li> <li>生态没有 <code>webpack</code> 丰富</li> <li>很多第三方 SDK 没有产出 ems 格式的代码，这就需要我们自己去做一些兼容</li></ol> <p>对于一些 没有产出 esm 的模块，如何去兼容呢？</p> <p>业界是有一些如 <code>lebab</code> 的方法可以将 <code>commjs</code> 代码快速转化为 <code>esm</code> 的，但是对于一些格式不规范的代码，可能还是需要单独处理。</p></li></ul> <p>构建工具的发展：Browserify -&gt; Gulp -&gt; Parcel -&gt; Webpack -&gt; Rollup -&gt; (后来的非打包)Snowpack 和 Vite</p> <p><strong>注意</strong>：在 <code>Vite</code> 中约定若 <code>path</code> 的请求路径满足 <code>/^\/@modules\//</code> 格式时，被认为是一个 <code>node_modules</code> 模块。</p> <ul><li><p>Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</p> <ol><li>服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</li> <li>客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</li></ol></li> <li><p>Vite 的实现核心：</p> <ol><li>实现静态服务功能 -&gt; <code>koa-static</code></li> <li>解析 import 语法 重写路径 -&gt; <code>es-module-lexer</code> parse 方法</li> <li>解析 以/@modules 文件开头的内容 找到对应的结果，设置响应类型 type='js'返回给客户端</li> <li>处理 html 不存在 process</li> <li>解析.vue 文件</li></ol></li></ul></li> <li><p><strong>Rollup</strong>：是下一代 ES6 <strong>模块打包工具</strong>，可以将我们按照 ESM（ES2015 Module）规范编写的源码构建输出如下格式：</p> <ol><li>IIFE：自执行函数，可通过 script 标签加载</li> <li>AMD：通过 requirejs 加载</li> <li>CommonJS：Node 默认的模块规范，可通过 webpack 加载</li> <li>UMD：兼容 IIFE、AMD、CJS 三种模块规范</li> <li>ESM：ES2015 Module 规范，可用 webpack，rollup 加载</li></ol> <ul><li><p><strong>优点</strong>：</p> <ol><li>支持动态导入</li> <li>支持 tree-shaking。仅加载模块里用得到的函数以减少文件大小</li> <li>Scope Hoisting。rollup 可以将所有的小文件生成到一个大文件中，所有代码都在同一个函数作用域里；不会像 webpack 那样用很多函数来包装模块</li> <li>没有其他冗余代码, 执行很快。除了必要的 <code>cjs</code>, <code>umd</code> 头外，bundle 代码基本和源码差不多，也没有奇怪的 <code>__webpack_require__</code>, <code>Object.defineProperty</code> 之类的东西</li></ol></li> <li><p><strong>缺点</strong>：</p> <ol><li>不支持热更新功能</li> <li>对于 commonjs 模块，需要额外的插件将其转化为 es2015 供 rollup 处理</li> <li>无法公共代码拆分</li></ol></li></ul> <p><strong>适用场景</strong>：开发第三方库、生成单一的 umd 文件的场景</p> <p><strong>比较 Webpack</strong>：</p> <ol><li>Rollup 目前还不支持代码拆分（Code Splitting）和模块的热更新（HMR）</li> <li>一般，对于应用开发使用 Webpack，对于类库开发使用 Rollup</li> <li>需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 CommonJS 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup</li> <li>React 已经将构建工具从 Webpack 换成了 Rollup</li></ol></li> <li><p><strong>Gulp</strong>：是基于 <strong>流</strong> 的 <strong>前端自动化构建工具</strong>，采用代码优于配置的策略，更容易学习和使用，它让简单的任务简单，复杂的任务复杂</p> <ul><li><strong>优点</strong>：
<ol><li>gulp 文档简单，学习成本低，使用也比较简单</li> <li>对大量源文件可以进行流式处理，借助插件，可以对文件类型进行多种操作处理</li></ol></li> <li><strong>缺点</strong>：
<ol><li>不支持 tree-shaking、热更新、代码拆分等</li> <li>gulp 对 js 模块化方案无能为力，只是对静态资源做流式处理，处理之后并未做有效的优化整合</li></ol></li></ul> <p><strong>适用场景</strong>：静态资源密集操作型场景，主要用于 css、图片等静态资源的处理操作</p> <p><strong>比较 grunt</strong>:</p> <ol><li>易用，Gulp 相比于 Grunt 更简洁，而且遵循代码优于配置策略，维护 Gulp 更像是写代码</li> <li>高效，Gulp 核心设计是基于 Unix 的<strong>流</strong>的概念，通过<strong>管道</strong>连接，不需要写中间文件</li> <li>易学，Gulp 的核心 API 只有 5 个，之后可以通过管道流组合自己想要的任务</li> <li>流：使用 Grunt 的 I/O 过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。而使用 Gulp 的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次 I/O 的过程，流程更清晰，更纯粹</li> <li>代码优于配置：维护 Gulp 更像是写代码，而且 Gulp 遵循 CommonJS 规范，因此跟写 Node 程序没有区别</li></ol></li> <li><p><strong>Grunt</strong>：是一套 <strong>前端自动化工具</strong>，帮助处理反复重复的任务。一般用于：编译、压缩、合并文件，简单语法检查等</p> <ul><li><strong>特点</strong>：
<ol><li>Grunt 有一个完成的社区，插件丰富</li> <li>它简单易学，你可以随便安装插件并配置它们</li></ol></li></ul></li></ul> <p>Webpack 的定位是模块打包器，而 Gulp/Grunt 属于构建工具</p> <h2 id="_7-了解热更新原理吗？它是如何做到的？说说其原理？"><a href="#_7-了解热更新原理吗？它是如何做到的？说说其原理？" aria-hidden="true" class="header-anchor">#</a> 7. 了解热更新原理吗？它是如何做到的？说说其原理？</h2> <p>开启了 express 应用，添加了对 webpack 编译的监听，添加了和浏览器的 websocket 长连接，当文件变化触发 webpack 进行编译并完成后，会通过 socket 告诉浏览器准备刷新。而为了减少刷新的代价，就是<strong>不用刷新页面</strong>，而是<strong>刷新某个模块</strong>，webpack-dev-server 可以支持热更新，通过生成文件的 hash 来对比需要更新的模块，浏览器再进行热替换</p> <p><strong>扩展</strong>：hash、chunkhash、contenthash 三者的区别？</p> <ul><li><p>hash 一般是结合 CDN 缓存来使用的</p> <ol><li>hash：是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都公用相同的 hash 值（每一次构建都会生成新的 hash 值（不管文件是否有改动）-》导致没有办法实现缓存效果）</li> <li>chunkhash：和 hash 不一样，它根据不同的入口文件（entry）进行依赖文件解析，构建对于的 chunk，生成对应的哈希值。-》（同一个 chunk 的一个依赖改变了，其他的依赖哈希值也会变）</li> <li>contenthash：针对的是对应的内容是否改变</li></ol></li> <li><p>如何避免相同的随机值？
webpack 在<code>计算hash后分割chunk</code>。<code>产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）</code></p></li> <li><p><strong>扩展</strong>：CDN 原理？</p> <ol><li>用户输入域名，首先经过 dns 解析，请求 cname 指向的那台 cdn 专用的 dns 服务器</li> <li>dns 服务器返回全局负载均衡的服务器 IP 给用户</li> <li>用户请求全局负载均衡服务器，服务器根据 IP 返回所在区域的负载均衡服务器 IP 给用户</li> <li>用户请求区域负载均衡服务器，服务器根据 IP 选择距离最近的，负载比较合适的一台缓存服务器 IP 给用户。（当没有对应内容时，会去上一级缓存服务器去找，直到找到资源所在的服务器，并且缓存在缓存服务器中，供下次访问）</li></ol></li></ul> <p>域名 -&gt; dns 解析 -&gt; 全局负载均衡的服务器 -&gt; 所在区域的负载均衡服务器 -&gt; 缓存服务器</p> <ul><li><strong>CDN 回溯</strong>：就是 <code>CDN</code> 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程</li></ul> <h2 id="_8-sourcemap-有哪些？对应的作用是什么？"><a href="#_8-sourcemap-有哪些？对应的作用是什么？" aria-hidden="true" class="header-anchor">#</a> 8. sourceMap 有哪些？对应的作用是什么？</h2> <h2 id="_9-babel-的原理？"><a href="#_9-babel-的原理？" aria-hidden="true" class="header-anchor">#</a> 9. Babel 的原理？</h2> <p><code>Babel</code> 是 <code>JS</code> 语法转换器（将一些高级语法转换成浏览器可以识别的低级语法）</p> <ul><li><p><code>Babel</code> 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p> <ol><li><code>解析</code>（Parse） ：将源代码转换成更加抽象的表示方法（例如<code>抽象语法树</code>）。包括 <code>词法分析</code> 和 <code>语法分析</code>。词法分析主要把<code>字符流</code>源代码（<code>Char Stream</code>）转换成<code>令牌流</code>（ <code>Token Stream</code>）。语法分析主要是将 <code>令牌流</code> 转换成 <code>抽象语法树</code>（<code>Abstract Syntax Tree</code>，AST）。</li> <li><code>转换</code>（Transform） ：通过 <code>Babel</code> 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li> <li><code>生成</code>（Generate） ：将 AST 转换成<code>字符串形式</code>的<code>低版本</code>代码，同时也能创建 Source Map 映射。</li></ol></li> <li><p><strong>Babel 的原理</strong>：</p> <ol><li>使用 <code>babylon</code> 将 <code>源代码</code> 进行 <code>解析</code> -&gt; 得到 <code>AST</code></li> <li>使用 <code>babel-traverse</code> 对 <code>AST</code> 树进行遍历转义 -&gt; 得到新的 <code>AST</code> 树</li> <li>使用 <code>babel-generator</code> 通过 <code>AST</code> 树生成 <code>ES5</code> 代码</li></ol></li> <li><p><strong>Babel 的包构成</strong>：</p> <ol><li><code>babel-core</code>: <code>babel</code> 的核心库，提供一下 babel 转义 API，如 <code>babel.transform</code> 等，用于对代码进行转译。（<code>webpack</code> 的 <code>babel-loader</code> 是调用这些 API 来完成转译的）</li> <li><code>babylon</code>：<code>js</code> 的词法解析器</li> <li><code>babel-traverse</code>：用于对 <code>AST</code> 的遍历</li> <li><code>babel-generator</code>: 根据 <code>AST</code> 生成代码</li></ol></li> <li><p><strong>工具包和功能包</strong>：</p> <ol><li><code>babel-cli</code>：<code>babel</code> 的命令行工具，通过命令行对 js 代码进行转译</li> <li><code>babel-register</code>：通过绑定 <code>node.js</code> 的 <code>require</code> 来自动转译 <code>require</code> 引用的 <code>js</code> 代码文件</li> <li><code>babel-types</code>：用于检验、构建和改变 AST 树的节点</li> <li><code>babel-polyfill</code>：JS 标准新增的原生对象和 API 的 shim，实现上仅仅是 <code>core-js</code> 和 <code>regenerator-runtime</code> 两个包的封装</li> <li><code>babel-runtime</code>：功能类似 <code>babel-polyfill</code>，一般用于 <code>library</code> 或 <code>plugin</code> 中，因为它不会污染全局作用域</li></ol></li></ul> <p><strong>扩展</strong>：<code>babel-runtime</code> 和 <code>babel-polyfill</code> 的区别？</p> <p><code>babel</code> 默认只转译<code>新的 JS 语法</code>，而不转译<code>新的 API</code>（如：<code>Iterator</code>、<code>Set</code>、<code>Generator</code>、<code>Proxy</code>、<code>Symbol</code> 等全局对象），以及一些定义在全局对象上的方法（如：<code>Object.assign</code>）都不会转译。如果想使用这些新的对象和方法，则需要为当前环境提供一个 <code>polyfill</code></p> <ul><li><p><code>babel-polyfill</code>，它会加载整个 <code>polyfill</code> 库，解决了 <code>babel</code> 不转译<code>新 API</code> 的问题。并且在代码中 <code>插入一些帮助函数</code></p> <p><strong>缺点</strong>：直接在代码中插入帮助函数，会导致<code>污染了全局环境</code>；并且全部引入，打包后会有很多 <code>重复的代码</code>，导致编译后的代码体积变大</p></li> <li><p><code>babel-runtime</code>：<code>babel</code> 为了解决以上问题，提供了单独的包，用以提供编译模块的工具函数。启用 <code>babel-plugin-transform-runtime</code>（它会帮我自动动态 <code>require @babel/runtime</code> 中的内容）后，<code>babel</code> 就会使用 <code>babel-runtime</code> 下的工具函数；<strong>这样可以避免自行引入 polyfill 时导致的污染全局命名空间的问题</strong></p></li> <li><p><code>babel-runtime</code> 适合在组件，类库项目中使用，而 <code>babel-polyfill</code> 适合在业务项目中使用</p></li></ul> <p><strong>扩展</strong>：<code>babel-runtime</code> 为什么适合 <code>JavaScript</code> 库和工具包的实现？</p> <ol><li>避免 <code>babel</code> 编译的工具函数在每个模块里重复出现，减小库和工具包的体积</li> <li>在没有使用 <code>babel-runtime</code> 之前，库和工具包一般不会直接引入 <code>polyfill</code>。否则像 <code>Promise</code> 这样的全局对象会污染全局命名空间。在使用 <code>babel-runtime</code> 后，库和工具只要在 <code>package.json</code> 中增加依赖 <code>babel-runtime</code>，交给 <code>babel-runtime</code> 去引入 <code>polyfill</code> 就行了</li></ol> <p><strong>注意</strong>：具体项目还是需要使用 <code>babel-polyfill</code>，只使用 <code>babel-runtime</code> 的话，实例方法不能正常工作（例如 <code>&quot;foobar&quot;.includes(&quot;foo&quot;)</code>）</p> <h2 id="_10-module、chunk、bundle-分别是什么意思，有何区别？"><a href="#_10-module、chunk、bundle-分别是什么意思，有何区别？" aria-hidden="true" class="header-anchor">#</a> 10. module、chunk、bundle 分别是什么意思，有何区别？</h2> <ul><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 <strong>module</strong></li> <li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 <strong>chunk</strong> 文件，webpack 会对这个 chunk 文件进行一些操作</li> <li>webpack 处理好 chunk 文件后，最后会输出 <strong>bundle</strong> 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行</li></ul> <p><strong>总结</strong>：我们直接写出来的是 <code>module</code>，<code>webpack</code> 处理时是 <code>chunk</code>，最后生成浏览器可以直接运行的 <code>bundle</code></p> <h2 id="_11-webpack-optimize-有配置过吗-可以简单说说吗"><a href="#_11-webpack-optimize-有配置过吗-可以简单说说吗" aria-hidden="true" class="header-anchor">#</a> 11. Webpack optimize 有配置过吗?可以简单说说吗?</h2></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/chapter16/react.html" class="prev">
          React 部分
        </a></span> <span class="next"><a href="/chapter16/http.html">
          HTTP 部分
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.c45b4ff4.js" defer></script><script src="/assets/js/77.1304118a.js" defer></script>
  </body>
</html>
