<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、JS 相关 | 技术博客文章总结</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.c45b4ff4.js" as="script"><link rel="preload" href="/assets/js/71.e941d084.js" as="script"><link rel="prefetch" href="/assets/js/10.9cdf722f.js"><link rel="prefetch" href="/assets/js/100.9b45b75e.js"><link rel="prefetch" href="/assets/js/101.95c4d653.js"><link rel="prefetch" href="/assets/js/102.09cdc274.js"><link rel="prefetch" href="/assets/js/103.985d4863.js"><link rel="prefetch" href="/assets/js/104.66cfb550.js"><link rel="prefetch" href="/assets/js/105.78c4c309.js"><link rel="prefetch" href="/assets/js/106.34be9d25.js"><link rel="prefetch" href="/assets/js/107.0df352d3.js"><link rel="prefetch" href="/assets/js/108.901d6014.js"><link rel="prefetch" href="/assets/js/109.76339f5d.js"><link rel="prefetch" href="/assets/js/11.d22cc24d.js"><link rel="prefetch" href="/assets/js/110.c6e9ec88.js"><link rel="prefetch" href="/assets/js/111.d390a797.js"><link rel="prefetch" href="/assets/js/112.cf502784.js"><link rel="prefetch" href="/assets/js/113.aa449169.js"><link rel="prefetch" href="/assets/js/114.fc2133ce.js"><link rel="prefetch" href="/assets/js/115.523542e3.js"><link rel="prefetch" href="/assets/js/116.c3507815.js"><link rel="prefetch" href="/assets/js/117.23b5b1f0.js"><link rel="prefetch" href="/assets/js/118.5df8c262.js"><link rel="prefetch" href="/assets/js/119.8e1342c2.js"><link rel="prefetch" href="/assets/js/12.636890c7.js"><link rel="prefetch" href="/assets/js/120.01f21153.js"><link rel="prefetch" href="/assets/js/121.7b546d27.js"><link rel="prefetch" href="/assets/js/122.bd8c0286.js"><link rel="prefetch" href="/assets/js/123.f4f16ed2.js"><link rel="prefetch" href="/assets/js/124.ab5935d4.js"><link rel="prefetch" href="/assets/js/125.b29cf321.js"><link rel="prefetch" href="/assets/js/126.ddf1b9eb.js"><link rel="prefetch" href="/assets/js/127.4d63b823.js"><link rel="prefetch" href="/assets/js/128.f63c61cb.js"><link rel="prefetch" href="/assets/js/129.e74fb4b4.js"><link rel="prefetch" href="/assets/js/13.74a454d8.js"><link rel="prefetch" href="/assets/js/130.05f02f04.js"><link rel="prefetch" href="/assets/js/131.bac5f9b9.js"><link rel="prefetch" href="/assets/js/132.a98fffcf.js"><link rel="prefetch" href="/assets/js/133.5b34ebb6.js"><link rel="prefetch" href="/assets/js/14.ffe8d211.js"><link rel="prefetch" href="/assets/js/15.1bcc034f.js"><link rel="prefetch" href="/assets/js/16.87d6c8f3.js"><link rel="prefetch" href="/assets/js/17.576aa97e.js"><link rel="prefetch" href="/assets/js/18.8c80ffa6.js"><link rel="prefetch" href="/assets/js/19.bd2abc77.js"><link rel="prefetch" href="/assets/js/2.0379b669.js"><link rel="prefetch" href="/assets/js/20.56b31195.js"><link rel="prefetch" href="/assets/js/21.81d1d011.js"><link rel="prefetch" href="/assets/js/22.b52a1bed.js"><link rel="prefetch" href="/assets/js/23.76785e7d.js"><link rel="prefetch" href="/assets/js/24.4bcce340.js"><link rel="prefetch" href="/assets/js/25.b2de599f.js"><link rel="prefetch" href="/assets/js/26.944ed78e.js"><link rel="prefetch" href="/assets/js/27.0bbcee1a.js"><link rel="prefetch" href="/assets/js/28.223ed5b6.js"><link rel="prefetch" href="/assets/js/29.b88c0c25.js"><link rel="prefetch" href="/assets/js/3.b3231975.js"><link rel="prefetch" href="/assets/js/30.5754e2d0.js"><link rel="prefetch" href="/assets/js/31.038ca76a.js"><link rel="prefetch" href="/assets/js/32.7f0c55a6.js"><link rel="prefetch" href="/assets/js/33.7fd80664.js"><link rel="prefetch" href="/assets/js/34.8dcb3109.js"><link rel="prefetch" href="/assets/js/35.8b1fdc43.js"><link rel="prefetch" href="/assets/js/36.cf886fc0.js"><link rel="prefetch" href="/assets/js/37.f7abfe5d.js"><link rel="prefetch" href="/assets/js/38.f63c0deb.js"><link rel="prefetch" href="/assets/js/39.9b06b340.js"><link rel="prefetch" href="/assets/js/4.c1de1412.js"><link rel="prefetch" href="/assets/js/40.490eed30.js"><link rel="prefetch" href="/assets/js/41.b5abbdbc.js"><link rel="prefetch" href="/assets/js/42.1f6e4a3a.js"><link rel="prefetch" href="/assets/js/43.5e85acae.js"><link rel="prefetch" href="/assets/js/44.11b7ef0a.js"><link rel="prefetch" href="/assets/js/45.9774ff29.js"><link rel="prefetch" href="/assets/js/46.2cf4bc5b.js"><link rel="prefetch" href="/assets/js/47.bc79b4ef.js"><link rel="prefetch" href="/assets/js/48.0d80c17f.js"><link rel="prefetch" href="/assets/js/49.4fcabf82.js"><link rel="prefetch" href="/assets/js/5.1d97952d.js"><link rel="prefetch" href="/assets/js/50.7d65f488.js"><link rel="prefetch" href="/assets/js/51.2545cb57.js"><link rel="prefetch" href="/assets/js/52.36a2cca1.js"><link rel="prefetch" href="/assets/js/53.64484c50.js"><link rel="prefetch" href="/assets/js/54.52e5411a.js"><link rel="prefetch" href="/assets/js/55.4f773e83.js"><link rel="prefetch" href="/assets/js/56.a5437204.js"><link rel="prefetch" href="/assets/js/57.24dd7861.js"><link rel="prefetch" href="/assets/js/58.86388619.js"><link rel="prefetch" href="/assets/js/59.c9912d49.js"><link rel="prefetch" href="/assets/js/6.210e38ca.js"><link rel="prefetch" href="/assets/js/60.b29d00e8.js"><link rel="prefetch" href="/assets/js/61.13ff4966.js"><link rel="prefetch" href="/assets/js/62.8efcf596.js"><link rel="prefetch" href="/assets/js/63.5fa9582a.js"><link rel="prefetch" href="/assets/js/64.bbd14fec.js"><link rel="prefetch" href="/assets/js/65.bae7fd4f.js"><link rel="prefetch" href="/assets/js/66.8e3958d7.js"><link rel="prefetch" href="/assets/js/67.dac9beaa.js"><link rel="prefetch" href="/assets/js/68.1c7432eb.js"><link rel="prefetch" href="/assets/js/69.363a3505.js"><link rel="prefetch" href="/assets/js/7.1b6e0d8a.js"><link rel="prefetch" href="/assets/js/70.e4e45ab1.js"><link rel="prefetch" href="/assets/js/72.6c657f6c.js"><link rel="prefetch" href="/assets/js/73.910ec668.js"><link rel="prefetch" href="/assets/js/74.92f12f63.js"><link rel="prefetch" href="/assets/js/75.984c2f19.js"><link rel="prefetch" href="/assets/js/76.e4dddf5f.js"><link rel="prefetch" href="/assets/js/77.1304118a.js"><link rel="prefetch" href="/assets/js/78.36d67468.js"><link rel="prefetch" href="/assets/js/79.bebe2f90.js"><link rel="prefetch" href="/assets/js/8.23102c69.js"><link rel="prefetch" href="/assets/js/80.4f2da588.js"><link rel="prefetch" href="/assets/js/81.666e12e9.js"><link rel="prefetch" href="/assets/js/82.00e1d25e.js"><link rel="prefetch" href="/assets/js/83.6f17555a.js"><link rel="prefetch" href="/assets/js/84.71aca979.js"><link rel="prefetch" href="/assets/js/85.5da240e9.js"><link rel="prefetch" href="/assets/js/86.e9b29015.js"><link rel="prefetch" href="/assets/js/87.0c138ef2.js"><link rel="prefetch" href="/assets/js/88.d122fecd.js"><link rel="prefetch" href="/assets/js/89.ccb42cfb.js"><link rel="prefetch" href="/assets/js/9.7477a4ab.js"><link rel="prefetch" href="/assets/js/90.620b4440.js"><link rel="prefetch" href="/assets/js/91.a231af75.js"><link rel="prefetch" href="/assets/js/92.0bb536ea.js"><link rel="prefetch" href="/assets/js/93.a8d3b09d.js"><link rel="prefetch" href="/assets/js/94.4e3d0336.js"><link rel="prefetch" href="/assets/js/95.263fdc93.js"><link rel="prefetch" href="/assets/js/96.2886b194.js"><link rel="prefetch" href="/assets/js/97.d085eef0.js"><link rel="prefetch" href="/assets/js/98.eaf95a18.js"><link rel="prefetch" href="/assets/js/99.fbafbf7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术博客文章总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Vue 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6+</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>H5</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端设计模式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>面试总结</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级进阶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>源码手写</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>高级面试题汇总</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/chapter16/" class="sidebar-link">前端面试大纲</a></li><li><a href="/chapter16/html.html" class="sidebar-link">HTML 部分</a></li><li><a href="/chapter16/css.html" class="sidebar-link">CSS 部分</a></li><li><a href="/chapter16/js.html" class="sidebar-link">JS 部分</a></li><li><a href="/chapter16/vue.html" class="sidebar-link">Vue 部分</a></li><li><a href="/chapter16/react.html" class="sidebar-link">React 部分</a></li><li><a href="/chapter16/webpack.html" class="sidebar-link">Webpack 部分</a></li><li><a href="/chapter16/http.html" class="sidebar-link">HTTP 部分</a></li><li><a href="/chapter16/algorithm.html" class="sidebar-link">算法部分</a></li><li><a href="/chapter16/optimize.html" class="sidebar-link">优化部分</a></li><li><a href="/chapter16/performance.html" class="sidebar-link">开放性</a></li><li><a href="/chapter16/inter.html" class="active sidebar-link">2022</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter16/inter.html#一、js-相关" class="sidebar-link">一、JS 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#二、es6-相关" class="sidebar-link">二、ES6+相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#三、h5-css3-相关" class="sidebar-link">三、H5 &amp; CSS3 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#四、vue-相关" class="sidebar-link">四、Vue 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#五、react-相关" class="sidebar-link">五、React 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#六、http-相关" class="sidebar-link">六、HTTP 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#七、webpack-相关" class="sidebar-link">七、Webpack 相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#八、经典面试题" class="sidebar-link">八、经典面试题</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#九、版本控制相关" class="sidebar-link">九、版本控制相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#十、安全相关" class="sidebar-link">十、安全相关</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#十一、手写题" class="sidebar-link">十一、手写题</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#十二、性能优化" class="sidebar-link">十二、性能优化</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#十三、项目重难点" class="sidebar-link">十三、项目重难点</a></li><li class="sidebar-sub-header"><a href="/chapter16/inter.html#十四、开放性相关" class="sidebar-link">十四、开放性相关</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="一、js-相关"><a href="#一、js-相关" aria-hidden="true" class="header-anchor">#</a> 一、JS 相关</h2> <h3 id="_1-谈谈你对-this-的理解？"><a href="#_1-谈谈你对-this-的理解？" aria-hidden="true" class="header-anchor">#</a> 1. 谈谈你对 this 的理解？</h3> <ul><li><code>this</code> 永远指向最后调用它的那个对象</li> <li><code>this</code> 的指向有以下几种情况：
<ol><li>默认绑定</li> <li>隐式绑定</li> <li>显示绑定</li> <li>new 绑定</li> <li>箭头函数绑定</li></ol></li></ul> <p><strong>注意</strong>：箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则，<code>this</code> 为 <code>undefined</code></p> <h3 id="_2-说一说事件循环-event-loop？"><a href="#_2-说一说事件循环-event-loop？" aria-hidden="true" class="header-anchor">#</a> 2. 说一说事件循环 Event-Loop？</h3> <p>JS 是一门单线程语言（注意：JS 的主线程是单线程的）。JS 代码在执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还可以依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。任务队列分为：macro-task(宏任务)与 micro-task(微任务)</p> <p>Macro-task: script(整个)、setTimeout、setInterval、setImmediate、I/O 等</p> <p>Micro-task: process.nextTick、Promise、Async/Await(实际上就是 promise)、MutationObserver(H5 新特性)</p> <p><strong>总结</strong>：执行宏任务，然后执行该宏任务产生的微任务。若微任务在执行过程中产生了新的微任务，则继续执行微任务。当微任务执行完毕后，再回到宏任务中进行下一轮循环</p> <p><strong>扩展</strong>：</p> <ul><li><p>NodeJs 中的事件循环</p> <ol><li>timersj 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li> <li>I/O callbacks：执行一些系统调用错误，比如网络通信的错误回调</li> <li>idle,prepare：仅 node 内部使用</li> <li>poll：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li> <li>check：执行 setImmediate() 的回调</li> <li>close callbacks：执行 socket 的 close 事件回调</li></ol></li> <li><p>node 和浏览器 event-loop 的主要区别？</p> <p>两者最主要的区别在于：浏览器中的微任务是在每个相应的宏任务中执行的，而 node 中的微任务是在不同阶段之间执行的</p></li> <li><p>进程：资源分配的最小单位；线程：程序执行的最小单位</p></li> <li><p>H5 的新特性 Web Worker 可以创建多线程。就是在主线程开辟的一个额外的线程，这个线程与主线程不相互影响。通过 postMessage 和 onMessage 交互数据。它创建的子线程完全受控于主线程，且位于外部文件中，无法访问 DOM。所以它并没有改变 js 单线程的本质</p></li></ul> <p><strong>考察</strong>：【promise 和 async/await 的执行顺序】</p> <h3 id="_3-你了解-js-中原型-原型链吗？"><a href="#_3-你了解-js-中原型-原型链吗？" aria-hidden="true" class="header-anchor">#</a> 3. 你了解 JS 中原型 &amp; 原型链吗？</h3> <p>JS 中一切皆是对象，对象分为普通对象和函数对象。Object、Function 是 JS 自带的函数对象。凡是通过 new Function()创建的对象都是函数对象，其他的都是普通对象</p> <ul><li><p>构造函数：实例的构造函数属性（constructor）指向构造函数</p></li> <li><p>每个对象都有一个<code>__proto__</code>属性，但只有函数对象才有 prototype 属性 <code>__proto__</code> 内置属性用于指向创建它的构造函数的原型对象。p.<code>__proto__</code> === Person.prototype</p></li> <li><p>原型对象：一个普通对象（除了 Function.prototype 外，它是函数对象，也没有 prototype 属性）。原型对象（Person.prototype）是构造函数（Person）的一个实例 -》原型对象主要用于 <strong>继承</strong></p></li> <li><p>所有函数对象的<code>__proto__</code>都指向 Function.prototype，它是一个空函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person
person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype
person1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person

Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span>
</code></pre></div><p><strong>总结</strong>：原型链的形成真正是靠 <code>__proto__</code> 而非 prototype</p></li></ul> <h3 id="_4-作用域-与-作用域链了解吗？"><a href="#_4-作用域-与-作用域链了解吗？" aria-hidden="true" class="header-anchor">#</a> 4. 作用域 与 作用域链了解吗？</h3> <p>js 作为一种弱类型语言 ，变量声明没有那么严谨。于是就要有属于它独特 一套执行方式。作用域可以理解就是一块小的“地盘”一块代码段所在的地方</p> <ul><li><p>作用域（Scope）的分类：</p> <ol><li>全局作用域</li> <li>函数作用域（局部作用域）</li> <li>块级作用域（ES6 新增）</li></ol></li> <li><p>作用域链（Scope Chain）</p></li></ul> <p>内部函数访问外部函数的变量，采取的是链式查找的方法来决定取那个结构，这种结构称之为作用域链</p> <p><strong>扩展</strong>：作用域与执行上下文的区别？</p> <ul><li><p>区别 1：</p> <ol><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是函数调用</li> <li>全局执行上下环境是在作用域确定之后，js 代码立马执行之前创建</li> <li>函数执行上下环境是在调用函数时，执行函数体代码之前创建</li></ol></li> <li><p>区别 2：</p> <ol><li>作用域是静态的，只要函数定义好了就会一直存在，不会变化</li> <li>上下文环境是动态的，调用函数时创建，函数调用结束时上下环境会立即释放</li></ol></li></ul> <h3 id="_5-闭包-知道吗？"><a href="#_5-闭包-知道吗？" aria-hidden="true" class="header-anchor">#</a> 5. 闭包 知道吗？</h3> <p><strong>闭包</strong> 是指有权访问另一个函数作用域中的变量的函数--《JavaScript 高级程序设计》</p> <ul><li><p>闭包的特性</p> <ol><li>函数嵌套函数</li> <li>函数内部可以引用外部的参数和变量,封装私有的方法和变量，避免全局变量的污染</li> <li>本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</li></ol></li> <li><p>闭包的好处</p> <ol><li>可以读取函数内部的变量</li> <li>让这些变量的值始终保持在内存中</li></ol></li> <li><p>闭包的优点</p> <p>延长局部变量的生命周期</p></li> <li><p>闭包的缺点</p> <p>会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li> <li><p>闭包的应用场景</p> <p>闭包的两个场景，闭包的两大作用：保存/保护。 在开发中, 其实我们随处可见闭包的身影, 大部分前端 JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送 ajax 请求成功|失败的回调;setTimeout 的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用</p></li></ul> <h3 id="_6-判断数据类型的方式？以及优缺点？"><a href="#_6-判断数据类型的方式？以及优缺点？" aria-hidden="true" class="header-anchor">#</a> 6. 判断数据类型的方式？以及优缺点？</h3> <ul><li><p>基本数据类型</p> <p>null、undefined、string、boolean、number、（ES6 新增）Symbol、BigInt</p></li> <li><p>引用数据类型</p> <p>object</p></li></ul> <p><strong>扩展</strong>：新增两个原始数据类型</p> <p>Record &amp; Tuple：就是一个<strong>只读</strong>的 Object 和 Array</p> <ul><li>基本用法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Record</span>
<span class="token keyword">const</span> myRecord <span class="token operator">=</span> #<span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">,</span>
  age<span class="token punctuation">:</span> <span class="token number">27</span>
<span class="token punctuation">}</span>
<span class="token comment">// Tuple</span>
<span class="token keyword">const</span> myTuple <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code></pre></div><p><strong>特点</strong>：其实就是在之前的对象和数组前面加了个#</p> <ul><li><p>特性</p> <ol><li>可读特性</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myRecord <span class="token operator">=</span> #<span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">,</span>
  age<span class="token punctuation">:</span> <span class="token number">27</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> myTuple <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
myRecord<span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token comment">// error</span>
myTuple<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// error</span>
</code></pre></div><ol start="2"><li>非唯一性</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1 <span class="token operator">===</span> arr2<span class="token punctuation">)</span> <span class="token comment">// false</span>
因为每个生成的对象在内存中的地址都不一样
<span class="token keyword">const</span> obj3 <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj4 <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token keyword">const</span> arr3 <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> arr4 <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1 <span class="token operator">===</span> arr2<span class="token punctuation">)</span> <span class="token comment">// true</span>
只要内部内容一致，就是相等的
</code></pre></div><ol start="3"><li>普通对象和数组的转换</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myRecord <span class="token operator">=</span> <span class="token function">Record</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'tmc'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// #{name: 'tmc'}</span>
<span class="token keyword">const</span> myTuple <span class="token operator">=</span> <span class="token function">Tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// #[1, 2, 3]</span>
</code></pre></div><ol start="4"><li>支持扩展运算符</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myTuple <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> myRecord <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tmc'</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> newTuple <span class="token operator">=</span> #<span class="token punctuation">[</span><span class="token operator">...</span>myTuple<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token comment">// #[1, 2, 3, 4, 5]</span>
<span class="token keyword">const</span> newRecord <span class="token operator">=</span> #<span class="token punctuation">{</span><span class="token operator">...</span>myRecord<span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">27</span><span class="token punctuation">}</span> <span class="token comment">// #{name: 'tmc', age: 27}</span>
</code></pre></div></li> <li><p>如何使用</p> <ol><li>安装 babel 插件</li></ol> <div class="language-sh extra-class"><pre class="language-text"><code>  # babel基本的库
  yarn add @babel/cli @babel/core @babel/preset-env -D
  # Record 和 Tuple 的Babel polyfill
  yarn add @babel/plugin-proposal-record-and-tuple @bloomberg/record-tuple-polyfill - D
</code></pre></div><ol start="2"><li>根目录创建 <code>.babelrc</code></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;presets&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;@babel/preset-env&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">&quot;plugins&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span>
      <span class="token string">&quot;@babel/plugin-proposal-record-and-tuple&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token string">&quot;importPolyfill&quot;</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token string">&quot;syntaxType&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;hash&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>直接使用</li></ol></li> <li><p>应用场景</p> <ol><li>用于保护一些数据，比如：函数的返回值、对象内部的静态属性...</li> <li>既然具有只读的特性，即不可变对象，那应该也可以作为对象的 key 值</li></ol></li> <li><p>数据判断类型方法</p> <ul><li><p>方式一：typeof</p> <ol><li>在基本数据类型中：除了 null 以外，使用 typeof 均可得到正确的结果</li> <li>在引用数据类型中：除了 function 以外，使用 typeof 都得到 object</li></ol></li> <li><p>方式二：instanceof</p> <ul><li><p>用来判断 xx 是否是 xx 的实例。是则返回 true,否则返回 false。语法：[对象] instanceof [构造函数]</p></li> <li><p>instanceof 有以下几点需要注意：</p> <ol><li>左侧必须是对象 object, 如果不是，则返回 false</li> <li>instanceof 检查的 <strong>原型</strong></li></ol></li></ul></li> <li><p>方式三：constructor</p></li></ul> <ol><li>原理是利用函数的原型对象的 constructor 属性指向其构造函数</li> <li>constructor 需要注意：null 和 undefined 是无效对象，没有 constructor</li></ol> <ul><li>方式四：toString【最好】</li></ul> <ol><li>toString 是 object 原型上的方法，默认会返回[[Class]] -&gt; [object String]</li> <li>toString 需要注意：对于其他对象，我们需要通过 <code>call</code>、<code>apply</code>、<code>bind</code>来改变<code>this</code>的指向后才能返回正确的结果</li></ol></li></ul> <p><strong>扩展</strong>：obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p> <ul><li>这是因为 toString 为 Object 的原型方法，而 Array 、Function 等类型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法，而不会去调用 Object 上原型 toString 方法，所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 上原型 toString 方法</li></ul> <h3 id="_7-js-中继承的方式有哪些？"><a href="#_7-js-中继承的方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 7. JS 中继承的方式有哪些？</h3> <ul><li><p>原型链继承：父类的实例作为子类的原型</p> <p><strong>缺点</strong>： 可以访问父类原型上的属性和方法，但是父构造函数上的属性和方法会被子类共享； 子类的实例都是访问的同一个原型对象。共享的是同一份数据-》导致数据可能被篡改</p></li> <li><p>构造函数继承（借用 call）：复制父类的实例属性给子类</p> <p><strong>缺点</strong>： 可以获取到父类的属性和方法。但是不能获取到父类原型上的方法</p></li> <li><p>组合继承（原型链继承 + 钩子函数继承）</p> <p><strong>缺点</strong>： 子类不仅自己独享一份父构造函数上的属性，还能访问父类原型上的属性和方法。 -》 父构造函数 Parent 被调用的次数太多了（假如 Parent 的构造函数代码量很大，每一次的继承都是一笔不小的性能开销）</p></li> <li><p>原型式继承（借用 Object.create）</p> <p>就是生成了一个原型的 <strong>proto</strong> 指针指向传入对象的对象而已。然后生成的对象可以通过原型链来访问原型对象的属性和方法</p></li> <li><p>寄生式继承（借用 Object.create 和工厂模式）</p></li> <li><p>组合寄生式继承</p></li></ul> <h3 id="_8-js-中数据的转换机制？"><a href="#_8-js-中数据的转换机制？" aria-hidden="true" class="header-anchor">#</a> 8. JS 中数据的转换机制？</h3> <p>比如：let x；虽然 js 中有很多数据类型，但我们在申明的时候只有一种数据类型，只有到运行期间才会确定当前类型。虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p> <p>常见的类型转换有：</p> <ul><li><p>强制转换（显示转换）</p> <ol><li>Number()：将任意类型的值转化为数值</li></ol> <p>undefined -&gt; NaN; null -&gt; 0; true -&gt; 1; false -&gt; 0; ....Object -&gt; 先调用 toPrimitive，再调用 toNumber</p> <p><strong>注意</strong>：</p> <ul><li>Number()转换字符串的时候，Number('')-&gt;0; Number('324abc') -&gt; NaN; Number('324')-&gt; 324</li> <li>Number()转换对象的时候,<em>通常转换成 NaN(除了只包含单个数值的数组)</em>，Number({a: 1})-&gt;NaN;Number([1, 2, 3])-&gt;NaN;Number([5])-&gt;5</li></ul> <ol start="2"><li>parseInt()：<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</li></ol> <p>parseInt('32a3') // 32</p> <ol start="3"><li>String()：可以将任意类型的值转化成字符串</li></ol> <p>String({a: 1})-&gt;&quot;[object Object]&quot;; String([1, 2, 3]) <em>// &quot;1,2,3&quot;</em>；其余的都是”类型“</p> <ol start="4"><li>Boolean()：可以将任意类型的值转为布尔值</li></ol> <p>Undefined,null,0,NaN,'' -&gt; false; {}, [] -&gt; true</p></li> <li><p>自动转换（隐式转换）</p> <p>隐式转换的场景：（要求运算符两边的操作数不是同一类型）</p> <ol><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li> <li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ol> <ul><li>undefined、null、false、+0、-0、NaN、‘’都会被转成 false；其余的都是 true</li> <li>自动转换成字符串，具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</li> <li>自动转换成数值，除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</li></ul></li></ul> <p><strong>扩展</strong>：== 和 === 有什么区别？
=== 叫做严格相等，是指：左右两边不仅值要相等，类型也要相等</p> <p>== 不像 === 那样严格，对于一般情况，只要值相等，就返回 true，但 == 还涉及一些类型转换，它的转换规则如下：</p> <ol><li>两边的类型是否相同，相同的话就比较值的大小，例如 1==2，返回 false</li> <li>判断的是否是 null 和 undefined，是的话就返回 true</li> <li>判断的类型是否是 String 和 Number，是的话，把 String 类型转换成 Number，再进行比较</li> <li>判断其中一方是否是 Boolean，是的话就把 Boolean 转换成 Number，再进行比较</li> <li>如果其中一方为 Object，且另一方为 String、Number 或者 Symbol，会将 Object 转换成字符串，再进行比较</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">//false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token operator">==</span> <span class="token string">'[object Object]'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><p><strong>注意</strong>：它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及+0 等于-0。Object.is 修复了 +0 和-0，NaN 和 NaN 相等的问题</p> <p><strong>扩展</strong>：对象转原始类型是根据什么流程运行的？</p> <p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p> <ol><li>如果 Symbol.toPrimitive()方法，优先调用再返回</li> <li>调用 valueOf()，如果转换为原始类型，则返回</li> <li>调用 toString()，如果转换为原始类型，则返回</li> <li>如果都没有返回原始类型，会报错</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">4</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'5'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">6</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 输出7</span>
</code></pre></div><p><strong>应用</strong>：如何让 if(a == 1 &amp;&amp; a == 2)条件成立？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token function-variable function">valueOf</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token operator">++</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="_9-说说-函数式编程里的高阶函数、函数柯里化、组合函数等？"><a href="#_9-说说-函数式编程里的高阶函数、函数柯里化、组合函数等？" aria-hidden="true" class="header-anchor">#</a> 9. 说说 函数式编程里的高阶函数、函数柯里化、组合函数等？</h3> <p>在 JavaScript 中，函数为一等公民（First Class），所谓的 “一等公民”，指的是函数与其他数据类型一样，处于平等地位，<code>可以赋值给其他变量</code>，<code>也可以作为参数，传入另一个函数</code>，或<code>作为其它函数的返回值</code>。</p> <p>由于函数式编程具有代码质量高且易于维护的特点，其应用也越来越广泛。许多不支持函数式编程的语言也加入了闭包，匿名函数等函数式编程特性。</p> <ul><li>纯函数：输出不受外部环境影响，同时也不影响外部环境，无副作用</li> <li>高阶函数：至少满足两个条件：它接收一个或多个函数作为参数、将函数作为输出返回
debounce  和  throttle
<ol><li>高阶函数：（如果函数的参数的一个函数，如果一个函数返回了一个函数，两者都被称为高阶函数）</li> <li>高阶函数的应用: (如果一个函数中前后想执行什么操作，就可以执行高阶函数;重写一些原生的方法;AOP 面向切面编程)</li></ol></li> <li>函数组合：就是将两个或两个以上的函数组合生成一个新函数的过程</li> <li>柯里化：是函数式编程中的一种进阶技巧。直接表现形式就是，当我们有一个函数 f(a,b,c)，通过柯里化转换，使得这个函数可以被这样调用 f(a)(b)(c)。
用途：参数可以复用，便于封装语法糖</li></ul> <h3 id="_10-深拷贝和浅拷贝的区别？如何实现一个深拷贝？（考虑正则，date-这种类型的数据）"><a href="#_10-深拷贝和浅拷贝的区别？如何实现一个深拷贝？（考虑正则，date-这种类型的数据）" aria-hidden="true" class="header-anchor">#</a> 10. 深拷贝和浅拷贝的区别？如何实现一个深拷贝？（考虑正则，Date 这种类型的数据）</h3> <p>JavaScript 中存在两大数据类型：基本类型、引用类型。 基本类型数据保存在在栈内存中；引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p> <ul><li>浅拷贝：对原始对象属性值的一份精确拷贝，若属性是基本类型，就拷贝其基本类型的值；若属性是引用类型，则拷贝的是内存地址。所以，若其中一个地址变了后就会影响到另一个对象
<ul><li>常见的浅拷贝方式有：
<ol><li>Object.assign -&gt; Object.assign({}, obj)</li> <li>Array.prototype.slice(), Array.prototype.concat() -&gt; arr.slice(0); arr.concat()</li> <li>...扩展运算符 -&gt; [...obj]</li></ol></li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newObj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newObj
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>深拷贝：指的是开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p> <ul><li><p>常见的深拷贝方式有：</p> <ol><li>_.cloneDeep()【lodash】 -&gt; _.cloneDeep(obj)</li> <li>jQuery.extend()【jQuery】 -&gt; $.extend(true, {}, obj)</li> <li>JSON.parse(JSON.stringify()) -&gt; JSON.parse(JSON.stringify(obj))
这种方式最简单，但有以下弊端：
<ul><li>当被拷贝对象中有 <code>Date</code> 对象，则拷贝后时间将以<code>字符串</code>的形式</li> <li>当被拷贝对象中有 <code>RegExp</code>、<code>Error</code> 对象，则拷贝的结果将得到一个<code>空对象</code></li> <li>当被拷贝对象中有 <code>undefined</code> 和 <code>函数</code> 的时，则拷贝的结果将会把函数或 undefined <code>丢失</code></li></ul></li> <li>手写递归</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>写一个深拷贝，考虑正则，Date这种类型的数据
<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> target <span class="token comment">// 如果是null或者undefined，不进行拷贝操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token comment">// let cloneTarget = Array.isArray(target) ? [] : {}</span>
    <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> target<span class="token punctuation">.</span>constructor <span class="token comment">// constructor没参数可以不写()</span>
    hash<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> cloneTarget<span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cloneTarget
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 普通值</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：null == undefined 为 true null === undefined 为 false</p></li></ul></li> <li><p>两者的区别：</p> <ol><li>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</li> <li>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</li></ol></li></ul> <h3 id="_11-js-中执行上下文-和-执行栈是什么？"><a href="#_11-js-中执行上下文-和-执行栈是什么？" aria-hidden="true" class="header-anchor">#</a> 11. JS 中执行上下文 和 执行栈是什么？</h3> <p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境</p> <ul><li><p>执行上下文总共有三种类型：</p> <ol><li>全局执行上下文： 默认的。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文</li> <li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建</li> <li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文</li></ol></li> <li><p>执行上下文的生命周期包括三个阶段：<code>创建阶段</code> → <code>执行阶段</code> → <code>回收阶段</code></p> <ol><li>创建阶段
<strong>扩展</strong>：当函数被调用，但未执行任何其内部代码之前，会做以下三件事：
<ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明</li> <li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li> <li>确定 this 指向</li></ul></li> <li>执行阶段
<strong>扩展</strong>：执行变量赋值、代码执行</li> <li>回收阶段
<strong>扩展</strong>：执行上下文出栈等待虚拟机回收执行上下文</li></ol></li> <li><p>变量提升
大部分编程语言都是先声明变量再使用，但在 JS 中，事情有些不一样：</p> <ol><li>变量声明提升</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">// 上述代码正常输出undefined而不是报错Uncaught ReferenceError: a is not defined,这是因为声明提升（hoisting）</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 等价于 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span> <span class="token comment">// 声明，默认值是undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 赋值</span>
</code></pre></div><ol start="2"><li>函数声明提升
创建一个函数的方法有两种，一种是通过函数声明 function foo(){}, 另一种是通过函数表达式 var foo = function(){} ,那这两种在函数提升有什么区别呢？</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// function f1(){}</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数声明</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数表达式</span>
</code></pre></div><p><strong>注意</strong>：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 输出function a() {}</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>
<span class="token comment">// function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 等价于 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span> <span class="token comment">// undefined -&gt; hoisting</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 输出function a() {}</span>
a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>
</code></pre></div><p><strong>总结</strong>：变量提升的规则：函数申明整体提升；变量声明提升值为 undefined</p></li> <li><p>确认 this 的指向
很重要的概念 —— <code>this 的值是在执行的时候才能确认，定义的时候不能确认！</code>
为什么呢 ? 因为 this 是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：</p></li> <li><p>执行上下文栈
函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？JavaScript 引擎创建了执行上下文栈来管理执行上下文。<code>可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</code> <strong>扩展</strong>：需要记住几个关键点：</p> <ol><li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li> <li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li> <li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li> <li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li> <li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li></ol></li></ul> <h3 id="_12-了解-预编译-吗？"><a href="#_12-了解-预编译-吗？" aria-hidden="true" class="header-anchor">#</a> 12. 了解 预编译 吗？</h3> <ul><li>js 运行代码共分三步：
<ol><li>语法分析
顾名思义就是检查一遍 JS 代码内有没有出息语法错误（比如少分号，多写括号等）；语法分析期间不会执行代码</li> <li>预编译
这个阶段发送在代码执行的前一刻，这个过程说白了就是在内存里面创建一个空间，用来存你定义的变量和函数（放东西的）</li> <li>解析执行
执行代码</li></ol></li></ul> <p>JS 在执行前会产生一个 GO（Global Object）也就是我们说的全局作用域。当一个方法被调用时会形成一个局部作用域 AO（Activation Object）</p> <ul><li>预编译发生在函数执行的前一刻, 预编译阶段做了哪些事情？
<ol><li>创建 AO(Activation Object)对象（里面存储的是函数内部的局部变量）</li> <li>找形参和变量声明，将变量和形参名做为 AO 属性名，值为 undefined</li> <li>将实参和形参统一，即更改形参后的 undefined 为具体的形参值</li> <li>找函数的申明 会覆盖相同变量的申明</li></ol></li></ul> <p>在全局作用域里，预编译过程有些许不同</p> <ul><li>GO 对象的过程如下：
<ol><li>创建 GO 对象</li> <li>寻找变量声明，值设定为 undefined</li> <li>寻找函数中的函数声明，将函数名作为 GO 属性名，值为函数体</li></ol></li></ul> <h3 id="_13-知道-事件代理吗？有什么应用场景？"><a href="#_13-知道-事件代理吗？有什么应用场景？" aria-hidden="true" class="header-anchor">#</a> 13. 知道 事件代理吗？有什么应用场景？</h3> <p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素。当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p> <p>事件代理，俗地来讲，就是把一个元素响应事件（click...）的函数委托到另一个元素</p> <p><strong>扩展</strong>：事件流的都会经过三个阶段： <code>捕获阶段</code> -&gt; <code>目标阶段</code> -&gt; <code>冒泡阶段</code></p> <ul><li><p>应用场景</p> <ol><li>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件。如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的。这时候就可以事件委托，把点击事件绑定在父级元素 ul 上面，然后执行事件的时候再去匹配目标元素</li> <li>动态绑定事件，动态的增加或者去除列表项元素</li></ol></li> <li><p>总结
适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code></p> <p>事件委托存在两大优点：</p> <ol><li>减少整个页面所需的内存，提升整体性能</li> <li>动态绑定，减少重复工作</li></ol> <p>使用事件委托也是存在局限性：</p> <ol><li>focus、blur 这些事件没有事件冒泡机制，所以无法进行委托绑定事件</li> <li>mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li></ol></li></ul> <h3 id="_14-说说-js-中的垃圾回收机制-与-内存泄漏？"><a href="#_14-说说-js-中的垃圾回收机制-与-内存泄漏？" aria-hidden="true" class="header-anchor">#</a> 14. 说说 JS 中的垃圾回收机制 与 内存泄漏？</h3> <p>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存。对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong></p> <p><strong>扩展</strong>：有些语言（比如 c 语言）必须手动释放内存。大多数语言提供自动内存管理，减轻程序员的负担，这被称为&quot;垃圾回收机制&quot;</p> <ul><li>js 垃圾回收机制原理：解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。</li></ul> <p>现在各大浏览器通常采用的垃圾回收机制有两种方法：<code>标记清除</code>【常用】，<code>引用计数</code>。</p> <ul><li><p>标记清除
js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;。而当变量离开环境时，则将其标记为&quot;离开环境&quot;。垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。（先所有都加上标记，再把环境中引用到的变量去除标记。剩下的就是没用的了）</p></li> <li><p>引用计数
语言引擎有一张&quot;引用表&quot;，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。（跟踪记录每 个值被引用的次数。清除引用次数为 0 的变量 ⚠️ 会有循环引用问题 。循环引用如果大量存在就会导致内存泄露。）</p></li> <li><p>内存泄漏的识别方法：</p> <ol><li><p>浏览器
开发者工具 -&gt; 选择 Timeline 面板 -&gt; 顶部的 Capture 字段里面勾选 Memory -&gt; 点击左上角的录制按钮 -&gt; 在页面上进行各种操作，模拟用户的使用情况 -&gt; 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况</p> <p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏</p></li> <li><p>命令行 process.memoryUsage()返回一个对象，包含了 Node 进程的内存占用信息</p></li> <li><p>ES6 推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个&quot;Weak&quot;，表示这是<code>弱引用</code> <strong>扩展</strong>：内存泄漏的场景</p></li></ol></li></ul> <h3 id="_15-websocket-的原理是啥？"><a href="#_15-websocket-的原理是啥？" aria-hidden="true" class="header-anchor">#</a> 15. WebSocket 的原理是啥？</h3> <p>WebSocket 是 HTML5 出的东西（协议）,是一个持久化的协议. 是基于 HTTP 协议的，或者说借用了 HTTP 的协议来完成一部分握手</p> <p><strong>问题</strong>：HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 典型的 Websocket 握手</span>
<span class="token constant">GET</span> <span class="token operator">/</span>chat <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token punctuation">:</span> server<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com
Upgrade<span class="token punctuation">:</span> websocket
Connection<span class="token punctuation">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key<span class="token punctuation">:</span> x3JJHMbDL1EzLkh9GBhXDw<span class="token operator">==</span> <span class="token comment">// 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：我要验证你是不是真的websocket协议</span>
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token punctuation">:</span> chat<span class="token punctuation">,</span> superchat <span class="token comment">// 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议;简单理解：今晚我要服务A，别搞错啦~</span>
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Version<span class="token punctuation">:</span> <span class="token number">13</span> <span class="token comment">// 是告诉服务器所使用的 Websocket Draft （协议版本）</span>
Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com

<span class="token comment">// 服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</span>
<span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">101</span> Switching Protocols
Upgrade<span class="token punctuation">:</span> websocket
Connection<span class="token punctuation">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Accept<span class="token punctuation">:</span> HSmrc0sMlYUkAGmm5OPpG2HaGWk<span class="token operator">=</span> <span class="token comment">// 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key</span>
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token punctuation">:</span> chat <span class="token comment">// 则是表示最终使用的协议</span>
</code></pre></div><p><strong>扩展</strong>：</p> <ol><li>ajax 轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</li> <li>long poll 其实原理跟 ajax 轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</li></ol> <ul><li>Websocket 的作用
<ol><li>服务端就可以主动推送信息给客户端</li> <li>可以以任何一种方式非常有效地发送数据。由于已经建立了连接并且非常有效地组织了 webSocket 数据帧，因此与通过 HTTP 请求（其中必须包含标头，Cookie 等）相比，可以更高效地发送数据。</li></ol></li></ul> <h3 id="_16-require-和-import-的区别？-es6-module-和-commonjs-区别？"><a href="#_16-require-和-import-的区别？-es6-module-和-commonjs-区别？" aria-hidden="true" class="header-anchor">#</a> 16. require 和 import 的区别？/ ES6 Module 和 Commonjs 区别？</h3> <ol><li>导入 require 导出 exports/module.exports 是 CommonJS 的标准，通常适用范围如 Node.js</li> <li>import/export 是 ES6 的标准</li> <li>commonjs 输出的，是一个值的拷贝，而 es6 输出的是值的引用</li> <li>commonjs 是运行时加载，es6 是编译时输出接口</li></ol> <p><strong>注意</strong>：require 是浅拷贝，也就是说你可以修改对象第二层的属性并影响原数据；import 是引用，基本数据类型，修改不会影响原数据，但是对象修改属性会影响。import 具有置顶性, 它不是一定要放在文件的顶部</p> <ol><li>ES6 Module 静态引入，编译时引入</li> <li>CommonJs 动态引入，执行(执行)时引入</li> <li>只有 ES6 Module 才能静态分析，实现 Tree-Shaking</li> <li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</li></ol> <p><strong>优势</strong>： CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 Modules 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p> <h3 id="_17-为何-proxy-不能被-polyfill"><a href="#_17-为何-proxy-不能被-polyfill" aria-hidden="true" class="header-anchor">#</a> 17. 为何 Proxy 不能被 Polyfill?</h3> <ol><li>如 Class 可以用 function 模拟</li> <li>如 Promise 可以用 callback 来模拟</li> <li>但 Proxy 的功能用 Object.defineProperty 无法模拟</li></ol> <h3 id="_18-编译器一般由哪几个阶段组成？"><a href="#_18-编译器一般由哪几个阶段组成？" aria-hidden="true" class="header-anchor">#</a> 18. 编译器一般由哪几个阶段组成？</h3> <p>编译器一般由 4 个阶段工作完成：</p> <ol><li>Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</li> <li>Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</li> <li>TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</li> <li>Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。</li></ol> <p><strong>注意</strong>：数据类型检查 一般在 Parse 阶段之前 就进行了，因为在生成 AST 之前 就要进行语法分析，提取出句子的结构</p> <h1 id><a href="#" aria-hidden="true" class="header-anchor">#</a></h1> <h2 id="二、es6-相关"><a href="#二、es6-相关" aria-hidden="true" class="header-anchor">#</a> 二、ES6+相关</h2> <h3 id="_1-es6-有哪些新特性？"><a href="#_1-es6-有哪些新特性？" aria-hidden="true" class="header-anchor">#</a> 1. ES6 有哪些新特性？</h3> <p>let,const；解构赋值；箭头函数；数组/对象/函数字符串等的扩展；Proxy；Reflect；Iterator；Set/WeakSet；Map/WeakMap；Symbol；Promise；Async+await；Generator；类；Module 模块化</p> <p><strong>注意</strong>：...在函数参数中叫<code>剩余运算符</code>(将所有的参数组合成一个数组，只能在最后一个参数)；在函数中调用是<code>展开运算符</code></p> <h3 id="_2-能手写一个完整的-promise-吗？及其静态方法？"><a href="#_2-能手写一个完整的-promise-吗？及其静态方法？" aria-hidden="true" class="header-anchor">#</a> 2. 能手写一个完整的 Promise 吗？及其静态方法？</h3> <ul><li>优点
<ol><li>可以解决异步嵌套问题</li> <li>可以解决多个异步并发的问题</li></ol></li> <li>缺点
<ol><li>promise 也是基于回调的</li> <li>promise 无法终止</li></ol></li></ul> <p><strong>扩展</strong>：</p> <ul><li><p>async+ await 如何处理错误？</p> <p>Promise 可以通过 catch 捕获错误，async+await 通过<strong>await-to-js</strong>捕获错误</p></li> <li><p>async+await 的原理？</p> <p>async+await 就是 Generator+yield 的<strong>语法糖</strong></p></li> <li><p>实现简版的 generator?</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">selfGenerator</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> done <span class="token operator">=</span> index <span class="token operator">&gt;=</span> len
      <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token operator">!</span>done <span class="token operator">?</span> arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token keyword">undefined</span>

      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        done<span class="token punctuation">:</span> done<span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> value<span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// yield返回iterator [...it]</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_3-怎么理解-set、map-两种数据结构？"><a href="#_3-怎么理解-set、map-两种数据结构？" aria-hidden="true" class="header-anchor">#</a> 3. 怎么理解 Set、Map 两种数据结构？</h3> <ul><li><p>Set 是一种叫做<strong>集合</strong>的数据结构，类似于数组。但成员是唯一且无需的，没有重复的值</p></li> <li><p>Map 是一种叫做 <strong>字典</strong>的数据结构</p></li> <li><p>WeakSet 与 Set 的本质区别：</p> <ol><li>WeakSet 只能存储对象引用，不能存放值；而 Set 对象都可以存放</li> <li>WeakSet 对象中存储的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet</li></ol></li> <li><p>Object 里的 key 只能是字符串（或 Symbol）,Map 的里的 key 可以放任何类型</p></li> <li><p>WeakMap 与 Map 的本质区别：</p> <ol><li>WeakMap 的键必须是对象，而值可以是任意的</li> <li>WeakMap 中的对象都是弱引用的</li></ol></li></ul> <p><strong>注意</strong>：Set 和 Map 注意的应用场景在于 <strong>数组去重</strong> 和 <strong>数据存储</strong></p> <h3 id="_4-symbol-的应用场景"><a href="#_4-symbol-的应用场景" aria-hidden="true" class="header-anchor">#</a> 4. Symbol 的应用场景</h3> <ul><li>Symbol 是基本数据类型，特点：独一无二【一般作为对象的 key】</li> <li>Symbol 属性默认是不能枚举的，可通过 Object.getOwnPropertySymbols(), Reflect.keys()获取</li> <li>Symbol 有两个静态方法：Symbol.for, Symbol.keyFor</li> <li>Symbol 具有元编程的能力，可以改写语法本身。（hasInstance, species, match,iterator, toPrimitive, toStringTag 等 11 种）</li> <li>Symbol 可以模拟类的私有方法</li></ul> <h3 id="_5-普通函数与箭头函数的区别？"><a href="#_5-普通函数与箭头函数的区别？" aria-hidden="true" class="header-anchor">#</a> 5. 普通函数与箭头函数的区别？</h3> <ol><li>箭头函数是匿名函数，不能作为构造函数，不能使用 new。</li> <li>箭头函数不绑定 arguments，取而代之用 rest 参数...解决</li> <li>箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值。</li> <li>箭头函数没有原型属性，undefined</li> <li>箭头函数不能当做 Generator 函数,不能使用 yield 关键字</li></ol> <p><strong>总结</strong>：普通函数的 this 指向调用它的对象；箭头函数的 this 指向调用父级的对象，如果父级作用域还是箭头函数，就继续向上找，直到 window</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  <span class="token function-variable function">b</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 浏览器是20；node中是undefined</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 浏览器是Window 对象；node中是{}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">c</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// {a: 10, b: ƒ, c: ƒ}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="三、h5-css3-相关"><a href="#三、h5-css3-相关" aria-hidden="true" class="header-anchor">#</a> 三、H5 &amp; CSS3 相关</h2> <h3 id="_1-元素水平垂直居中的方式有哪些？如果元素不定宽高呢？"><a href="#_1-元素水平垂直居中的方式有哪些？如果元素不定宽高呢？" aria-hidden="true" class="header-anchor">#</a> 1. 元素水平垂直居中的方式有哪些？如果元素不定宽高呢？</h3> <ul><li><p>第一种：绝对定位 + transform
通过设置父盒子相对定位，子盒子绝对定位并 top 和 left 距离 50%，实现了子盒子左上角点居中，再通过 transform: translate(-50%, -50%); 属性来实现子盒子的中心点居中</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.children</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：需要添加浏览器前缀进行兼容</p></li> <li><p>第二种：绝对定位 + margin</p> <ol><li>不用知道子盒子的宽高
通过设置父盒子相对定位，子盒子绝对定位，top、right、bottom、left 均为 0，再通过 margin: auto; 属性来实现子盒子的水平垂直居中</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.children</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>需要知道子盒子的宽高
通过设置父盒子相对定位，子盒子绝对定位并 top 和 left 距离 50%，实现了子盒子右上角居中，然后利用 margin-top 和 margin-left 属性等于盒子的负宽高，来实现子盒子的中心点居中</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.children</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>第三种：table-cell 属性
通过设置子盒子为 display: table-cell; 显示类型 ，并分别通过 text-align: center; 和 vertical-align: middle; 实现了子盒子内的文本水平垂直居中</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.children</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：水平垂直居中的是盒子中的文本段落</p></li> <li><p>第四种：flex 布局
通过设置父盒子为 display: display; 显示类型 ，并分别通过 justify-content: center; 和 align-items: center; 实现父盒子中的主轴、交叉轴居中，从而让子盒子水平垂直居中</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parents</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">-webkit-display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">-webkit-justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">-webkit-align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：需要添加浏览器前缀进行兼容</p></li> <li><p>第五种：calc()函数
calc() 函数是 css 中用于动态计算长度值，运算符 ”-“ 前后都需要保留一个空格</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parents</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.children</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>100vh - 300px<span class="token punctuation">)</span> / 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">-webkit-calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>100vh - 300px<span class="token punctuation">)</span> / 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>100vw - 300px<span class="token punctuation">)</span> / 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">-webkit-calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>100vw - 300px<span class="token punctuation">)</span> / 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：需要添加浏览器前缀进行兼容</p></li> <li><p>元素不定宽高水平垂直有哪几种：</p> <ol><li>父元素设置 display:table;子元素设置 display:table-cell
<strong>缺点</strong>：IE7 不支持，而且子元素会填满父元素，不建议使用</li> <li>使用 css3 transform:translate(-50%; -50%)
<strong>缺点</strong>：兼容性不好，IE9+</li> <li>使用 flex 布局
<strong>缺点</strong>：兼容性不好，IE9+</li> <li>利用伪类元素</li></ol></li></ul> <h3 id="_2-说说-em、rem、vh、vw、px-、-的区别？移动端适配解决方案？"><a href="#_2-说说-em、rem、vh、vw、px-、-的区别？移动端适配解决方案？" aria-hidden="true" class="header-anchor">#</a> 2. 说说 em、rem、vh、vw、px 、%的区别？移动端适配解决方案？</h3> <ul><li><p>px: 是 pixel 像素的缩写，相对长度单位，网页设计常用的基本单位。像素 px 是相对于显示器屏幕分辨率而言的</p></li> <li><p>em: em 是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的 font-size）.如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸
<strong>特点</strong>：</p> <ol><li>em 的值并不是固定的</li> <li>em 会继承父级元素的字体大小</li></ol></li> <li><p>rem: 是 CSS3 新增的一个相对单位，rem 是相对于 HTML 根元素的字体大小（font-size）来计算的长度单位. 如果你没有设置 html 的字体大小，就会以浏览器默认字体大小，一般是 16px</p> <p><strong>em 与 rem 的区别</strong>：rem 是相对于根元素（html）的字体大小，而 em 是相对于其父元素的字体大小</p></li> <li><p>vw、vh
vw、vh、vmax、vmin 这四个单位都是基于视口</p> <p>vw 是相对视口（viewport）的宽度而定的，长度等于视口宽度的 1/100.(假如浏览器的宽度为 200px，那么 1vw 就等于 2px（200px/100）)</p> <p>vh 是相对视口（viewport）的高度而定的，长度等于视口高度的 1/100.(假如浏览器的高度为 500px，那么 1vh 就等于 5px（500px/100）)</p> <p>vmin 和 vmax 是相对于视口的高度和宽度两者之间的最小值或最大值</p></li> <li><p>%（百分比）
一般来说就是相对于父元素：</p> <ol><li>对于普通定位元素就是我们理解的父元素</li> <li>对于 position: absolute;的元素是相对于已定位的父元素</li> <li>对于 position: fixed;的元素是相对于 ViewPort（可视窗口）</li></ol></li> <li><p>实现移动端适配的核心思想就是： 使用 rem 作为样式单位，根据不同分辨率的移动设备设置根元素的 font-size 值</p></li></ul> <p><strong>常见问题</strong>：</p> <ol><li>如何使 1rem=10px？
在设置 HTML{font-size：62.5%；}即可</li> <li>如果父元素没有指定高度，那么子元素的百分比的高度是多少？
会按照子元素的实际高度，设置百分比则没有效果</li> <li>如何合理地设置根元素的 font-size 值呢？
<ol><li>将 viewport 宽度设置为移动设备逻辑宽度；</li> <li>使用 js 根据不同分辨率的移动设备来设置根元素的 font-size 值，注意移动端与 pc 端的临界值；</li> <li>在样式中字体使用 px 单位，而其它元素使用 rem 单位；</li> <li>使用 sass 中的 function 来设置一个 px 与 rem 之间的转换函数；
以 iphone 6 的设计稿为基准，即设计稿横向分辨率为 750，取 100 为参照数（即在使用 rem 时与使用 px 时相差 100 的倍数），则我们可以知道 html 的宽度为 7.5rem（750 / 100），而我们知道 iphone 6 的逻辑宽度是 375px，所以 html 的宽度也为 375px，那么此时 7.5rem * html(font-size) = 375px，所以可以得出：html(font-size) = 375 / 7.5，即 html(font-size) = deviceWidth / 7.5
<blockquote><p>通过 js 来设置根元素的 font-size</p></blockquote></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> deviceWidth <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> deviceWidth <span class="token operator">/</span> <span class="token number">7.5</span> <span class="token operator">+</span> <span class="token string">'px'</span>
</code></pre></div><strong>前提</strong>：就是设置 viewport 宽度为移动设备的逻辑宽度<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span>
  <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre></div><strong>注意</strong>：而当 deviceWidth 大于 750px 时，我们应该去访问的是 pc 版的页面，所以当 deviceWidth 大于 750px 时我们不应该再改变根元素的 font-size 值<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> deviceWidth <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth
<span class="token keyword">if</span> <span class="token punctuation">(</span>deviceWidth <span class="token operator">&gt;</span> <span class="token number">750</span><span class="token punctuation">)</span> deviceWidth <span class="token operator">=</span> <span class="token number">750</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> deviceWidth <span class="token operator">/</span> <span class="token number">7.5</span> <span class="token operator">+</span> <span class="token string">'px'</span>
</code></pre></div>通过 sass 的 function 来设置一个 px 与 rem 之间的转换函数<div class="language-css extra-class"><pre class="language-css"><code><span class="token atrule"><span class="token rule">@function</span> <span class="token function">pxToRem</span><span class="token punctuation">(</span>$num<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token atrule"><span class="token rule">@return</span> <span class="token punctuation">(</span>$num/100<span class="token punctuation">)</span> * 1rem<span class="token punctuation">;</span></span>
<span class="token punctuation">}</span>
<span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">pxToRem</span><span class="token punctuation">(</span>50<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token function">pxToRem</span><span class="token punctuation">(</span>50<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h3 id="_3-谈谈你对-bfc-的理解？"><a href="#_3-谈谈你对-bfc-的理解？" aria-hidden="true" class="header-anchor">#</a> 3. 谈谈你对 BFC 的理解？</h3> <p>BFC 即块级格式化上下文，是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局</p> <ul><li><p>BFC 有以下特性：</p> <ol><li>块级元素会在垂直方式一个接一个的排列，和文档流的排列方式一样</li> <li>垂直方向的距离由<code>margin</code> 决定。属于同一个 BFC 中相邻的两个容器的 <code>margin</code> 会发生重叠</li> <li>计算 BFC 高度时，浮动元素也参与计算</li> <li>BFC 是一个独立的容器，容器里的内容不会影响到外面的内容</li></ol></li> <li><p>触发 BFC 的方式：</p> <ol><li><code>overflow</code> 的值不为 <code>visible</code></li> <li><code>position</code> 的值为 <code>absolute</code>、<code>fixed</code></li> <li><code>display</code> 的值为 <code>inline-block</code>、<code>table-cell</code>、<code>flex</code></li></ol></li> <li><p>BFC 有哪些作用：</p> <ol><li>实现两栏布局（第一个 float 后覆盖在第二个上面）</li> <li>解决高度塌陷（使用 float 脱离文档流后，高度塌陷）</li> <li>解决 margin 边距重叠</li></ol></li></ul> <h3 id="_4-说一下-flexbox-和-grid-布局，以及适用场景？"><a href="#_4-说一下-flexbox-和-grid-布局，以及适用场景？" aria-hidden="true" class="header-anchor">#</a> 4. 说一下 FlexBox 和 Grid 布局，以及适用场景？</h3> <ul><li><p>FlexBox
在 flex 布局中，有两个概念需要谨记：容器与元素。在一个 html 标签中声明样式：display：flex or display：inline-flex 即声明了一个 flex 的容器，在这个容器里面的元素即为 flex 元素。而 flex 所有的样式属性分为两类：容器属性与元素属性，他们均作用于 flex 元素，只不过 flex 容器中声明的属性统领 flex 所有元素整体显示与排布方式，而 flex 元素的属性表示单一元素的排布方式。
<img src="https://segmentfault.com/img/bVborUX?w=2380&h=998" alt></p> <ul><li><p>容器属性</p> <ol><li>flex-direction: 是控制 flex 元素的整体布局方向的，它包括四个属性：
row //从左到右 默认 row-reverse column //从上到下 column-reverse</li> <li>flex-wrap: 是控制元素是换行显示还是单行显示，它共有三个属性:
no-wrap //不换行 默认 wrap // 换行 wrap-reverse //换行反序</li> <li>flex-flow: 是 flex-direction 与 flex-wrap 的统写，语法是:
flex-flow:&lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</li> <li>justify-content: 控制 flex 元素水平方向的对齐方式，它共有 个属性：
flex-start // 默认值 默认情况下左对齐 flex-end // 右对齐 center // 居中</li></ol> <p>下面以 space 开头的属性都是描述剩余空间的排布方式的</p> <p>space-around //剩余空间围绕在每个子元素的周围
space-between //剩余空间只分布在子元素之间，两端元素左右没有剩余空间
space-evenly // 剩余空间均匀分布在元素两端、之间</p> <ol start="5"><li>align-content: 代表元素垂直方向上的分布,而这种分布方式只有在多行的情况下才能够凸显出来，单行情况下设置此属性无效。
相对于 justify-content，它多出来一个 stretch 的属性，代表拉伸,默认属性</li> <li>align-items: 就是在单行情况下，控制元素排布方式的。共有 5 个属性：
stretch 默认属性，会将元素的高度拉伸至父容器的高度
flex-start 顶部对齐
flex-end 底部对齐
baseline 基线对齐
center 居中</li></ol></li> <li><p>元素属性</p> <ol><li>order 属性：可以控制 flex 元素的排布顺序，flex 元素会根据 order 从小到大依次排布，order 的默认值为 0，因此如果想要某个元素排在前面，只需要将他的 order 值设为比 0 小的值即可。</li> <li>flex-grow：控制元素所占宽度，默认值为 0，当容器内有剩余空间时，flex-grow 不为 0 的元素将会按照以下规则扩展：</li></ol> <ul><li>容器中只有一个元素设置了 flex-grow
<ol><li>flex-grow 值&gt;=1 那么这个元素会填充容器的剩余空间</li> <li>flex-grow 在 0-1 之间，那么这个元素会多占用空间为剩余空间乘以这个 flex-grow 的值</li></ol></li> <li>容器中有多个元素设置了 flex-grow
<ol><li>所有元素的 flex-grow 的值之和&gt;1。则占用全部的剩余空间，多占用的剩余空间比例即为各个元素所设置 flex-grow 的比例。</li> <li>所有元素的 flex-grow 的值之和&lt;1。 所占用的剩余空间的比例即为各个元素的 flex-grow 的值的比例。</li></ol></li></ul> <ol start="3"><li>flex-shrink 属性与 flex-grow 相反，指的是当空间不足的时候，元素的收缩比例，默认值为 1；其核心思路与 grow 一致</li> <li>flex-basis：定义了在分配剩余空间之前，每个元素的默认宽度，默认为 auto 即元素的宽度；当 flex-basis 的值不为 auto 时，其显示的优先级是高于元素的 width 的</li> <li>flex 属性为以上三个属性的统称，语法为：
flex: none | auto | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]
flex 翻译为中文就是弹性的，所以这个属性就是说明当有空间过大 or 空间不足时，每个元素如何分布。</li> <li>align-self：就是确定单个元素垂直分布状态</li></ol></li></ul></li></ul> <ul><li>Grid
与 Flex 相同，Grid 也分为容器与元素两个概念；在一个 html 标签中添加样式：display：grid 或者 display：inline-grid，即构建了一个 Grid 的容器，里面的 dom 元素即为 Grid 元素。同样，Grid 也分为两类属性，分别装载在容器与元素上
<img src="https://segmentfault.com/img/bVborRD?w=2038&h=956" alt></li></ul> <h3 id="_5-css3-中新增了哪些新特性？"><a href="#_5-css3-中新增了哪些新特性？" aria-hidden="true" class="header-anchor">#</a> 5. CSS3 中新增了哪些新特性？</h3> <p>答：一些选择器、边框（border-radius, border-image）、box-shadow、背景（background-origin<code>、</code>background-size 等）、文字（word-wrap, text-overflow, text-shadow）、颜色（rgba, hsla）、transition 过渡、transform 转换（scale 缩放，translate 平移，rotate 旋转，skew 切斜）、animation 动画、渐变（linear-gradient 线性渐变和 radial-gradient 径向渐变）、Flex 布局、Grid 栅格布局、多列布局、媒体查询等等</p> <h3 id="_6-css3-画一个三角形，其原理是什么？"><a href="#_6-css3-画一个三角形，其原理是什么？" aria-hidden="true" class="header-anchor">#</a> 6. CSS3 画一个三角形，其原理是什么？</h3> <p>我们有时候会需要用到一个三角形的形状，比如地址选择或者播放器里面播放按钮,通常情况下，我们会使用图片或者 svg 去完成三角形效果图</p> <ul><li><p>实心三角形</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.border:</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 0 50px 50px<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/c9c4766fca653e3f13f0c6deed864588.png" alt>
这时候就已经能够看到 4 个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为透明就可以得到下方的红色三角形. 但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉</p></li> <li><p>空心三角形(利用伪类)
伪类元素定位参照对象的内容区域宽高都为 0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.border</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 0 50px 50px<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent #d9534f<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.border:after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 0 40px 40px<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent #96ceb4<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 6px<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> -40px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/9bcc5345f0404068ea0e2370e8c77229.png" alt></p></li> <li><p>原理分析
<strong>采用的是均分原理</strong>：非常有意思的是盒子都是一个矩形或正方形，从形状的中心，向 4 个角上下左右划分 4 个部分
<img src="https://img-blog.csdn.net/20170428125622251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2ppbnNh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.square</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 6px<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> red transparent transparent transparent<span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid dashed dashed dashed<span class="token punctuation">;</span> // 为了兼容IE6，把没有的边框都设置为虚线
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/9c5eedf681b5cfee8262e3c88be6645e.png" alt>
边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形.当分别取消边框的时候，发现下面几种情况：</p> <ol><li>取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的</li> <li>当仅有邻边时， 两个边会变成对分的三角</li> <li>当保留边没有其他接触时，极限情况所有东西都会消失
<img src="https://img-blog.csdnimg.cn/img_convert/49235a2eff29b6057568653e96abbe6e.png" alt></li></ol> <ul><li>通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">如设置直角三角形 .box</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 内部大小 */</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>
  <span class="token comment">/* 边框大小 只设置两条边*/</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> #4285f4 solid<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> transparent solid<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 85px<span class="token punctuation">;</span>
  <span class="token comment">/* 其他设置 */</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_7-获取元素的宽高的方式有哪些？"><a href="#_7-获取元素的宽高的方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 7. 获取元素的宽高的方式有哪些？</h3> <ol><li><p>dom.style.width/height</p> <p><strong>原理</strong>：这种方式只能取到 dom 元素内联样式所设置的宽高；（也就是说如果该节点的样式是在 style 标签中或外联的 CSS 文件中设置的话，通过这种方法是获取不到 dom 的宽高的）</p></li> <li><p>dom.currentStyle.width/height</p> <p><strong>原理</strong>：获取渲染后的宽高。（但仅 IE 支持）</p></li> <li><p>dom.getComputedStyle(dom).width/height</p> <p><strong>原理</strong>：与 2 原理类似。但是兼容性，通用性更好一些</p></li> <li><p>dom.getBoundingClientRect().width/height</p> <p><strong>原理</strong>：计算元素的绝对位置，获取到四个属性，left, top, right, bottom</p></li></ol> <h3 id="_8-说说你对-盒子模型-的理解？"><a href="#_8-说说你对-盒子模型-的理解？" aria-hidden="true" class="header-anchor">#</a> 8. 说说你对 盒子模型 的理解？</h3> <p>CSS3 中的盒模型有以下两种：标准盒模型、IE（怪异替代）盒模型。</p> <p>两种盒子模型都是由 content + padding + border + margin 构成，其大小都是由 content + padding + border 决定的，但是盒子内容宽/高度（即 width/height）的计算范围根据盒模型的不同会有所不同：</p> <ul><li>标准盒模型：只包含 content</li> <li>IE（替代）盒模型：content + padding + border</li></ul> <p>可以通过 box-sizing 来改变元素的盒模型：</p> <ul><li>box-sizing: content-box ：标准盒模型（默认值）</li> <li>box-sizing: border-box ：IE（替代）盒模型</li></ul> <h3 id="_9-css-中选择器有哪些？优先级？哪些属性可以继承？"><a href="#_9-css-中选择器有哪些？优先级？哪些属性可以继承？" aria-hidden="true" class="header-anchor">#</a> 9. CSS 中选择器有哪些？优先级？哪些属性可以继承？</h3> <p>样式的优先级一般为 <code>!important</code> &gt; <code>style</code> &gt; <code>id</code> &gt; <code>class</code> &gt; <code>标签选择器</code></p> <ul><li><p>优先级：</p> <ol><li>!important</li> <li>内联样式（1000）</li> <li>ID 选择器（0100）</li> <li>类选择器/属性选择器/伪类选择器（0010）</li> <li>元素选择器/伪元素选择器（0001）</li> <li>关系选择器/通配符选择器（0000）</li></ol> <p><strong>总结</strong>：带!important 标记的样式属性优先级最高； 样式表的来源相同时：!important &gt; 行内样式&gt;ID 选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p></li> <li><p>css 属性选择器常用的有：</p> <ol><li>id 选择器（#box），选择 id 为 box 的元素</li> <li>类选择器（.one），选择类名为 one 的所有元素</li> <li>标签选择器（div），选择标签为 div 的所有元素</li> <li>后代选择器（#box div），选择 id 为 box 元素内部所有的 div 元素</li> <li>子选择器（.one&gt;one_1），选择父元素为.one 的所有.one_1 的元素</li> <li>相邻同胞选择器（.one+.two），选择紧接在.one 之后的所有.two 元素</li> <li>群组选择器（div,p），选择 div、p 的所有元素</li> <li>通配符选择器(*)</li></ol></li> <li><p>一些使用频率相对不是很多的选择器：</p> <ol><li>伪类选择器（:link, :visited, :active, :hover）</li> <li>伪元素选择器（:after, :before）</li> <li>属性选择器（[attribute], [attribute=value]）</li></ol></li> <li><p>CSS3 中新增的选择器：</p> <ol><li>伪类选择器（:nth-child(n), :not, :last-child）</li> <li>属性选择器（[attribute^=value]）</li></ol></li> <li><p>优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p> <ol><li>如果存在内联样式，那么 A = 1，否则 A = 0</li> <li>B 的值等于 ID 选择器（#id） 出现的次数</li> <li>C 的值等于 类选择器（.class） 和 属性选择器（a[href=&quot;https://example.org&quot;]） 和 伪类（:first-child） 出现的总次数</li> <li>D 的值等于 标签选择器（h1,a,div） 和 伪元素（::before,::after） 出现的总次数</li></ol> <ul><li><p>知道了优先级是如何计算之后，就来看看比较规则：</p> <ol><li>从左往右依次进行比较 ，较大者优先级更高</li> <li>如果相等，则继续往右移动一位进行比较</li> <li>如果 4 位全部相等，则后面的会覆盖前面的</li></ol></li></ul></li> <li><p>CSS 属性继承</p> <p>在 css 中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p> <ul><li><p>关于继承属性，可以分成：</p> <ol><li><p>字体系列属性</p></li> <li><p>文本系列属性</p></li> <li><p>元素可见性</p></li> <li><p>表格布局属性</p> <p><strong>注意</strong>：继承中比较特殊的几点：</p> <ol><li>a 标签的字体颜色不能被继承</li> <li>h1-h6 标签字体的大小也是不能被继承的</li></ol></li></ol></li> <li><p>无继承的属性：</p> <ol><li>display</li> <li>文本属性：vertical-align、text-decoration</li> <li>盒子模型的属性：宽度、高度、内外边距、边框等</li> <li>背景属性：背景图片、颜色、位置等</li> <li>定位属性：浮动、清除浮动、定位 position 等</li> <li>生成内容属性：content、counter-reset、counter-increment</li> <li>页面样式属性：size、page-break-before、page-break-after</li></ol></li></ul></li></ul> <h3 id="_10-display-和-position-有哪些值？"><a href="#_10-display-和-position-有哪些值？" aria-hidden="true" class="header-anchor">#</a> 10. display 和 position 有哪些值？</h3> <ul><li>display 的值：none、inline、inline-block、block、table、flex</li> <li>position 的值：static、relative、absolute、fixed、inherit</li></ul> <h3 id="_11-清除浮动的方式有哪些？"><a href="#_11-清除浮动的方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 11. 清除浮动的方式有哪些？</h3> <ul><li>添加额外标签，使用 clear:both;清除浮动<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>parent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 添加额外标签并且添加clear属性 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token property">clear</span><span class="token punctuation">:</span>both</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 也可以加一个br标签 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li>利用伪元素:after 来清除浮动<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">//在css中添加:after伪元素
.parent:after</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 设置添加子元素的内容是空 */</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token comment">/* 设置添加子元素为块级元素 */</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token comment">/* 设置添加的子元素的高度0 */</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token comment">/* 设置添加子元素看不见 */</span>
  <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
  <span class="token comment">/* 设置clear：both */</span>
  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>使用 CSS 的 overflow 属性（BFC）</li></ul> <h3 id="_12-说说重绘-重排？"><a href="#_12-说说重绘-重排？" aria-hidden="true" class="header-anchor">#</a> 12. 说说重绘 &amp; 重排？</h3> <p>简单地总结下两者的概念：</p> <ul><li>重排：无论通过什么方式影响了元素的几何信息(元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做重排</li> <li>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘</li></ul> <p>如何减少重排和重绘？</p> <ol><li>最小化重绘和重排，比如样式集中改变，使用添加新样式类名 .class 或 cssText</li> <li>批量操作 DOM，比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createDocumentFragment() 来添加要被添加的节点，处理完之后再插入到实际 DOM 中</li> <li>使用 <strong>absolute</strong> 或 <strong>fixed</strong> 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显</li> <li>开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘</li></ol> <p><strong>扩展</strong>：transform 会造成回流吗？
渲染流水线是这样的顺序：重排 -&gt; 重绘 -&gt; 合成；transform: translate 是直接合成，跳过了前面的重排重绘。</p> <h3 id="_13-defer、async-的区别？"><a href="#_13-defer、async-的区别？" aria-hidden="true" class="header-anchor">#</a> 13. defer、async 的区别？</h3> <ul><li>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li> <li>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li> <li>defer script：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-watermark.awebp" alt></p> <h3 id="_14-说说-html、css、js-的加载顺序？"><a href="#_14-说说-html、css、js-的加载顺序？" aria-hidden="true" class="header-anchor">#</a> 14. 说说 html、css、js 的加载顺序？</h3> <ul><li><p><strong>DOM 解析</strong>：把所写的各种 <code>html</code> 标签，生成一个 <code>DOM TREE</code>，相当于是生成了一个最原始的页面，一点样式都没有，毫无 <code>CSS</code> 修饰</p></li> <li><p><strong>DOM 渲染</strong>：浏览器会把本身默认的样式 + 用户自己写得样式整合到一起，形成一个<code>CSS TREE</code>，而<code>DOM</code>渲染就是指<code>DOM TREE</code> 和 <code>CSS TREE</code> 结合到一起，生成一个<code>Render TREE</code>，呈现出一个带有样式的页面</p></li> <li><p>DOM 与 CSS</p></li></ul> <ol><li><code>css</code> 的加载不会阻塞 <code>DOM</code> 的<strong>解析</strong></li> <li><code>css</code> 的加载会阻塞 <code>DOM</code> 的<strong>渲染</strong></li></ol> <ul><li>DOM 与 JS</li></ul> <ol><li><code>JS</code>（加载和执行） 都会阻塞 <code>DOM</code> 的<strong>解析</strong></li> <li><code>JS</code>（加载和执行） 都会阻塞 <code>DOM</code> 的<strong>渲染</strong></li></ol> <p><strong>注</strong>：<code>html</code> 中每遇到 <code>script</code> 标签，页面就会重新渲染一次，因为要保证标签中的 <code>JS</code> 代码拿到的都是最新的样式</p> <ul><li>CSS 与 JS</li></ul> <ol><li><code>CSS</code> 的加载阻塞 <code>JS</code> 的<strong>运行</strong>，不阻塞 <code>JS</code> 的<strong>加载</strong></li></ol> <p><strong>注</strong>：<code>CSS</code> 的渲染 <code>GUI 线程</code>和 <code>JS 运行线程</code>互斥</p> <p><strong>总结</strong>：</p> <ol><li>script 最好放底部，link 最好放头部</li> <li>如果头部同时有<code>script</code>与<code>link</code>的情况下，最好将<code>script</code>放在<code>link</code>上面</li></ol> <p><strong>扩展</strong>：为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高 css 加载速度，比如可以使用以下几种方法:</p> <ol><li>使用 CDN（因为 CDN 会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间）</li> <li>对 css 进行压缩（可以用很多打包工具，比如 webpack,gulp 等，也可以通过开启 gzip 压缩）</li> <li>合理的使用缓存（设置 cache-control,expires,以及 E-tag 都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号）</li> <li>减少 http 请求数，将多个 css 文件合并，或者是干脆直接写成内联样式（内联样式的一个缺点就是不能缓存）</li> <li>不要在嵌入的 JS 中调用运行时间较长的函数，如果一定要用，可以用<code>setTimeout</code>来调用</li></ol> <h3 id="_15-你知道哪几种方式可以隐藏一个元素？"><a href="#_15-你知道哪几种方式可以隐藏一个元素？" aria-hidden="true" class="header-anchor">#</a> 15. 你知道哪几种方式可以隐藏一个元素？</h3> <p>答：opacity/filter: opacity()、clip-path、position、z-index、visibility、覆盖一个元素(伪类:after)、display、transform: scale(0)/translate(-999px, 0px)、color alpha、缩小尺寸等</p> <h3 id="_16-了解-h5-的-draggable-拖拽吗？"><a href="#_16-了解-h5-的-draggable-拖拽吗？" aria-hidden="true" class="header-anchor">#</a> 16. 了解 H5 的 draggable 拖拽吗？</h3> <p>为了使元素可拖动，把 draggable 属性设置为 true。draggable 属性可用于任何元素节点，但是图片（img）和链接（a）不加这个属性，就可以拖拉</p> <p><strong>注意</strong>：一旦某个元素节点的 draggable 属性设为 true，就无法再用鼠标选中该节点内部的文字或子节点了</p> <ul><li><p>当元素节点或选中的文本被拖拉时，包括以下一些事件：</p> <ul><li>drag：拖拉过程中</li> <li>dragstart：用户开始拖拉时</li> <li>dragend：拖拉结束时</li> <li>dragenter：拖拉进入当前节点时</li> <li>dragover：拖拉到当前节点上方时</li> <li>dragleave：拖拉操作离开当前节点范围时</li> <li>drop：被拖拉的节点或选中的文本，释放到目标节点时</li></ul></li></ul> <h2 id="四、vue-相关"><a href="#四、vue-相关" aria-hidden="true" class="header-anchor">#</a> 四、Vue 相关</h2> <h3 id="_1-vue3-和-vue2-有哪些区别？"><a href="#_1-vue3-和-vue2-有哪些区别？" aria-hidden="true" class="header-anchor">#</a> 1. Vue3 和 Vue2 有哪些区别？</h3> <ul><li>数据响应式原理变化，Vue2：Object.defineProperty()；Vue3：Proxy</li> <li>Vue3 新增内置组件：Fragment(文档碎片)、Suspense(异步组件)、Teleport(瞬移组件)</li> <li>Vue3 提供 Composition API；Vue2 是 Options API；自定义函数(hooks)</li> <li>Vue3 中生命周期前面都加了 on，移除了 beforeCreate 和 created 钩子函数</li> <li>Vue3 源码采用 TS 开发，Vue2 采用 flow；-&gt; Vue3 对 TS 支持更加友好</li> <li>Vue3 源码采用 monorepo 方式进行管理，将模块拆分到 packages 目录中</li> <li>Vue3 支持 tree-shaking，不使用就不会打包，提升性能</li> <li>Vue3 中对模块编译进行了优化，编译时生成 block tree，可以对子节点进行收集。可以减少比较，并且采用了 patchFlag 标记动态节点。</li> <li>Vue3 中对全局 API 的改变</li></ul> <h3 id="_2-说一下-vue2-和-vue3-的响应式原理？"><a href="#_2-说一下-vue2-和-vue3-的响应式原理？" aria-hidden="true" class="header-anchor">#</a> 2. 说一下 Vue2 和 Vue3 的响应式原理？</h3> <p>Vue2：当创建 Vue 实例时，Vue 会遍历 data 选项的属性，利用 Object.defineProperty 为属性添加 getter 和 setter（getter 用来依赖收集，setter 用来派发更新），并且在内部追踪依赖，在属性被访问和修改时通知变化。</p> <ul><li><p>Watcher、Dep、Observer 三者的区别？</p> <ol><li>Observer：它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</li> <li>Dep：用于收集当前响应式对象的依赖关系，每个响应式对象包括子对象都拥有应 Dep 实例（里面 subs 是 watcher 实例数组），当数据变更时，会通过 dep.notify()通知各个 watcher</li> <li>Watcher：观察者对象（渲染 watcher、计算属性 watcher、用户传的 watcher）
<strong>扩展</strong>：Watcher 和 Dep 的关系？
一个属性可能有多个依赖，每个响应式数据都有一个 Dep 来管理它的依赖</li></ol></li> <li><p>Vue 实例挂载的过程发生了什么?（new Vue()发生了啥？）</p> <ol><li>src/core/instance/index.js -&gt; new Vue() -&gt; this._init(options) -&gt; initMixin(Vue)[原型上挂载_init 方法]</li> <li>scr/core/instance/init.js -&gt; Vue.prototype._init -&gt; 合并配置 mergeOptions() -&gt; 初始化生命周期(initLifecycle) -&gt; 初始化事件中心(initEvents) -&gt; 初始化渲染(initRender) -&gt; 挂载 beforeCreate 钩子 -&gt; 初始化 Inject(initInject) -&gt; 初始化 initState(data props computed watcher)等等 -&gt; 初始化 Provide(initProvide) -&gt; 初始化 created 钩子 -&gt; 最后判断是否有 el 使用$mount 挂载</li> <li>src/core/instance/state.js -&gt; initState: 会对 props、methods、data、computed、watcher 进行初始化=》数组的基本来源</li> <li>src/core/instance/state.js -&gt; initData: 初始化数据 -&gt; 判断 data 是否是函数 -&gt; 获取 data 所有的 key 和 props、methods 判断是否有重名 -&gt; 观测数据（observe(data))</li> <li>src/core/observer/index.js -&gt; observe() -&gt; 通过<code>__ob__</code>判断数据是否被观测 -&gt; 如果观测就返回观测的数据，若没有观测就实例化（new Observer(value)）</li> <li>src/core/observer/index.js -&gt; class Observer 类 -&gt; 1、给每个属性添加<strong>ob</strong>属性；2、判断数组还是对象；3、数组走 observeArray(), 对象走 walk()【注意：此时实例化 dep；this.dep = new Dep()】</li> <li>对象情况：循环所有的 key, 调用<strong>defineReactive()</strong> -&gt; <strong>Object.defineProperty()</strong></li></ol> <ul><li><p>get() [dep.depend()依赖收集【如果有孩子深度观测 childOb.dep.depend()；若孩子是数组走 dependArray()（循环所有的孩子，e &amp;&amp; e.<code>__ob__</code> &amp;&amp; e.<code>__ob__</code>.dep.depend()）；如果孩子里还有数组，递归调用 dependArray()】]</p> <ol><li>src/observer/dep.js -&gt; depend() ：如果 Dep.target 存在，就添加依赖 Dep.target.addDep(this)</li> <li>src/observer/watcher.js -&gt; addDep(dep) ：将 dep 添加到 watcher 的 newDeps 中；通过 addSub()将 watcher 添加到 Dep 的 subs 数组中（判断是否重复，相同的只能添加一次），不存在的话就将 watcher 添加到 dep 中 dep.addSub(this)</li> <li>src/observer/dep.js -&gt; addSub(sub: Watcher)将 watcher 添加到 dep 中 this.subs.push(sub)</li></ol></li> <li><p>set() [dep.notify()触发更新]【如果孩子是数组也要进行观测 childOb = observe(newVal)】-&gt; dep.notify()</p> <ol><li>src/observer/dep.js -&gt; notify() : 遍历 Dep 中的 subs 里所有的 watcher，循环调用 watcher 的 update 方法；subs[i].update()</li> <li>src/observer/watcher.js -&gt; update(): 如果是同步 this.sync 调用 this.run() 【调用 watcher 中的 get 方法 this.get()获取最新 value，将 this.value 赋值给 oldValue; 将最新的 value 赋值给 this.value；调用 this.cb.call(this.vm, value, oldValue)】-&gt; 如果是异步调用 queueWatcher(this)</li> <li>src/observer/scheduler.js -&gt; queueWatch(watcher: Watcher)方法: -&gt; nextTick(flushSchedulerQueue)</li> <li>src/observer/scheduler.js -&gt; flushSchedulerQueue() 就是将更新队列中的 watcher 拿出来并依次调用他们的 callback，但重点在于为什么在 for 循环之前先对这些 watcher 进行了升序排列</li></ol></li></ul> <ol start="8"><li>src/platform/web/entry-runtime-with-compiler.js -&gt; $mount()重写$mount 方法 -&gt; 判断（是否 render 函数、是否有 template、都没有则 el.outerHTML ）-&gt; 将 template 转换成 render 方法【compileToFunction(template)】</li></ol> <p>线路图：new Vue =&gt; _init =&gt; $mount =&gt; mountComponent</p> <p>src/instance/lifecycle.js：mountComponent() -&gt; 挂载组件 -&gt; callHook(vm, 'beforeMount') -&gt; 定义 updateComponent -&gt; new Watcher(vm, updateComponent, () =&gt; {}, true) // == updateComponent() ;默认 vue 是通过 watcher 来进行渲染 渲染 watcher;</p> <ul><li>_render()函数返回的就是虚拟 dom</li> <li>_update()方法将虚拟节点转换成真实节点</li> <li>_render 函数会读取 data 中的数据从而触发 getter 方法进行依赖收集(会调用 watcher 中的 get 方法进行求值)</li></ul> <p><strong>扩展</strong>：Vue2 中 runtime+compiler 和 runtime-only 的区别？</p> <ul><li>runtime-only 相比 runtime-compiler 有两个优点：
<ol><li>运行效率高</li> <li>源代码量更少</li></ol></li> <li>runtime-compiler 模式，runtime-only 模式在 src 文件里面只在 main.js 里面有区别：
<ol><li>runtime-compiler 模式里的 Vue 实例的模板，和注册的组件，都被一个 render 函数替换掉了</li> <li>h 函数是 createElement 的缩写-》用于创建虚拟 DOM 的
<img src="https://img-blog.csdnimg.cn/20200116225927903.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA2Mjgw,size_16,color_FFFFFF,t_70" alt></li></ol></li> <li>**runtime-compiler 的步骤：**template -&gt; ast -&gt; render -&gt; virtual dom -&gt; 真实 dom</li> <li>**runtime-only 的步骤：**render -&gt; virtual dom -&gt; 真实 dom
<strong>问题</strong>：**runtime-only：**main.js 中的 template 被替换掉了，那组件中 template 还存在，他是怎么编译的呢？
Vue-template-compiler，运行项目时，这个包会自动将组件的 template 转换成 render 函数</li></ul></li></ul> <h3 id="_3-vue2-和-vue3-组件通信方式有哪些？"><a href="#_3-vue2-和-vue3-组件通信方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 3. Vue2 和 Vue3 组件通信方式有哪些？</h3> <ul><li><p>Vue2 组件通信方式：</p> <ol><li>父 -&gt; 子：props; 子 -&gt; 父：$emit【单向数据流：props 只能从上一级组件传递到下一级组件】</li> <li>父子组件之间：$parents、$children 获取组件实例</li> <li>provide 和 inject ：父组件中通过 provide 来提供变量，然后子组件中使用 inject 来注入变量【Vue2.2.0 新增】</li> <li>ref 和 refs：如果在普通的 DOM 元素上，引用指向的是 DOM 元素；如果用在子组件上，引用就指向组件是来，可以通过实例获取组件的方法和数据等。</li> <li>EventBus：事件总线（$emit派发事件、$on 注册事件、$off 移除事件）</li> <li>$attrs 和 $listeners：新增了<strong>inheritAttrs</strong> 选项，默认值为 true【Vue2.4 新增】</li> <li>Vuex：专为 Vue.js 应用程序开发设计的状态管理</li></ol></li> <li><p>Vue3 组件通信方式：</p> <ol><li>父 -&gt; 子：props; 子 -&gt; 父：emit</li> <li>v-model 方式</li> <li>$refs 【defineExpose 暴露属性】</li> <li>provide 和 inject</li> <li>事件总线（Vue3 中移除了 Event-Bus，但是可以借助第三方工具：Vue 官方推荐：mitt 和 tiny-emitter）</li> <li>Vuex4</li> <li>Pinia</li></ol></li></ul> <h3 id="_4-说一说-nexttick-的原理？"><a href="#_4-说一说-nexttick-的原理？" aria-hidden="true" class="header-anchor">#</a> 4. 说一说 nextTick 的原理？</h3> <p>nextTick 作用：是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <ul><li><p>再回答 nextTick 实现原理之前，首先要了解 JS 的执行机制</p> <p>JS 是单线程的，一次只能干一件事，即<strong>同步</strong>。（就是说所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，这是非常影响用户体验的）。所以有了 <strong>异步</strong> 的概念</p> <ul><li>同步任务：指排队在主线程上依次执行的任务</li> <li>异步任务：不进入主线程，而进入任务队列的任务，又分为宏任务和微任务</li> <li>宏任务： 渲染事件、请求、script、setTimeout、setInterval、Node 中的 setImmediate 等</li> <li>微任务： Promise.then、MutationObserver(监听 DOM)、Node 中的 Process.nextTick 等</li></ul> <p>当执行栈中的同步任务执行完后，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染...，如此形成循环，即<strong>事件循环(EventLoop)</strong></p></li> <li><p>Vue2 中 nextTick 源码解析：</p> <ul><li><p>源码地址：src/core/util/next-tick.js，源码版本：2.6.14</p></li> <li><p>源码的主要的两个作用：</p> <ol><li>一是判断当前环境能使用的最合适的 API 并保存异步函数
主要是判断用哪个宏任务或微任务，因为宏任务耗费的时间是大于微任务的，所以成先使用微任务，判断顺序如下：
<ul><li>Promise</li> <li>MutationObserver</li> <li>setImmediate</li> <li>setTimeout
环境判断结束就会得到一个延迟回调函数 timerFunc,然后进入核心的 nextTick</li></ul></li> <li>二是调用异步函数 执行回调队列
nextTick 方法主要逻辑就是：
<ul><li>把传入的回调函数放进回调队列 callbacks</li> <li>执行保存的异步任务 timeFunc，就会遍历 callbacks 执行相应的回调函数了</li></ul></li></ol> <p><strong>注意</strong>：如果没有提供回调，并且支持 Promise，就返回一个 Promise。 -&gt;  this.$nextTick().then(()=&gt;{ ... })</p></li></ul></li> <li><p>名词解析：</p> <ol><li>isUsingMicroTask：是否启用微任务开关</li> <li>callbacks：回调队列</li> <li>pending：异步控制开关，同一时间只能执行一次</li> <li>flushCallbacks()：该方法负责执行队列中的全部回调；执行之前先备份并清空回调队列，是为了防止 nextTick 里有 nextTick 出现的问题</li> <li>timerFunc：用来保存调用异步任务方法</li></ol></li> <li><p>Vue3 中 nextTick 源码解析：</p> <ul><li>源码地址：packages/runtime-core/src/scheduler.ts，源码版本：3.2.11</li> <li>vue3 中 nextTick 的队列由几个方法维护，基本执行顺序是这样的：
queueJob -&gt; queueFlush -&gt; flushJobs -&gt; nextTick 参数的 fn</li> <li>【还需探索...】</li></ul></li></ul> <h3 id="_5-为什么-index-不能作为-key-谈谈你对-key-的理解？"><a href="#_5-为什么-index-不能作为-key-谈谈你对-key-的理解？" aria-hidden="true" class="header-anchor">#</a> 5. 为什么 index 不能作为 key, 谈谈你对 key 的理解？</h3> <ul><li>不能用随机数作为 key, 不然会全部重新创建</li></ul> <h3 id="_6-有写过自定义指令吗？自定义指令的应用场景？"><a href="#_6-有写过自定义指令吗？自定义指令的应用场景？" aria-hidden="true" class="header-anchor">#</a> 6. 有写过自定义指令吗？自定义指令的应用场景？</h3> <h3 id="_7-前端路由的原理？"><a href="#_7-前端路由的原理？" aria-hidden="true" class="header-anchor">#</a> 7. 前端路由的原理？</h3> <ul><li>什么叫路由？
核心：根据不同的路径跳转不同的组件</li></ul> <p>vue-router 提供三种路由模式：</p> <ol><li>hash 模式【默认】
通过路径中的 hash 值来控制路由跳转，不存在兼容问题。
<strong>原理</strong>：在正常路径后跟一个 # 号，匹配 # 后边的路径为前端路由，通过 window.onhashchange 方法来操控路由改变的时候切换内容</li> <li>history 模式
H5 新增的 history API，相对 hash 而言，不会显示#号，但是需要服务器端配置
<strong>原理</strong>：在 HTML5 中，新增了 pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求，同时还有 popstate 事件，实现原理与 hash 相似，只不过因为没有了 # 号，所以刷新页面还是会向服务器发送请求，而后端没有对应的处理措施的话，会返回 404，所以需要后端配合</li> <li>abstract 模式
支持 javascript 的所有运行环境，常指 Node.js 服务器环境
<strong>原理</strong>：abstract 模式是不依赖于浏览器环境的一种模式，它是 VueRouter 内部使用数组进行模拟了路由管理，在 node 环境，或者原生 App 环境下，都会默认使用 abstract 模式，VueRouter 内部会根据所处的环境自行判断，默认使用 hash 模式，如果检测到没有浏览器 API 的时候，就会使用 abstract 模式</li></ol> <ul><li><p>提供了两个函数式组件: router-link 和 router-view</p></li> <li><p>vue-router 使用方式</p> <p>Vue.use(VueRouter); 注册插件（如果是在浏览器环境运行的，可以不写该方法） 安装 router-link 和 router-view 组件，并且给当前应用下所有组件都注入$outer $route 对象</p> <ol><li>定义/导入（路由）组件</li> <li>定义路由 routes</li> <li>创建 router 实例，并传 <code>routes</code> 配置</li> <li>创建和挂载根实例</li></ol> <ul><li>VueRouter 构造函数
<ol><li>constructor() -&gt; this.matcher = createMatcher(options.routes || []);扁平化用户传入的数据，创建路由映射表</li></ol> <ul><li>createMatcher 方法返回：
<ol><li>match 匹配根据传入的 location 路径在 pathMap 找到对应的记录，createRoute()中生成一个新的 route 路径</li> <li>addRoutes 作用是动态添加路由配置</li></ol> <ul><li>addRoutes 的实现
<ol><li>是调用 createRouteMap()目标是把用户的路由配置转成一张路由映射表。方法中遍历路由配置 routes， 返回值是一个包括 pathList 、pathMap 、nameMap 的对象</li> <li>pathList 是存储所有 path 值，pathMap 表示一个 path 到 RouteRecord 的映射关系，nameMap 表示 name 到 RouteRecord 的映射关系</li></ol></li></ul></li></ul> <ol start="2"><li>判断 mode 模式，switch(mode)根据不同模式，来创建不同路由对象</li></ol></li> <li>install(Vue) 方法
<ol><li>Vue.mixin 在 beforeCreate()；在所有的组件上新增了一个_routerRoot 属性，通过这个属性可以拿到根实例;</li> <li>this.$options.router 判断是否是根组件。是 this._routerRoot = this;不是 this._routerRoot = this.$parent &amp;&amp; this.$parent._routerRoot（子组件）</li> <li>this._router.init(this)调用初始化路由系统</li> <li>Vue.util.defineReactive(this, '_route', this._router.history.current) // 将属性变成响应式，数据一变界面就更新；</li> <li>使用 Object.defineProperty 在 Vue.property 原型上定义$route和$router 属性，get()通过代理拿到 this._routerRoot._route；this._routerRoot._router</li> <li>注册全局组件 RouterView 和 RouterLink</li></ol></li> <li>init(app)初始化路由系统
<ol><li>通过 instanceof 判断 history 是哪一种路由;HTML5History、HashHistory、AbstractHistory 都是继承 History.针对于 HTML5History 和 HashHistory 特殊处理，因为在这两种模式下才有可能存在进入时候的不是默认页，需要根据当前浏览器地址栏里的 path 或者 hash 来激活对应的路由</li></ol></li></ul></li> <li><p>路由更新方式：</p> <ol><li>主动触发
router-link 绑定了 click 方法，触发 history.push 或者 history.replace，从而触发 history.transitionTo。transitionTo 用于处理路由转换，其中包含了 updateRoute 用于更新_route.当_route 变化后，触发 router-view 的变化</li> <li>地址变化（如：在浏览器地址栏直接输入地址）
HashHistory 和 HTML5History 会分别监控 hashchange 和 popstate 来对路由变化作对用的处理。HashHistory 和 HTML5History 捕获到变化后会对应执行 push 或 replace 方法，从而调用 transitionTo</li></ol></li> <li><p>路由变更到视图的过程：
hash -&gt; match router -&gt; set _route -&gt; router-view render() -&gt; render matched component</p></li> <li><p>实现过程技术点：</p> <ol><li>Vue 插件机制</li> <li>数据响应式机制</li> <li>Vue 渲染机制</li> <li>地址变更监听</li></ol></li></ul> <h3 id="_8-你知道-vue-页面不刷新的情况有哪些？"><a href="#_8-你知道-vue-页面不刷新的情况有哪些？" aria-hidden="true" class="header-anchor">#</a> 8. 你知道 Vue 页面不刷新的情况有哪些？</h3> <ul><li>Vue 无法检测实例被创建时不存在 data 中的属性</li> <li>Vue 无法检测对象属性的添加和移除</li> <li>Vue 通过数组下标（索引）修改一个数据项</li> <li>Vue 不能直接修改数组的 length</li> <li>在异步执行之前操作 DOM</li> <li>循环嵌套太深，视图不更新 -&gt; 解决：$forceUpdate()</li> <li>路由参数变化时，页面不刷新 -&gt; 解决：watch 监听$route 和 router-view 添加 key</li></ul> <h3 id="_9-keep-alive-的原理？"><a href="#_9-keep-alive-的原理？" aria-hidden="true" class="header-anchor">#</a> 9. keep-alive 的原理？</h3> <p>keep-alive 是一个<strong>抽象组件</strong>：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p> <p><strong>总的来说</strong>：keep-alive 用于保存组件的渲染状态，防止组件多次渲染。</p> <ul><li><p>keep-alive 用法：</p> <ul><li>在动态组件中的应用<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>whiteList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:exclude</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>blackList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:max</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>amount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>currentComponent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li>在 vue-router 中的应用<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>whiteList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:exclude</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>blackList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:max</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>amount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul></li></ul> <p><strong>其中</strong>：include 定义缓存白名单，keep-alive 会缓存命中的组件；exclude 定义缓存黑名单，被命中的组件将不会被缓存；max 定义缓存组件上限，超出上限使用 LRU 的策略置换缓存数据。</p> <ul><li>缓存淘汰策略 LRU（最近最少使用）</li></ul> <blockquote><p>源码解析过程：</p></blockquote> <ol><li><p>路径：src/core/components/keep-alive.js</p></li> <li><p>abstract 属性：true，判断当前组件虚拟 dom 是否渲染成真实 dom 的关键</p></li> <li><p>props 属性：</p> <ul><li>include：缓存白名单</li> <li>exclude：缓存黑名单</li> <li>max：缓存的组件数量</li></ul></li> <li><p>keep-alive 在它生命周期内定义了三个钩子函数：</p> <ul><li><p>created：初始化两个对象分别缓存 VNode(虚拟 DOM)cache 和 VNode 对应的键集合 keys</p></li> <li><p>destroyed：删除 this.cache 中缓存的 VNode 实例
<strong>扩展</strong>：为什么不直接将 this.cache 置为 null，而是遍历调用 pruneCacheEntry 函数删除？
删除缓存的 VNode 还要对应组件实例的 destroy 钩子函数</p></li> <li><p>mounted：对 include 和 exclude 参数进行监听，然后实时地更新（删除）this.cache 对象数据</p></li> <li><p>render：</p> <ol><li>第一步：获取 keep-alive 包裹着的第一个子组件对象及其组件名</li> <li>第二步：根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则执行第三步</li> <li>第三步：根据组件 ID 和 tag 生成缓存 Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置（更新 key 的位置是实现 LRU 置换策略的关键），否则执行第四步</li> <li>第四步：在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 设置值，超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）</li> <li>第五步：最后并且很重要，将该组件实例的 keepAlive 属性值设置为 true</li></ol></li></ul></li></ol> <ul><li>新增两个钩子函数：activated、deactivated</li></ul> <blockquote><p>Vue 的渲染过程：</p></blockquote> <p>new Vue -&gt; init -&gt; $mount -&gt; compile -&gt; render -&gt; VNode -&gt; patch -&gt; DOM</p> <p><strong>可得</strong>：Vue 的渲染是在 render 阶段开始的，但 keep-alive 的渲染是在 patch 阶段（将虚拟 DOM 转换成真实 DOM）</p> <p><strong>扩展</strong>：从 render 到 patch 的过程？</p> <ul><li>Vue 在渲染的时候先调用原型上的_render 函数将组件对象转化成一个 VNode 实例。而_render 是通过调用 createElement 和 createEmptyVNode 两个函数进行转化</li> <li>createElement 的转化过程会根据不同的情形选择 new VNode 或者调用 createComponent 函数做 VNode 实例化</li> <li>完成 VNode 实例化后，这时候 Vue 调用原型上的_update 函数把 VNode 渲染成真实 DOM，这个过程又是通过调用 patch 函数完成的（这就是 patch 阶段了）
<img src="https://img-blog.csdnimg.cn/20200810143213423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tpZURZSA==,size_16,color_FFFFFF,t_70" alt></li></ul> <blockquote><p>常见问题：</p></blockquote> <ul><li><p>keep-alive 不会生成真正的 DOM 节点，Vue 是如何做到的？</p> <p>Vue 在<strong>初始化生命周期</strong>的时候，为组件实例建立父子关系会根据 abstract 属性决定是否忽略某个组件。在 keep-alive 中，设置了 abstract:true，那 Vue 就会跳过该组件实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/instance/lifecycle.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
  <span class="token punctuation">}</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>keep-alive 包裹的组件是如何使用缓存的？</p> <p>在 patch 阶段，会执行 createComponent 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/vdom/patch.js</span>
<span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>hook<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
      <span class="token function">insert</span><span class="token punctuation">(</span>parentElem<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> refElem<span class="token punctuation">)</span> <span class="token comment">// 将缓存的DOM(vnode.elem) 插入父元素中</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>在首次加载被包裹组建时，由 keep-alive.js 中的 render 函数可知，vnode.componentInstance 的值是 undefined，keepAlive 的值是 true，因为 keep-alive 组件作为父组件，它的 render 函数会先于被包裹组件执行；那么只执行到 i(vnode,false)，后面的逻辑不执行</li> <li>再次访问被包裹组件时，vnode.componentInstance 的值就是已经缓存的组件实例，那么会执行 insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的 DOM 插入到父元素中</li></ol></li></ul> <h3 id="_10-你知道-vue2-的模板编译原理吗？和-vue3-做了哪些改进？"><a href="#_10-你知道-vue2-的模板编译原理吗？和-vue3-做了哪些改进？" aria-hidden="true" class="header-anchor">#</a> 10. 你知道 Vue2 的模板编译原理吗？和 Vue3 做了哪些改进？</h3> <h3 id="_11-vue3-中的-composition-api-和-vue2-中的-options-api-有什么不同？"><a href="#_11-vue3-中的-composition-api-和-vue2-中的-options-api-有什么不同？" aria-hidden="true" class="header-anchor">#</a> 11. Vue3 中的 Composition API 和 Vue2 中的 Options API 有什么不同？</h3> <ul><li><p>通常使用 Vue2 开发的项目，普遍会存在以下问题：</p> <ol><li>代码的可读性随着组件变大而变差</li> <li>每一种代码复用的方式，都存在缺点</li> <li>TypeScript 支持有限</li></ol></li> <li><p>mixins 的缺陷：</p> <ol><li>命名冲突</li> <li>数据来源不清楚</li></ol></li> <li><p>两者的主要区别：</p> <ol><li>在逻辑组织和逻辑复用方面，Composition API 是优于 Options API</li> <li>因为 Composition API 几乎是函数，会有更好的类型推断</li> <li>Composition API 对 tree-shaking 友好，代码也更容易压缩</li> <li>Composition API 中见不到 this 的使用，减少了 this 指向不明的情况</li> <li>如果是小型组件，可以继续使用 Options API，也是十分友好的</li></ol></li></ul> <h3 id="_12-说一下-vue2-中-diff-算法？vue3-做了哪些改进？"><a href="#_12-说一下-vue2-中-diff-算法？vue3-做了哪些改进？" aria-hidden="true" class="header-anchor">#</a> 12. 说一下 Vue2 中 Diff 算法？Vue3 做了哪些改进？</h3> <p>虚拟 DOM 是一个 JS 对象,虚拟 DOM 是一个对象. 虚拟 DOM 算法 = 虚拟 DOM + Diff 算法</p> <ul><li><p>使用虚拟 DOM 算法的损耗计算： 总损耗 = 虚拟 DOM 增删改+（与 Diff 算法效率有关）真实 DOM 差异增删改+（较少的节点）排版与重绘</p></li> <li><p>直接操作真实 DOM 的损耗计算： 总损耗 = 真实 DOM 完全增删改+（可能较多的节点）排版与重绘</p></li> <li><p>Diff 算法的目的是什么？
为了减少 DOM 操作的性能开销，我们要尽可能的复用 DOM 元素。所以我们需要判断出是否有节点需要移动，应该如何移动以及找出那些需要被添加或删除的节点。</p></li></ul> <p>diff 算法是一种通过<strong>同层的树节点</strong>进行比较的高效算法, diff 整体策略为：深度优先，同层比较</p> <p>其有两个特点：</p> <ol><li>比较只会在同层级进行, 不会跨层级比较</li> <li>在 diff 比较的过程中，循环从两边向中间比较</li></ol> <ul><li>原理分析
源码位置：src/core/vdom/patch.js</li></ul> <p>当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图</p> <p>对比流程：set -&gt; Dep.notify -&gt; patch(oldVnode, newVnode) -&gt; isSameVnode() -&gt; 不是直接替换，是走 patchVnode(1. oldVnode 有子节点, newVnode 没有；2. oldVnode 没有子节点, newVnode 有；3. 都是文本节点；4. 都有子节点)</p> <ul><li><p>sameVnode 方法判断是否为同一类型的节点
如何才算同一类型的节点，sameVnode(oldVnode, newVnode)几种情况：</p> <ol><li>key 值是否一样</li> <li>tagName 标签名是否一样</li> <li>isComment 是否都是注释节点</li> <li>是否都定义了 data(class, style)是否一样</li> <li>sameInputType() 当前节点为 input 时，type 必须相同</li></ol></li> <li><p>patchVnode 函数做了哪些事情
el: 真的的 DOM，oldVnode: 旧节点，newVnode: 新节点</p> <ol><li>获取对应的真实 DOM，el</li> <li>判断 newVnode 和 oldVnode 是否指向同一个对象，如果是，直接返回</li> <li>如果他们都有文本节点并且不相同，那么将 el 的文本节点设置为 newVnode 的文本节点</li> <li>如果 oldVnode 有子节点而新节点没有，则删除 el 的子节点</li> <li>如果 oldVnode 没有子节点而新节点有，则将 newVnode 的子节点真实化之后添加到 el</li> <li>如果两者都有子节点，则执行 updateChildren 函数比较子节点</li></ol></li> <li><p>updateChildren 函数五种比较情况：
记住一点，最终的渲染结果都要以 newVDOM 为准，这也解释了为什么之后的节点移动需要移动到 newVDOM 所对应的位置</p> <ol><li>旧头 &amp; 新头</li> <li>旧头 &amp; 新尾</li> <li>旧尾 &amp; 新头</li> <li>旧尾 &amp; 新尾</li> <li>如果以上逻辑都不匹配，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置</li></ol></li></ul> <h3 id="_13-描述一下组件的渲染和更新的过程？"><a href="#_13-描述一下组件的渲染和更新的过程？" aria-hidden="true" class="header-anchor">#</a> 13. 描述一下组件的渲染和更新的过程？</h3> <p>渲染组件时，会通过 Vue.extend 方法构建子组件的构造函数，初始化组件的时候会进行实例化。然后手动调用$mount()进行组件挂载渲染。更新组件时会进行 patchVnode 流程，核心就是 diff 算法。</p> <h3 id="_14-vue-为什么要采用-异步组件？抽象组件是个啥？动态组件？函数式组件优势？"><a href="#_14-vue-为什么要采用-异步组件？抽象组件是个啥？动态组件？函数式组件优势？" aria-hidden="true" class="header-anchor">#</a> 14. Vue 为什么要采用 异步组件？抽象组件是个啥？动态组件？函数式组件优势？</h3> <p>异步组件可以减少打包的结果。会将异步组件分开打包，会采用异步的方式加载组件，可以有效的解决一个组件过大的问题。不使用异步组件，如果组件功能比较多打包出来的结果就会变大</p> <p>异步组件的核心可以给组件定义变成一个函数，函数里面可以用 import 语法，实现文件的分割加载，import 语法是 webpack 提供的，采用的就是 jsonp</p> <div class="language-js extra-class"><pre class="language-js"><code>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">A</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'xxxx.vue'</span><span class="token punctuation">)</span>
  <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'xxx.vue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>异步组件的原理？
在 createComponent()方法中，定义了 asyncFactory 变量。然后判断 isUndef(Ctor.cid)，是否组件是一个函数，是则 asyncFactory = Ctor，调用 resolveAsyncComponent()方法；Ctor = resolveAsyncComponent(asyncFactory, baseCtor)，将 asyncFactory 传入让 asyncFactory 立马执行，但不会马上返回结果，会返回一个 promise。此时的值为 undefined。然后调用 createAsyncPlaceholder()方法创建一个异步组件的占位，空虚拟节点。当加载此组件的时候会调用 factory 函数传入 resolve, reject 两个参数，执行后返回影成功的回调和失败的回调，成功就调 resolve,resolve 中会调用 forceRender 强制更新视图重新渲染,forceRender 中调用$forceUpdate()。同时把结果放到 factory.resolve 上。如果强制刷新的时候就会再次走 resolveAsyncComponent 方法，这时候有个判断，如果有成功的结果就把结果直接放回去，这时候 resolveAsyncComponent 返回的就不是 undefined 了，就会接的创建组件，初始化组件，渲染组件</li></ul> <h3 id="_15-vue-router-中导航守卫有哪些？"><a href="#_15-vue-router-中导航守卫有哪些？" aria-hidden="true" class="header-anchor">#</a> 15. Vue-Router 中导航守卫有哪些？</h3> <ul><li>组件内导航守卫：
<ol><li>beforeRouterEnter: 在页面还未进入的时候。这个时候 vue 实力还未创建。因此访问不到 this。</li> <li>beforeRouterUpdate:当前页面组件被复用的时候，页面的路径发生了改变，会触发此方法。在这个时候是可以访问到 this 的</li> <li>beforeRouterLeave:离开当前路由的时候，即要离开当前页面的时候，这个时候是可以访问到 this 的</li></ol></li> <li>全局导航守卫：
<ol><li>router.beforeEach: 全局前置守卫进入路由之前触发</li> <li>router.beforeResolve: 全局解析守卫在 beforeRouteEnter 调用之后调用</li> <li>router.beforeAfter: 全局后置钩子进入路由后触发</li></ol></li> <li>路由独享守卫：<div class="language-js extra-class"><pre class="language-js"><code>routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
    component<span class="token punctuation">:</span> Foo<span class="token punctuation">,</span>
    <span class="token function-variable function">beforeEnter</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre></div></li></ul> <h3 id="_16-简述一下-vuex-工作原理？"><a href="#_16-简述一下-vuex-工作原理？" aria-hidden="true" class="header-anchor">#</a> 16. 简述一下 Vuex 工作原理？</h3> <ul><li>Vuex 是什么？</li></ul> <p>Vuex 是专门为 Vue 服务，用于管理页面的数据状态.相当于数据库 mongoDB，MySQL 等. 相似有 Redux</p> <p>Vuex 采用 MVC 模式中的 Model 层，规定所有的数据必须通过 action —&gt; mutaion —&gt; state 这个流程进行来改变状态的。再结合 Vue 的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过 DEVtools 去查看状态。</p> <ul><li><p>核心变量</p> <ol><li>state: 状态，类似于 data</li> <li>getters: 类似于 computed</li> <li>mutations: 更改 Vuex 的 store 中的状态的唯一方法时提交 mutation，类似于 methods</li> <li>actions: Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任何的异步操作, 但 mutation 必须是同步操作</li> <li>modules: 模块</li></ol></li> <li><p>核心原理：</p></li></ul> <p>Vuex 本质是一个对象，有两个属性，一个是 install 方法（作用是将 store 这个实例挂载到所有的组件上），一个是 Store 这个类（拥有 commit，dispatch 这些方法，Store 类里将用户传入的 state 包装成 data，作为 new Vue 的参数，从而实现了 state 值的响应式）</p> <blockquote><p>常见问题：</p></blockquote> <ul><li><p>Vue 项目中是怎么引入 Vuex 的？</p> <ol><li>安装 Vuex，再通过 import Vuex from 'vuex'引入</li> <li>先 const store = new Vuex.Store({…}),再把 store 作为参数的一个属性值，new Vue({store})</li> <li>通过 Vue.use(Vuex) 使得每个组件都可以拥有 store 实例</li></ol> <blockquote><ol><li>我们是通过 new Vuex.store({})获得一个 store 实例，也就是说，我们引入的 Vuex 中有 Store 这个类作为 Vuex 对象的一个属性。因为通过 import 引入的，<strong>实质上就是一个导出一个对象的引用</strong></li></ol></blockquote> <blockquote><ol start="2"><li>我们还使用了 Vue.use(),而 Vue.use 的一个原则就是执行对象的 install 这个方法</li></ol></blockquote> <p><strong>扩展</strong>：Vue.use 的实现原理？
Vue 是使用.use( plugins )方法将插件注入到 Vue 中。use 方法会检测注入插件 VueRouter 内的 install 方法，如果有，则执行 install 方法。</p> <pre><code>1. 参数：{ Object | Function } plugin
2. 安装Vue.js插件。如果插件是一个对象，必须提供install方法。如果插件是一个函数，它会被作为install方法。调用install方法时，会将Vue作为参数传入。install方法被同一个插件多次调用时，插件也只会被安装一次。
3. 注册插件，此时只需要调用install方法并将Vue作为参数传入即可。但在细节上有两部分逻辑要处理：
  1. 插件的类型，可以是install方法，也可以是一个包含install方法的对象。
  2. 插件只能被安装一次，保证插件列表中不能有重复的插件。
</code></pre> <ul><li>具体实现过程：
<ol><li>在 Vue.js 上新增了 use 方法，并接收一个参数 plugin</li> <li>首先判断插件是不是已经别注册过，如果被注册过，则直接终止方法执行，此时只需要使用 indexOf 方法即可</li> <li>toArray 方法我们在就是将类数组转成真正的数组。使用 toArray 方法得到 arguments。除了第一个参数之外，剩余的所有参数将得到的列表赋值给 args，然后将 Vue 添加到 args 列表的最前面。这样做的目的是保证 install 方法被执行时第一个参数是 Vue，其余参数是注册插件时传入的参数</li> <li>由于 plugin 参数支持对象和函数类型，所以通过判断 plugin.install 和 plugin 哪个是函数，即可知用户使用哪种方式祖册的插件，然后执行用户编写的插件并将 args 作为参数传入</li> <li>最后，将插件添加到 installedPlugins 中，保证相同的插件不会反复被注册（<strong>可能会问为什么插件不会被重新加载</strong>）</li></ol></li></ul> <blockquote><ol start="3"><li>执行 install 的时候，将 Vue 作为参数传进去.mixin 的作用是将 mixin 的内容混合到 Vue 的初始参数 options 中.如果判断当前组件是根组件的话，就将我们传入的 store 挂在到根组件实例上，属性名为$store. 如果判断当前组件是子组件的话，就将我们根组件的$store也复制给子组件。注意是引用的复制，因此每个组件都拥有了同一个$store 挂载在它身上</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">applyMixin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    beforeCreate<span class="token punctuation">:</span> vuexInit<span class="token punctuation">,</span> <span class="token comment">// Vuex初始化工作</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">vuexInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Vuex初始化工作'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根组件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>store
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>parent <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store <span class="token comment">// 把父组件的$store传给子组件</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>常见问题</strong>:</p> <ol><li>为什么是 beforeCreate 而不是 created 呢？: 因为如果是在 created 操作的话，$options 已经初始化好了</li> <li>为什么子组件可以从父组件里获取$store: 在执行子组件的 beforeCreate 的时候，父组件已经执行完 beforeCreate 了，那理所当然父组件已经有$store 了(<strong>考察父组件和子组件的执行顺序？</strong>)</li> <li>Vuex 和全局变量比有什么区别？：Vuex 具有响应式</li> <li>this.$store.vm.state 如何使用 this.state.xxx 访问：类的属性访问器，get state() {}</li> <li>为什么用 getter 的时候不用写括号: 利用了 Object.defineProperty 的 get 接口，其实写的是方法，但是取值的时候 是属性</li> <li>为什么 mutation 和 action 的第一个参数不同？mutation(thi.state, xxx) 而 action(this, xxx)<strong>注意</strong>：此时要使用<strong>箭头函数</strong></li> <li><strong>注意</strong>：Vue 中定义数据，属性名是有特点的，如果属性名是通过，$xxx命名的，是不会被代理的，使用$$state</li> <li>发布订阅模式: 将用户定义的 mutation 和 action 先保存起来(this._mutations = {}, this._actions = {})，当调用 commit 时，就找订阅的 mutation，当调用 dispatch，就找对应的 action 执行</li> <li>vue-router: 是把属性定义到了根实例上，所有的组件都能拿到这个根，通过根实例获取这个属性;vuex：是给每个组件都定义一个$store 属性，指定的是同一个人</li> <li>new Store -&gt; 收集模块转换成一棵树,this._modules = new ModuleCollection(options) -&gt; this.register() 存在 modules 选项，递归注册</li> <li>actions mutation 和 action 的区别？action 执行后返回的是一个 promise。判断 res 是不是一个 promise。不是则 Promise.resolve(res)返回。当调用 dispatch 方法时，Promise.all 执行</li> <li>Vuex3 内部会创建一个 vue 实例，但是 vuex4 直接采用 vue3 提供的响应式方法（reactive）；vuex4 中使用 provide（给根 app 增加一个_provides，子组件会向上查找）,inject（injectKey.js）</li> <li>Vuex 区分 State 是外部直接修改，还是通过 commit 修改?
Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 <code>this._withCommit(fn)</code> 设置 <code>_committing</code> 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。<strong>外部修改</strong>虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  flag<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>_committing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 通过commit修改</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 直接修改</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="14"><li>state 内部支持模块配置和模块嵌套，如何实现的
在  store  构造方法中有  makeLocalContext  方法，所有  module  都会有一个  local context，根据配置时的  path  进行匹配。所以执行如  dispatch('submitOrder', payload)这类  action  时，默认的拿到都是  module  的  local state，如果要访问最外层或者是其他  module  的  state，只能从  rootState  按照  path  路径逐步进行访问。</li></ol></li></ul> <h3 id="_17-vue-中父子组件的生命周期的顺序？"><a href="#_17-vue-中父子组件的生命周期的顺序？" aria-hidden="true" class="header-anchor">#</a> 17. Vue 中父子组件的生命周期的顺序？</h3> <ul><li>加载渲染过程： 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</li> <li>挂载阶段： 父 created-&gt;子 created-&gt;子 mounted-&gt;父 mounted</li> <li>父组件更新阶段： 父 beforeUpdate-&gt;父 updated</li> <li>子组件更新阶段： 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</li> <li>销毁阶段： 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</li></ul> <h3 id="_18-spa-单页面的理解以及优缺点？ssr-了解吗？"><a href="#_18-spa-单页面的理解以及优缺点？ssr-了解吗？" aria-hidden="true" class="header-anchor">#</a> 18. SPA 单页面的理解以及优缺点？SSR 了解吗？</h3> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <ul><li><p>优点：</p> <ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li> <li>基于上面一点，SPA 相对对服务器压力小</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li></ol></li> <li><p>缺点：</p> <ol><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势</li></ol></li> <li><p>SSR 服务端渲染 Nuxt.js</p> <ul><li>优点：
<ol><li>更利于 SEO</li> <li>更利于首屏渲染</li></ol></li> <li>缺点：
<ol><li>服务端压力较大</li> <li>开发条件受限（created 和 beforeCreate 之外的生命周期钩子不可用）</li> <li>学习成本相对较高（除了对 webpack、Vue 要熟悉，还需要掌握 node、Express 相关技术）</li></ol></li></ul></li></ul> <h3 id="_19-vue-中事件绑定原理？"><a href="#_19-vue-中事件绑定原理？" aria-hidden="true" class="header-anchor">#</a> 19. Vue 中事件绑定原理？</h3> <h3 id="_20-set、delete-的实现原理？"><a href="#_20-set、delete-的实现原理？" aria-hidden="true" class="header-anchor">#</a> 20. set、delete 的实现原理？</h3> <ul><li><p>set 的实现原理？</p> <ul><li>路径：src/core/instance/observer/index.js -&gt; set(target, key, val)</li> <li>大致流程：核心方法：defineReactive(ob.value, key, val)
<ol><li>判断目标值是否为有效值，不是有效值直接停止</li> <li>判断是否为数组，并且 key 值是否为有效的 key 值
如果是数组，就选择数组的长度和 key 值取较大值作为数组的新的 length 值，并且替换目标值 splice 方法，重写了，所以执行 splice，会双向数据绑定</li> <li>如果目标值是对象，并且 key 值是目标值存在的有效 key 值，并且不是原型上的 key 值
判断目标值是否为响应式的<strong>ob</strong>
如果是 vue 实例，直接不行
如果不是响应式的数据，就是普通的修改对象操作
如果是响应式数据，那就通过 Object.defineProperty 进行数据劫持</li> <li>通知 dom 更新 ob.dep.notify()</li></ol></li></ul></li> <li><p>delete 的实现原理？</p> <ul><li>路径：src/core/instance/observer/index.js -&gt; del(target, key)</li> <li>大致流程：核心逻辑：delete target[key]
<ol><li>非生产环境下, 不允许删除一个原始数据类型, 或者 undefined, null</li> <li>如果 target 是数组, 并且 key 是一个合法索引，通过数组的 splice 方法删除值, 并且还能触发数据的响应（数组拦截器截取到变化到元素, 通知依赖更新数据）</li> <li>target._isVue: 不允许删除 Vue 实例对象上的属性;（ob &amp;&amp; ob.vmCount）: 不允许删除根数据对象的属性，触发不了响应</li> <li>如果属性压根不在对象上, 什么都不做处理</li> <li>走到这一步说明, target 是对象, 并且 key 在 target 上, 直接使用 delete 删除</li> <li>如果 ob 不存在, 说明 target 本身不是响应式数据 return； 存在 ob, 通过 ob 里面存储的 Dep 实例的 notify 方法通知依赖更新 ob.dep.notify()</li></ol></li></ul></li></ul> <p><strong>扩展</strong>：$delete 和 delete 的区别？</p> <ol><li>delete 是 js 原生方法，由于语言限制，此操作无法设置<strong>回调</strong>来响应</li> <li>$delete 是 vue 提供的实例方法，核心就是在删除后通知了依赖更新</li></ol> <h3 id="_21-vue-源码设计用了哪些设计模式？"><a href="#_21-vue-源码设计用了哪些设计模式？" aria-hidden="true" class="header-anchor">#</a> 21. Vue 源码设计用了哪些设计模式？</h3> <ul><li>单例模式：new 多次，只有一个实例</li> <li>工场模式：传入参数就可以创建实例（虚拟节点的创建）</li> <li>发布订阅模式：eventBus</li> <li>观察者模式：watch 和 dep</li> <li>代理模式：_data 属性、proxy、防抖、节流</li> <li>中介者模式：vuex</li> <li>策略模式</li> <li>外观模式</li></ul> <p><strong>扩展</strong>：</p> <ul><li>发布 / 订阅模式和观察者模式的区别是什么？</li></ul> <p>在观察者模式中，被观察者通常会维护一个观察者列表。当被观察者的状态发生改变时，就会通知观察者</p> <p>在发布订阅模式中，具体发布者会动态维护一个订阅者的列表：可在运行时根据程序需要开始或停止发布给对应订阅者的事件通知</p> <p>区别在于发布者本身并不维护订阅列表（它不会像观察者一样主动维护一个列表），它会将工作委派给具体发布者（相当于秘书，任何人想知道我的事情，直接问我的秘书就可以了）；订阅者在接收到发布者的消息后，会委派具体的订阅者来进行相关的处理</p> <h3 id="_22-vue2-和-vue3-中-v-model-的实现原理？"><a href="#_22-vue2-和-vue3-中-v-model-的实现原理？" aria-hidden="true" class="header-anchor">#</a> 22. Vue2 和 Vue3 中 v-model 的实现原理？</h3> <ul><li><p>v-model：即可以作用于表单元素，也可以作用于自定义组件。无论是哪一种情况（vue2, vue3），它都是一个 <strong>语法糖</strong>，最终生成一个<strong>属性</strong>和<strong>事件</strong></p></li> <li><p><strong>当其作用于表单元素时</strong>，<code>vue</code>会根据作用的表单元素类型而生成合适的属性和事件</p> <ol><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件</li> <li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件</li> <li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件</li></ol></li> <li><p><strong>当其作用于自定义组件时</strong>，默认情况下，它会生成一个<code>value</code>属性和<code>input</code>事件</p> <ol><li>vue2 中：</li></ol> <div class="language-html extra-class"><pre class="language-html"><code>props: { value: Number, }, change(val) { this.$emit(&quot;update:value&quot;, val); },

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal = $event<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 等效于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ul><li>开发者可以通过组件的 model 配置来改变生成的属性和事件</li></ul> <div class="language-html extra-class"><pre class="language-html"><code>props: { number: Number, }, model: { prop: &quot;number&quot;, // 默认为 value event:
&quot;change&quot;, // 默认为 input }, change(val) { this.$emit(&quot;change&quot;, val); }

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 等效于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span> <span class="token attr-name">:number</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>data=$event<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="2"><li>vue3 中：默认情况下，它会生成一个<code>modelValue</code>属性和<code>onUpdate:modelValue</code>事件</li></ol> <div class="language-html extra-class"><pre class="language-html"><code>const props = defineProps({ modelValue: Number }) const emits =
defineEmits(['update:modelValue']); const change = (val) =&gt; {
emits('update:modelValue', val) }

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 等效于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">:modelValue</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>modelValue</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>vue2 和 vue3 都有 v-model,原理都是生成一个属性和一个事件，但是也存在些区别?</p> <ol><li>vue3 中去掉了<code>.sync</code>修饰符是，他的功能可以由<code>v-model</code>的参数替代</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- vue2 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 简写为 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">:title.sync</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- Vue3 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>input = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 简写为 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name"><span class="token namespace">v-model:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>inputVal<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>Vue3 中可以写多个 v-model, Vue2 只能一个</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name"><span class="token namespace">v-model:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageTitle<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-model:</span>content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageContent<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- 是以下的简写： --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span>
  <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageTitle<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">@update:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageTitle = $event<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">:content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageContent<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">@update:</span>content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>pageContent = $event<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="3"><li><code>v-model</code> 修饰符: vue2.x 是自带的修饰符（.lazy、.number、.trim 等），但是在 3.x 的版本中，可以自定义修饰符哦 .在 3.x 中的修饰符会在当作属性传递给子组件，并且在属性中生成一个<code>modelModifiers</code>的属性。存在这个修饰符就会有对应的修饰符，并且是 true,如果没有传递，那就是 undefined</li></ol> <div class="language-html extra-class"><pre class="language-html"><code>const props = defineProps({ modelValue: Number, modelModifiers: { default: ()
=&gt; ({}) } }) const emits = defineEmits(['update:modelValue']); const change =
(val) =&gt; { // 如果存在修饰符range2，那就多加1,减法就没有效果
if(props.modelModifiers.range2){ val++; } emits('update:modelValue', val) }

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">v-model.range2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>Vue2 中 v-model 源码分析？
在给页面上绑定了 v-model 之后，就会根据表单元素的 tag 标签以及 type 属性的值，去调用不同的 model 方法，这里我们调用 genDefaultModel</p> <ol><li>路径：src/platforms/web/compiler/directives/model.js -&gt; genDefaultModel()</li> <li>genDefaultModel()：先是去检测该表单元素是否同时有 v-model 绑定和 v-bind:value</li> <li>获取到表单元素的修饰符 lazy（替换 input 的 change 时间）,number（入字符串转为数字）及 trim.（去除两边空格），之后生成值得表达式</li> <li>通过 genAssignmentCode()方法生成 v-model value 值的代码</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  请输入：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/&gt;</span></span>
  你输入的是：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span> <span class="token attr-name">disabled</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

这一句代码经过vue的处理之后，就变成了

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message= $event.target.value<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/&gt;</span></span>

相当于将data里面的值通过响应式更新到视图上，然后给input绑定change事件，在改变值得时候对data里面message值做修改并更新视图
</code></pre></div></li></ul> <h3 id="_23-vue-computed-是如何实现的？"><a href="#_23-vue-computed-是如何实现的？" aria-hidden="true" class="header-anchor">#</a> 23. Vue computed 是如何实现的？</h3> <p>initComputed -&gt; new Watcher -&gt; defineComputed -&gt; createComputedGetter -&gt; 用户取值（dirty: false 返回上次计算的结果；dirty: true -&gt; watcher.evaluate）</p> <ul><li>基本使用
<ol><li>函数</li> <li>get set</li></ol></li> <li>与 watch 比较
<ol><li>computed 是计算一个新的属性，并将该属性挂载到 vm（Vue 实例）上，而 watch 是监听已经存在且已挂载到 vm 上的数据，所以用 watch 同样可以监听 computed 计算属性的变化（其它还有 data、props）</li> <li>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数</li> <li>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据</li></ol></li></ul> <p><strong>扩展</strong>：</p> <ul><li><p>Vue 响应系统，其核心有三点：observe、watcher、dep：</p> <ol><li>observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持</li> <li>dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象</li> <li>watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应</li></ol></li> <li><p>初始化
initProps -&gt; initMethods -&gt; initData -&gt; initComputed -&gt; initWatch</p></li> <li><p>Watcher 和 Dep 的关系，用一句话总结:
watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者，dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新</p></li> <li><p>原理解析</p> <ul><li>当组件初始化的时候，computed 和 data 会分别建立各自的响应系统，Observer 遍历 data 中每个属性设置 get/set 数据拦截</li> <li>初始化 computed 会调用 initComputed 函数
<ol><li>注册一个 watcher 实例，并在内实例化一个 Dep 消息订阅器用作后续收集依赖</li> <li>调用计算属性时会触发其 Object.defineProperty 的 get 访问器函数</li> <li>调用 watcher.depend() 方法向自身的消息订阅器 dep 的 subs 中添加其他属性的 watcher</li> <li>调用 watcher 的 evaluate 方法（进而调用 watcher 的 get 方法）让自身成为其他 watcher 的消息订阅器的订阅者，首先将 watcher 赋给 Dep.target，然后执行 getter 求值函数，当访问求值函数里面的属性（比如来自 data、props 或其他 computed）时，会同样触发它们的 get 访问器函数从而将该计算属性的 watcher 添加到求值函数中属性的 watcher 的消息订阅器 dep 中，当这些操作完成，最后关闭 Dep.target 赋为 null 并返回求值函数结果</li></ol></li> <li>当某个属性发生变化，触发 set 拦截函数，然后调用自身消息订阅器 dep 的 notify 方法，遍历当前 dep 中保存着所有订阅者 watcher 的 subs 数组，并逐个调用 watcher 的 update 方法，完成响应更新。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1. 存放computed的观察者</span>
<span class="token keyword">var</span> watchers <span class="token operator">=</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_computedWatchers <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 2. 遍历computed</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> userDef <span class="token punctuation">:</span> userDef<span class="token punctuation">.</span>get<span class="token punctuation">;</span>

  watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token comment">// 生成观察者（Watcher实例）</span>
    vm<span class="token punctuation">,</span>
    getter <span class="token operator">||</span> noop<span class="token punctuation">,</span><span class="token comment">// getter将在观察者get方法中执行</span>
    noop<span class="token punctuation">,</span>
    computedWatcherOptions <span class="token comment">// { lazy: true }懒执行，暂不执行get方法，当读取computed属性值执行</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 computed 属性添加到组件实例上，并通过 get、set 获取或者设置属性值，并且重定义 getter 函数</span>

  <span class="token keyword">function</span> <span class="token function">defineComputed</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> shouldCache <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      sharedPropertyDefinition<span class="token punctuation">.</span>get <span class="token operator">=</span> shouldCache <span class="token comment">// 重定义getter函数</span>
          <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
          <span class="token punctuation">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>

      Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将computed属性添加到组件实例上</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">computedGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// true，懒执行</span>
                watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行watcher方法后设置dirty为false</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">//返回观察者的value值</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
如果 dirty 为 <span class="token boolean">true</span>（即依赖的值没有发生变化），就不会重新求值。相当于 computed 被缓存了
</code></pre></div></li></ul> <p><img src="https://ask.qcloudimg.com/http-save/7220648/v751d0gmpn.png?imageView2/2/w/1620" alt></p> <p>每个 computed 属性都会生成对应的观察者（Watcher 实例），观察者存在 values 属性和 get 方法。computed 属性的 getter 函数会在 get 方法中调用，并将返回值赋值给 value。初始设置 dirty 和 lazy 的值为 true，lazy 为 true 不会立即 get 方法（懒执行），而是会在读取 computed 值时执行 computedWatcherOptions={lazy: true}</p> <h3 id="_24-你知道插槽-slot-是怎么“插”的吗"><a href="#_24-你知道插槽-slot-是怎么“插”的吗" aria-hidden="true" class="header-anchor">#</a> 24. 你知道插槽 Slot 是怎么“插”的吗?</h3> <ul><li>单个插槽(匿名插槽)</li></ul> <div class="language-html extra-class"><pre class="language-html"><code>// 子组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
// 父组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>汤小梦<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p>编译作用域
slot 其实就是能够让我们在父组件中添加内容到子组件的‘空间’。我们可以添加父组件内任意的 data 值. <child> </child>但是，我们能否直接使用子组件内的数据呢？显然不行！！</p> <p>直接传入子组件内的数据是不可以的。因为：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></li> <li><p>设置默认值
有时我没有在父组件内添加内容，那么 slot 就会显示默认值</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>这就是默认值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>具名插槽
有时候，也许子组件内的 slot 不止一个，那么我们如何在父组件中，精确的在想要的位置，插入对应的内容呢？ 给插槽命一个名即可，即添加 name 属性。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>one<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 这就是默认值1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>two<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 这就是默认值2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>three<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 这就是默认值3 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
// 父组件通过，或slot=&quot;name&quot;（旧语法），v-slot:name或#name（新语法）
的方式添加内容：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">'</span>app<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>&quot;one&quot;</span><span class="token punctuation">&gt;</span></span> 这是插入到one插槽的内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>&quot;two&quot;</span><span class="token punctuation">&gt;</span></span> 这是插入到two插槽的内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>&quot;three&quot;</span><span class="token punctuation">&gt;</span></span> 这是插入到three插槽的内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>作用域插槽 (父组件在子组件处使用子组件 data)
我们知道不能直接使用子组件内的数据，但是 我们也可以使用 slot-scope 的方式：让我们能够使用子组件的数据</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>one<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>child1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 这就是默认值1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span> //
    绑定child1的数据 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:value2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>child2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 这就是默认值2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>//
    绑定child2的数据，这里我没有命名slot
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>one</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>slotone<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ slotone.value1 }} // 通过v-slot的语法 将子组件的value1值赋值给slotone
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>slotde<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ slotde.value2 }} // 同上，由于子组件没有给slot命名，默认值就为default
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>Slot 插槽是怎么“插”的</p> <ul><li>普通插槽
<ol><li>父组件先解析，把 child 当做子元素处理，把 插槽当做 child 的子元素处理，并且在父组件作用域内得出了 parent 变量的值，生成对应的节点</li> <li>子组件解析，slot 作为一个占位符，会被解析成一个函数 _t('default') _t('one')</li> <li>_t 函数需要传入插槽名称，默认是 default，具名插槽则传入 name，这个函数的作用，是把第一步解析得到的插槽节点拿到，然后返回解析后的节点，那么子组件的节点就完整了.插槽也找到了父亲</li></ol></li> <li>作用域插槽
<ol><li>父组件先解析，遇到作用域插槽，会将此插槽封装成一个函数保存到子元素 child 下</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
      tag<span class="token punctuation">:</span> <span class="token string">&quot;child&quot;</span>
      scopeSlots<span class="token punctuation">:</span><span class="token punctuation">{</span>
          <span class="token keyword">default</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 记住这个data参数</span>
              <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'插入one slot 中插入默认 slot 中'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>value1 <span class="token operator">+</span> data<span class="token punctuation">.</span>value2<span class="token punctuation">]</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token function">one</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 记住这个data参数</span>
              <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'插入one slot 中'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>value1 <span class="token operator">+</span> data<span class="token punctuation">.</span>value2<span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>轮到子组件解析了，这个时候_t 函数又登场了，并且子组件将对应的插槽数据包装成一个对象，传进_t 函数</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token string">'我在子组件里面'</span><span class="token punctuation">,</span>
    <span class="token function">_t</span><span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>value1<span class="token punctuation">:</span> <span class="token string">'子数据1'</span><span class="token punctuation">,</span> value2<span class="token punctuation">:</span> <span class="token string">'子数据1'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">_t</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>value1<span class="token punctuation">:</span> <span class="token string">'子数据2'</span><span class="token punctuation">,</span> value2<span class="token punctuation">:</span> <span class="token string">'子数据2'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>接下来就是_t 内部执行，包装后的对象被当做 data 参数传入了 scopeSlots 中的对应的各个函数，解析成：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token string">'我在子组件里面'</span><span class="token punctuation">,</span>
    <span class="token string">'插入默认 slot 中 子数据1 子数据1'</span><span class="token punctuation">,</span>
    <span class="token string">'插入one slot 中 子数据2 子数据2'</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>$slots
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db269ceae0b24ed79cfe372c31d88bde~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt>
存放解析后的节点 VNode 对象。$slots 是一个 Map，key 是各个插槽的名称（匿名插槽的 key 为 default），key 对应的 value 都是各个插槽下面的 VNode 节点</li></ul></li></ul> <h3 id="_25-vue-组件中的-data-为什么是个函数？"><a href="#_25-vue-组件中的-data-为什么是个函数？" aria-hidden="true" class="header-anchor">#</a> 25. Vue 组件中的 data 为什么是个函数？</h3> <p>总结一下: 组件中的 data 是一个函数的原因在于：同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果 data 是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过 data 函数返回一个对象作为组件的状态。而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</p> <h3 id="_26-谈谈你对-vue-生命周期的理解？"><a href="#_26-谈谈你对-vue-生命周期的理解？" aria-hidden="true" class="header-anchor">#</a> 26. 谈谈你对 Vue 生命周期的理解？</h3> <p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p><img src="https://ask.qcloudimg.com/http-save/yehe-7229962/6l5o7c3m2o.png?imageView2/2/w/1620" alt></p> <ul><li>Vue 本质上是一个构造函数</li> <li>构造函数的核心是调用了_init 方法</li> <li>_init 内调用了很多初始化函数，从函数名称可以看出分别是执行
<ol><li>初始化生命周期（initLifecycle）</li> <li>初始化事件中心（initEvents）</li> <li>初始化渲染（initRender）</li> <li>执行 beforeCreate 钩子（callHook(vm, 'beforeCreate')）</li> <li>解析 inject（initInjections）</li> <li>初始化状态（initState）</li> <li>解析 provide（initProvide）</li> <li>执行 created 钩子（callHook(vm, 'created')）</li></ol></li> <li>在_init 函数的最后有判断如果有 el 就执行$mount 方法
<ol><li>重写了 Vue 函数的原型上的$mount 函数</li> <li>判断是否有模板，并且将模板转化成 render 函数</li></ol></li> <li>最后调用了 runtime 的 mount 方法，用来挂载组件，也就是 mountComponent 方法
<ol><li>mountComponent 内首先调用了 beforeMount 方法，然后在初次渲染和更新后会执行 vm._update(vm._render(), hydrating)方法。最后渲染完成后调用 mounted 钩子</li> <li>beforeUpdate 和 updated 钩子是在页面发生变化，触发更新后，被调用的，对应是在 src/core/observer/scheduler.js 的 flushSchedulerQueue 函数中</li> <li>beforeDestroy 和 destroyed 都在执行 destroy 函数时被调用</li></ol></li></ul> <h3 id="_26-vue-中常见的性能优化方式"><a href="#_26-vue-中常见的性能优化方式" aria-hidden="true" class="header-anchor">#</a> 26. Vue 中常见的性能优化方式?</h3> <ul><li>编码优化
<ol><li>尽量不要将所有的数据都放在 data 中，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</li> <li>vue 在 v-for 时给每项元素绑定事件尽量用事件代理</li> <li>拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )</li> <li>v-if 当值为 false 时内部指令不会执行,具有阻断功能，很多情况下使用 v-if 替代 v-show</li> <li>合理使用路由懒加载、异步组件</li> <li>Object.freeze 冻结数据</li></ol></li> <li>用户体验
<ol><li>app-skeleton 骨架屏</li> <li>pwa serviceworker</li></ol></li> <li>加载性能优化
<ol><li>第三方模块按需导入 ( babel-plugin-component )</li> <li>滚动到可视区域动态加载 ( vue-virtual-scroll-list )</li> <li>图片懒加载 (vue-lazyload)</li></ol></li> <li>SEO 优化
<ol><li>预渲染插件 prerender-spa-plugin</li> <li>服务端渲染 ssr</li></ol></li> <li>打包优化
<ol><li>使用 cdn 的方式加载第三方模块</li> <li>多线程打包 happypack、parallel-webpack</li> <li>控制包文件大小（tree shaking / splitChunksPlugin）</li> <li>使用 DllPlugin 提高打包速度</li></ol></li> <li>缓存/压缩
<ol><li>客户端缓存/服务端缓存</li> <li>服务端 gzip 压缩</li></ol></li></ul> <h3 id="_27"><a href="#_27" aria-hidden="true" class="header-anchor">#</a> 27.</h3> <h2 id="五、react-相关"><a href="#五、react-相关" aria-hidden="true" class="header-anchor">#</a> 五、React 相关</h2> <h3 id="_1-setstate-是同步还是异步？"><a href="#_1-setstate-是同步还是异步？" aria-hidden="true" class="header-anchor">#</a> 1. setState 是同步还是异步？</h3> <ul><li>异步情况 在 React 事件当中是异步操作</li> <li>同步情况 如果是在 setTimeout 事件或者自定义的 dom 事件中，都是同步的</li></ul> <h3 id="_2-说说-react-中的事件机制？"><a href="#_2-说说-react-中的事件机制？" aria-hidden="true" class="header-anchor">#</a> 2. 说说 React 中的事件机制？</h3> <h3 id="_3-对-fiber-的理解？解决了什么问题？"><a href="#_3-对-fiber-的理解？解决了什么问题？" aria-hidden="true" class="header-anchor">#</a> 3. 对 Fiber 的理解？解决了什么问题？</h3> <h3 id="_4-谈谈你对-react-hooks-的理解？"><a href="#_4-谈谈你对-react-hooks-的理解？" aria-hidden="true" class="header-anchor">#</a> 4. 谈谈你对 React Hooks 的理解？</h3> <h3 id="_5-react-中性能优化有哪些手段？"><a href="#_5-react-中性能优化有哪些手段？" aria-hidden="true" class="header-anchor">#</a> 5. React 中性能优化有哪些手段？</h3> <h3 id="_6-说一下你对-diff-算法的理解？"><a href="#_6-说一下你对-diff-算法的理解？" aria-hidden="true" class="header-anchor">#</a> 6. 说一下你对 Diff 算法的理解？</h3> <h3 id="_7-react-中受控组件和非受控组件的区别？"><a href="#_7-react-中受控组件和非受控组件的区别？" aria-hidden="true" class="header-anchor">#</a> 7. React 中受控组件和非受控组件的区别？</h3> <h3 id="_8-描述-redux-单项数据流？"><a href="#_8-描述-redux-单项数据流？" aria-hidden="true" class="header-anchor">#</a> 8. 描述 Redux 单项数据流？</h3> <h3 id="_9-jsx-本质是什么？context-是什么？有何用途？"><a href="#_9-jsx-本质是什么？context-是什么？有何用途？" aria-hidden="true" class="header-anchor">#</a> 9. JSX 本质是什么？context 是什么？有何用途？</h3> <h2 id="六、http-相关"><a href="#六、http-相关" aria-hidden="true" class="header-anchor">#</a> 六、HTTP 相关</h2> <h3 id="_1-说一下-get-和-post-的区别？"><a href="#_1-说一下-get-和-post-的区别？" aria-hidden="true" class="header-anchor">#</a> 1. 说一下 GET 和 POST 的区别？</h3> <ul><li><p>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</p></li> <li><p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</p></li> <li><p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会保留</p></li> <li><p>GET 请求参数通过 URL 传递且参数是有长度限制的（2083 字符，中文字符的话只有 2083/9=231 个字符），而 POST 参数放在 Request body 中是没有限制的</p></li> <li><p>对参数的数据类型，GET 只接受 ASCII 字符（如果非 ASCII 字符会进行转码），而 POST 没有限制</p></li> <li><p>GET 和 POST 本质上就是 TCP 链接, GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包</p> <p><strong>注意</strong>：并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次</p> <ol><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li> <li>对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</li></ol></li></ul> <h3 id="_2-http1-0、http1-1、http2、http3-的区别？"><a href="#_2-http1-0、http1-1、http2、http3-的区别？" aria-hidden="true" class="header-anchor">#</a> 2. HTTP1.0、HTTP1.1、HTTP2、HTTP3 的区别？</h3> <h3 id="_3-dns-解析过程及原理？回源是什么？cdn-的原理和回源是什么？dns-劫持听说过吗？"><a href="#_3-dns-解析过程及原理？回源是什么？cdn-的原理和回源是什么？dns-劫持听说过吗？" aria-hidden="true" class="header-anchor">#</a> 3. DNS 解析过程及原理？回源是什么？CDN 的原理和回源是什么？DNS 劫持听说过吗？</h3> <ul><li>DNS 解析过程
<ol><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li> <li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li> <li>路由缓存：路由器也有 DNS 缓存。</li> <li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li> <li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ol></li> <li>CDN 原理
CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应</li></ul> <h3 id="_4-tcp-和-udp-区别是什么？"><a href="#_4-tcp-和-udp-区别是什么？" aria-hidden="true" class="header-anchor">#</a> 4. TCP 和 UDP 区别是什么？</h3> <ul><li>UDP
<ol><li>无连接</li> <li>面向报文，只是报文的搬运工</li> <li>不可靠，没有拥塞控制</li> <li>高效，头部开销只有 8 字节</li> <li>支持一对一、一对多、多对多、多对一</li> <li>适合直播、视频、语音、会议等实时性要求高的</li></ol></li> <li>TCP
<ol><li>面向连接：传输前需要先连接</li> <li>可靠的传输</li> <li>流量控制：发送方不会发送速度过快，超过接收方的处理能力</li> <li>拥塞控制：当网络负载过多时能限制发送方的发送速率</li> <li>不提供时延保障</li> <li>不提供最小带宽保障</li></ol></li></ul> <h3 id="_5-如何理解-tcp-ip-五层模型-osi-七层模型？"><a href="#_5-如何理解-tcp-ip-五层模型-osi-七层模型？" aria-hidden="true" class="header-anchor">#</a> 5. 如何理解 TCP/IP 五层模型 OSI 七层模型？</h3> <ul><li>OSI 七层模型
<ol><li>应用层：文件传输，常用协议 HTTP，FTP</li> <li>表示层：数据格式化，代码转换，数据加密，</li> <li>会话层：建立，解除会话</li> <li>传输层：提供端对端的接口，tcp,udp</li> <li>网络层：为数据包选择路由，IP，icmp</li> <li>数据链路层：传输有地址的帧</li> <li>物理层：二进制的数据形式在物理媒体上传输数据</li></ol></li></ul> <h3 id="_6-为什么-https-比-http-安全？https-是如何保证安全的？"><a href="#_6-为什么-https-比-http-安全？https-是如何保证安全的？" aria-hidden="true" class="header-anchor">#</a> 6. 为什么 HTTPS 比 HTTP 安全？HTTPS 是如何保证安全的？</h3> <h3 id="_7-http-常见的状态码有哪些？适用的场景？"><a href="#_7-http-常见的状态码有哪些？适用的场景？" aria-hidden="true" class="header-anchor">#</a> 7. HTTP 常见的状态码有哪些？适用的场景？</h3> <ul><li><p>常见的状态码：</p> <ol><li>1xx 表示消息类</li> <li>2xx 表示成功类</li> <li>3xx 表示重定向类</li> <li>4xx 表示请求错误</li> <li>5xx 表示服务器错误</li></ol></li> <li><p>状态码的适用场景：</p> <ol><li>100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据</li> <li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li> <li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名</li> <li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li> <li>304：协商缓存</li> <li>400：参数有误，请求无法被服务器识别</li> <li>403：告诉客户端禁止访问该站点或者资源</li> <li>404：服务器找不到资源时</li> <li>503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503</li> <li>504：网关超时</li></ol></li></ul> <h3 id="_8-知道-http-的缓存吗？（浏览器强缓存和协商缓存）"><a href="#_8-知道-http-的缓存吗？（浏览器强缓存和协商缓存）" aria-hidden="true" class="header-anchor">#</a> 8. 知道 HTTP 的缓存吗？（浏览器强缓存和协商缓存）</h3> <p>强缓存是利用 Expires（http1.0）和 Cache-Control（http1.1）这两个字段来控制的，控制资源缓存的时间，在有效期内不会去向服务器请求了，同时存在，优先 Cache-Control</p> <ul><li>Expires 的值为一个绝对时间（由于 Expires 是依赖于客户端系统时间，当修改了本地时间后，缓存可能会失效）</li> <li>给 Cache-Control 设置 max-age ，表示缓存的最长时间是多少秒，是一个相对时间。</li> <li>Catch-Control 的值：public 都缓存；private 客服端缓存，服务器不换车；no-cache：表示不进行强缓存，而是用协商缓存来验证；no-store 所有内容都不缓存</li></ul> <p>协商缓存是由服务器来确定缓存资源是否可用，是利用 Last-Modified（http1.0）（表示被请求资源在服务器端的最后一次修改时间）/ If-Modified-Since 和 ETag（每次文件修改后服务端那边会生成一个新的 ETag）/if-None-Match 来控制的，同时存在，优先 ETag</p> <ul><li>Last-Modified/if-Modified-Since 的缺点：（文件有可能在 1s 内修改内容、文件内容修改后又复原）</li> <li>ETag 性能上的不足,只要文件发生改变,<code>ETag</code>就会发生改变. <code>ETag</code>需要服务器通过算法来计算出一个 hash 值</li></ul> <h3 id="_9-前端错误的分类有哪些？"><a href="#_9-前端错误的分类有哪些？" aria-hidden="true" class="header-anchor">#</a> 9. 前端错误的分类有哪些？</h3> <ul><li><p>前端错误类型：</p> <ol><li>SyntaxError(语法错误)</li> <li>ReferenceError(引用错误)</li> <li>TypeError(类型错误)</li> <li>RangeError(范围越界错误)</li></ol></li></ul> <h3 id="_10-说说为什么前端会有跨域？如何解决跨域？知道-option-请求吗？"><a href="#_10-说说为什么前端会有跨域？如何解决跨域？知道-option-请求吗？" aria-hidden="true" class="header-anchor">#</a> 10. 说说为什么前端会有跨域？如何解决跨域？知道 option 请求吗？</h3> <p>不同域之间相互请求资源，称为”跨域“；浏览器的 <strong>同源策略</strong>（同源：url 是由协议、域名、端口和路径等组成。如果两个路径的协议、域名、端口都相同则表示再同一个域上）</p> <p>在浏览器上 script、img、link、iframe 等标签都可以加载跨域资源 且不受同源限制</p> <ul><li><p>非同源限制：</p> <ol><li>无法读取非同源网页的 Cookie、LocalStorage、IndexedDB</li> <li>无法接触非同源网页的 DOM</li> <li>无法向非同源地址发起 ajax 请求</li></ol></li> <li><p>解决跨域的方式：</p> <ol><li><p><strong>设置 document.domain 解决无法读取非同源网页的 Cookie 问题</strong>
浏览器是通过 document.domain 属性来检查两个页面是否同源，因此只要通过设置相同的 document.domain，两个页面就可以共享 Cookie。（**缺点：**此方案仅限主域相同，子域不同的跨域应用场景）</p></li> <li><p><strong>JSONP</strong>
是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本 IE），<strong>缺点</strong>：是只支持 get 请求， 需要后台配合，将返回结果包装成 callback(res)的形式。原理是利用 script 元素的跨域能力
**核心思想：**网页通过添加一个<code>script元素</code>，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来</p> <ul><li>原生 js 实现【请求地址后面添加?callback=&quot;xxx&quot;,然后在 script 中添加 xxx 方法其参数返回结果】</li> <li>jQuery 的 ajax【dataType: 'jsonp', 请求方式为 jsonp；jsonpCallback: 'handleCallback' 自定义回调函数】</li></ul> <p><strong>扩展</strong>：</p> <ol><li>script 的 src 和 img 的 src 跨域的区别？
原理上都是利用标签的 src 可绕过同源限制，跨域请求的特点；区别在于：img 只能单向发送 get 请求，不可访问响应内容（只是展现），而 script 可对其进行解析</li> <li>如果黑客植入 script 脚本通过 jsonp 的方式对服务器进行攻击，怎么办？
可以通过页面设置的内容安全协议 csp 进行防范</li></ol></li> <li><p><strong>H5 提供的 postMessage</strong>
postMessage 事件发送消息，message 事件接受消息</p></li> <li><p><strong>跨域资源共享 CORS</strong>【常用】
浏览器将 CORS 请求分成两类：简单请求和非简单请求；当发出简单请求，只需要在头信息之中增加一个 Origin 字段。当发出 CORS 非简单请求，会在正式通信之前，增加一次 OPTIONS 查询请求，称为&quot;预检&quot;请求（preflight）。设置响应头的 Access-Control-Allow-Origin： *
<strong>扩展</strong>：简单请求同时满足的三个条件？</p> <ol><li>请求方式只能是：GET、POST、HEAD</li> <li>HTTP 请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID</li> <li>Content-type 只能取：application/x-www-form-urlencoded(是 Jquery 的 Ajax 请求默认方式)、multipart/form-data、text/plain</li></ol> <p>预检请求(preflight)：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p> <p><strong>重点</strong>：服务端如何避免每次都发出预检请求？（缓存）</p> <ol><li>Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求（全局和局部方式）常用</li> <li>@CrossOrigin 注解，可细粒度精确到单个请求级别</li></ol></li> <li><p>**window.name **
name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）</p></li> <li><p><strong>vue 中 proxy 配置本地代理</strong></p></li> <li><p><strong>H5 中的 websocket</strong></p></li> <li><p><strong>Nginx 代理</strong></p></li></ol></li></ul> <p><strong>扩展</strong>：二级域名和域名是否同源？非同源的话是如何传递 cookie 的？</p> <h3 id="_11-tcp-三次握手-四次挥手（短连接-长连接）？"><a href="#_11-tcp-三次握手-四次挥手（短连接-长连接）？" aria-hidden="true" class="header-anchor">#</a> 11. TCP 三次握手 &amp; 四次挥手（短连接 &amp; 长连接）？</h3> <ul><li>TCP 三次握手
<ol><li>第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq=x，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认</li> <li>.第二次握手：Server 收到数据包后由标志位 SYN=1 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack=x+1，随机产生一个值 seq=y，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量</li> <li>第三次握手：Client 收到确认后，检查 ack 是否为 x+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=y+1，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y+1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据
<strong>三次握手</strong>：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</li></ol></li></ul> <h3 id="_12-v8-如何执行一段-js-代码？"><a href="#_12-v8-如何执行一段-js-代码？" aria-hidden="true" class="header-anchor">#</a> 12. V8 如何执行一段 JS 代码？</h3> <h3 id="_13-多路复用与-keep-alive-的区别？"><a href="#_13-多路复用与-keep-alive-的区别？" aria-hidden="true" class="header-anchor">#</a> 13. 多路复用与 keep-alive 的区别？</h3> <h2 id="七、webpack-相关"><a href="#七、webpack-相关" aria-hidden="true" class="header-anchor">#</a> 七、Webpack 相关</h2> <h3 id="_1-说说你对-webpack-的理解？它解决了什么问题？"><a href="#_1-说说你对-webpack-的理解？它解决了什么问题？" aria-hidden="true" class="header-anchor">#</a> 1. 说说你对 Webpack 的理解？它解决了什么问题？</h3> <p>Webpack 是一个现代的 JS 应用程序的静态模块打包器。它主要做的事情就是：分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Sass TS 等）。并将其打包为合适的格式以供浏览器使用。</p> <ul><li><p>Webpack 的主要功能:</p> <ol><li>代码转换</li> <li>文件优化</li> <li>代码分割</li> <li>模块合并</li> <li>自动刷新</li> <li>代码校验</li> <li>自动发布等等</li></ol></li> <li><p>早期模块化？</p> <ol><li>把单独的功能抽离到单独的 js 文件，通过 script 引入。</li></ol> <ul><li>**问题：**模块都在全局中，大量模块污染环境，并且模块与模块之间没有依赖关系，维护困难，没有私有空间等问题</li> <li><strong>解决</strong>：出现了 <code>命名空间</code> 方式，规定每个模块只暴露一个全局对象，模块的内容都挂载在这个对象中; ---》还是没有解决第一种方式的 <code>依赖</code> 等问题
<ul><li>再后来，使用 <code>立即执行函数</code> 模块提供私有空间，通过 <code>参数</code> 的形式作为依赖声明; ---》这种方式还是存在一些问题。比如：通过 script 引入模块，这些<strong>模块的加载并不受代码的控制</strong></li></ul></li> <li><strong>理想的解决方式</strong>：在页面中引入一个 JS 入口文件，其余用到的模块可以通过代码控制，按需加载进来</li></ul> <ol start="2"><li>除了 <strong>模块加载</strong>的问题以外，还需要规定模块化的规范。如今流行的：CommonJS、ES Module</li></ol></li> <li><p>从前后端渲染的 JSP、PHP。到前端原生 JavaScript。再到 jQuery 开发。再到目前三大框架 Vue, React, Angular 开发。也从 JavaScript 到后面的 es5,6,7,8...。再到 TypeScript。有些编写的 CSS 预处理器 less、sass 等。如今的前端变得十分复杂，所以我们开发过程中会遇到以下问题：</p> <ol><li>项目需要通过模块化的方式来开发</li> <li>使用一些高级的特性来加快我们的开发效率，如：ES6+、TypeScript 开发脚本逻辑，通过 Less、Sass 等方式来编写 css 样式代码</li> <li>监听文件的变化并且反映到浏览器上，提高开发效率</li> <li>JS 代码需要模块化，HTML 和 CSS 这些资源文件有些也需要模块化</li> <li>开发完后我们需要将代码压缩、合并以及一些优化等问题</li></ol></li></ul> <p><strong>综合</strong>：Webpack 恰巧可以解决以上问题！</p> <h3 id="_2-webpack-的构建流程？"><a href="#_2-webpack-的构建流程？" aria-hidden="true" class="header-anchor">#</a> 2. Webpack 的构建流程？</h3> <p><img src="https://ask.qcloudimg.com/http-save/yehe-7229962/kl8mmit2al.png?imageView2/2/w/1620" alt></p> <ul><li><strong>初始化参数</strong>：解析 webpack 配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数,形成最后的配置结果</li> <li><strong>开始编译</strong>：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件 监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译</li> <li><strong>确认入口</strong>：根据配置的 entry 入口，开始解析文件构建 AST（抽象语法树），找出依赖，递归下去</li> <li><strong>编译模块</strong>：递归中根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li> <li><strong>完成模块编译并输出资源</strong>：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据 entry 或分包配置生成代码块 chunk</li> <li><strong>输出完成</strong>：输出所有的 chunk 到文件系统</li></ul> <h3 id="_3-常见的-loader、plugin-有哪些？能手写吗？"><a href="#_3-常见的-loader、plugin-有哪些？能手写吗？" aria-hidden="true" class="header-anchor">#</a> 3. 常见的 Loader、Plugin 有哪些？能手写吗？</h3> <ul><li><p>常见的 Plugin:</p> <ol><li><strong>html-webpack-plugin</strong>：可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件</li> <li><strong>extract-text-webpack-plugin</strong>：将 js 文件中引用的样式单独抽离成 css 文件（webpack4 推荐使用 mini-css-extract-plugin）</li></ol> <ul><li>两者有啥区别？
<ol><li>后者：更容易使用、异步加载、而且只针对 CSS，并且不重复编译，性能更好</li> <li>该插件一般在（生产环境）使用。代替 loaders 中的 style-loader，暂时不支持 HMR</li></ol></li></ul> <ol start="3"><li><strong>clean-webpack-plugin</strong>: 清理每次打包的文件</li> <li><strong>speed-measure-webpack-plugin</strong>: 可以看每个 Loader 和 Plugin 执行耗时（webpack5 使用 speed-measure-webpack5-plugin）</li> <li><strong>webpack-bundle-analyzer</strong>: 可视化 Webpack 输出文件的体积</li> <li><strong>copy-webpack-plugin</strong>：拷贝插件</li> <li><strong>friendly-errors-webpack-plugin</strong>： 识别某些类别的 webpack 错误，并清理，聚合和优先级，以提供更好的开发人员体验</li></ol> <ul><li>webpack 中提供了 stats 选项显示打包信息（只展示错误信息、都展示等等）</li></ul> <ol start="8"><li><strong>optimize-css-assets-webpack-plugin</strong>：压缩 css</li> <li><strong>purgecss-webpack-plugin</strong>: 去除无用的 css</li> <li><strong>uglifyJs-webpack-plugin</strong>：压缩 js（压缩 es6 的代码不是很友好；并且是单线程压缩代码，打包时间慢，所以开发环境将其关闭，生产环境打开（parallelUglifyPlugin 开启多个子进程打包，每个子进程还是 UglifyJS 打包，但并行执行）-》webpack4 推荐用 terser-webpack-plugin（开启 parallel 参数【一般是电脑的 CPU 核数减 1】，使用进程压缩）；此插件 webpack5 中内置了）</li> <li><strong>compression-webpack-plugin</strong>：（生产环境可采用）gzip 压缩 JS 和 CSS【需要后台配置 nginx】</li> <li><strong>HotModuleReplacementPlugin</strong>：热更新（自带的）</li> <li><strong>happypack</strong>：开启多进程打包，提高打包速度</li> <li><strong>ProvidePlugin</strong>：自动加载模块，代替 require 和 import（自带）</li> <li><strong>DefinePlugin</strong>：定义全局变量（浏览器获取的值，需使用 JSON.stringify 包裹）</li> <li><strong>IgnorePlugin</strong>：忽略或排除（moment 不用全部加载，只加载中文）</li> <li><strong>DllPlugin</strong>：动态链接库，配合 DllReferencePlugin 一起使用（自带的）</li> <li><code>Plugin</code> 就是一个扩展器，它比 <code>Loader</code> 更加灵活，因为它可以接触到 <code>Webpack</code> 编译器。在 <code>Webpack</code> 运行的生命周期中会广播出许多的事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。这样 <code>Plugin</code> 就可以通过一些 hook 函数来拦截 <code>Webpack</code> 的执行，做一些 <code>Webpack</code> 打包之外的事情。像：<code>打包优化</code>、<code>资源管理</code>、<code>注入环境变量</code>等等。</li> <li>插件实例上都会有个 apply 方法，并将 compiler 作为其参数。（类似于：Vue 插件都有个 install 方法）</li> <li>在开发 <code>Plugin</code> 时最常用的两个对象 <code>Compiler</code> 和 <code>Compilation</code>，它们都继承自<code>Tapable</code>，是 <code>Plugin</code> 和 <code>Webpack</code> 之间的桥梁。类似于 <code>react-redux</code> 是连接 <code>React</code> 和 <code>Redux</code> 的桥梁
<ul><li>Tapable 有同步钩子和异步钩子（异步串行钩子和异步并行钩子）</li></ul></li> <li>注册钩子的方式：同步（tap 注册 -》 call 执行）；异步（tap -》call、tapAsync -》callAsync、tapPromise -》promise）</li> <li>通过 schema-utils 验证 options 的合法性</li></ol></li> <li><p>常见的 Loader:</p> <ol><li>file-loader：</li> <li>url-loader：</li> <li>babel-loader：</li> <li>css-loader：</li> <li>style-loader：</li> <li>eslint-loader：</li> <li>cache-loader：</li> <li>less-loader、sass-loader、styles-loader：</li> <li>image-webpack-loader：压缩图片</li> <li>postcss-loader、autoprefixer-loader</li></ol> <p>就是一个代码转码器，对各种资源进行转换。它的特点：单一原则，每个 loader 只做对应的事情。它的执行顺序：从右到左，从下到上。有几种分类：pre、normal（默认）、inline、post。<code>Loader</code> 就是一个函数，接受原始资源作为参数，输出进行转换后的内容。</p> <ul><li>loader 的执行分为两个阶段：Pitch 阶段和 Normal 阶段。<code>loader</code> 会先执行 <code>pitch</code>，然后获取资源再执行 <code>normal loader</code>。如果 <code>pitch</code> 有返回值时，就不会走之后的 <code>loader</code>，并将返回值返回给之前的 <code>loader</code>。这就是为什么 <code>pitch</code> 有 <strong>熔断</strong> 的作用！</li> <li>loader-utils 中 getOptions(this)方法用来获取 loader 中 options 的配置</li> <li>schema-utils 中 validate 方法用来验证 loader 中 options 的配置是否合法{type: 'object', properties: {}, additionalProperties: true}</li> <li>loader 分为同步（return 或 this.callback(null, source, map, meta)两种方式）和异步（this.async()）</li></ul></li></ul> <h3 id="_4-如何提高-webpack-的构建速度？"><a href="#_4-如何提高-webpack-的构建速度？" aria-hidden="true" class="header-anchor">#</a> 4. 如何提高 Webpack 的构建速度？</h3> <p>优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手：</p> <ul><li>多线程/多实例构建：HappyPack(不维护了)、thread-loader</li> <li>优化 loader 的配置
<ol><li>include 和 exclude</li> <li>配置 babel-loader 时，可以配置 cacheDirectory 开启缓存</li></ol></li> <li>合理的使用 resolve.extensions
<ol><li>extensions: [&quot;.js&quot;,&quot;.json&quot;]</li></ol></li> <li>优化 resolve.modules
<ol><li>用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>['node_modules']</code>，配置了可以减少查找路径</li></ol></li> <li>优化 resolve.alias
<ol><li>&quot;@&quot;:path.resolve(__dirname,'./src')减少查找过程</li></ol></li> <li>使用 DllPlugin 插件
<ol><li>打包成一个 Dll 库，webpack.DllPlugin() -&gt; 生成 mainfest.json 文件</li> <li>引入 Dll 库，webpack.DllReferencePlugin()</li></ol></li> <li>使用 cache-loader
<ol><li>针对一些开销较大的 loader 前添加 cache-loader，将其结果缓存到磁盘里，显著提升二次构建速度（保存和读取这些缓存文件会有一些时间开销，只针对一些开销大的 loader）</li> <li>use: ['cache-loader', ...loaders]</li></ol></li> <li>terser 开启多线程
<ol><li>使用多进程并行运行来提高构建速度</li> <li>optimization: { minimizer: [new TerserPlugin({ parallel: true })] }</li></ol></li> <li>合理使用 sourceMap</li></ul> <h3 id="_5-webpack4-和-webpack5-有哪些区别？"><a href="#_5-webpack4-和-webpack5-有哪些区别？" aria-hidden="true" class="header-anchor">#</a> 5. Webpack4 和 Webpack5 有哪些区别？</h3> <ul><li>压缩代码
内部自带 terser-webpack-plugin 插件（生产环境自动开启压缩）【webpack4 需要独立安装】<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack5开发环境启动压缩</span>
<span class="token keyword">const</span> TerserPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'terser-webpack-plugini'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    usedExports<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 只导出被使用的模块</span>
    minimize<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 启动压缩</span>
    minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">TerserPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div>**扩展：**开发模块开启 Tree Shaking 的方式？【生产环境自动开启】
<ul><li>optimization.sideEffects: true; //开启 （package.json 里也要配置：'sideEffects: false | true | []'）</li> <li>Tree-shaking 机制的原理？
<ol><li>treeShaking 也叫<code>摇树优化</code>，是一种通过移除多于代码，来优化打包体积的，<code>生产环境默认开启</code></li></ol></li></ul></li></ul> <ol start="2"><li>它可以在<code>代码不运行</code>的状态下，分析出<code>不需要的代码</code></li> <li>利用<code>es6模块</code>的规范
<ol><li>ES6 Module 引入进行<code>静态分析</code>，故而<code>编译的时候正确判断到底加载了那些模块</code></li></ol></li> <li>Tree-shaking 的实现：
<ol><li>先<strong>标记</strong>出模块导出值中哪些没有被用过</li> <li>使用 Terser 删掉这些没被用到的导出语句</li> <li>标记过程大致可划分为三个步骤：
<ol><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li> <li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li> <li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ol></li></ol></li></ol> <ul><li><p>缓存配置</p> <ol><li>webpack4 通过 hard-source-webpack-plugin 缓存</li> <li>webpack5 内置了 cache 缓存机制</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用持久化缓存</span>
  cache<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token string">'filesystem'</span><span class="token punctuation">,</span>
    cacheDirectory<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'node_modules/.cache/webpack'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>**注意：**cache 在开发模式默认设置成 type: memory; 【生产模块把 cache 给禁用掉了】</p></li> <li><p>启动服务的差别</p> <ol><li>webpack4 启动服务 -&gt; webpack-dev-server</li> <li>webpack5 启动服务使用内置的 webpack serve 启动</li></ol></li> <li><p>输出代码</p> <ol><li>webpack4 只能输出 es5 的代码</li> <li>webpack5 新增属性 output.ecmaVersion，可以生成 es5 和 es6 的代码</li></ol></li> <li><p>代码分割</p> <ol><li>webpack4 将超过 30kb 文件单独提为一个 chunk（minSize: 30000）</li> <li>webpack5 可以区分是 js 还是 css，精准划分（minSize: {javascript: 30000, css: 50000}）</li></ol></li> <li><p>模块联邦</p></li> <li><p>devtool 差别</p> <ol><li>webpack4 有 13 种</li> <li>webpack5 有 26 种
**扩展：**webpack4 一般开发环境配置 cheap-eval-module-source-map，在生产用 none；webpack5 使用 eval-cheap-module-source-map</li></ol></li></ul> <h3 id="_6-grunt、gulp、webpack、rollup、vite-的比较？"><a href="#_6-grunt、gulp、webpack、rollup、vite-的比较？" aria-hidden="true" class="header-anchor">#</a> 6. Grunt、Gulp、Webpack、Rollup、Vite 的比较？</h3> <p><strong>模块化管理工具</strong> 和 <strong>自动化构建工具</strong> 是不同的。两者主要的侧重点不一样。<strong>自动化构建工具</strong> 则侧重于 <strong>前端开发的整个过程</strong> 的控制管理（像流水线）。而<strong>模块化管理工具</strong>更侧重于 <strong>模块打包</strong>。可以把开发中的所有资源（图片、js、css 文件等）都当成 <strong>模块</strong></p> <ul><li><p><strong>Webpack</strong>: 是当前最流行的 <strong>模块化管理工具</strong> 和 打包工具。其通过 loader 的转换，可以将任何形式的资源都当成模块。它还可以将各个模块通过其 <strong>依赖关系</strong> 打包成符合生产环境部署的前端资源。它还可以将应用程序分解成可管理的代码块，可以按需加载</p> <p><strong>打包原理</strong>：解析各个模块的依赖关系，使用 loader 转换文件，使用 plugin 注入钩子，打包合并模块，最终生成 bundle 文件，使用 express 开启本地服务器，浏览器请求的是 bundle 文件</p> <ul><li><p><strong>优点</strong>：</p> <ol><li>基本之前 gulp 可以操作的，webpack 都可以做</li> <li>同时支持热更新、tree-shaking、Scope Hoisting、动态加载、代码拆分、文件指纹、代码压缩、静态资源处理等</li> <li>支持多种打包方式</li></ol></li> <li><p><strong>缺点</strong>：</p> <ol><li>各个模块之间的依赖关系过于复杂 会导致打包速度很慢</li> <li>使用热更新时，改动一个模块，其他有依赖关系的模块也会重新打包</li> <li>不支持打包出 esm 格式的代码（打包后的代码再次被引用时 tree shaking 困难），打包后亢余代码较多</li></ol></li></ul></li> <li><p><strong>Vite</strong>：和 webpack 差不多，vite 是当下新型的 <strong>模块化管理工具</strong> 和打包工具。它本地启动速度比 webpack 快了很多。但是 vite 还完成没有替换 webpack 的能力，不管是从社区还是从能力来说，vite 本身还是太过脆弱，它的产生和火热完成依赖于 vue 本身的热度</p> <p><strong>打包原理</strong>：使用 koa 开启本地服务器，没有 webpack 那样打包合并的过程，所以启动服务器快</p> <ul><li><p><strong>缺点</strong>：</p> <ol><li>项目的开发浏览器要支持 esmmodule</li> <li>不能识别 commonjs 语法</li> <li>生态没有 webpack 丰富</li> <li>生产环境 esbuild 构建对于 css 和代码分割不够友好</li></ol></li></ul></li> <li><p><strong>Rollup</strong>：是下一代 ES6 <strong>模块打包工具</strong>，可以将我们按照 ESM（ES2015 Module）规范编写的源码构建输出如下格式：</p> <ol><li>IIFE：自执行函数，可通过 script 标签加载</li> <li>AMD：通过 requirejs 加载</li> <li>CommonJS：Node 默认的模块规范，可通过 webpack 加载</li> <li>UMD：兼容 IIFE、AMD、CJS 三种模块规范</li> <li>ESM：ES2015 Module 规范，可用 webpack，rollup 加载</li></ol> <ul><li><p><strong>优点</strong>：</p> <ol><li>支持动态导入</li> <li>支持 tree-shaking。仅加载模块里用得到的函数以减少文件大小</li> <li>Scope Hoisting。rollup 可以将所有的小文件生成到一个大文件中，所有代码都在同一个函数作用域里；不会像 webpack 那样用很多函数来包装模块</li> <li>没有其他冗余代码, 执行很快。除了必要的 <code>cjs</code>, <code>umd</code> 头外，bundle 代码基本和源码差不多，也没有奇怪的 <code>__webpack_require__</code>, <code>Object.defineProperty</code> 之类的东西</li></ol></li> <li><p><strong>缺点</strong>：</p> <ol><li>不支持热更新功能</li> <li>对于 commonjs 模块，需要额外的插件将其转化为 es2015 供 rollup 处理</li> <li>无法公共代码拆分</li></ol></li></ul> <p><strong>适用场景</strong>：开发第三方库、生成单一的 umd 文件的场景
<strong>比较 Webpack</strong>：</p> <ol><li>Rollup 目前还不支持代码拆分（Code Splitting）和模块的热更新（HMR）</li> <li>一般，对于应用开发使用 Webpack，对于类库开发使用 Rollup</li> <li>需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 CommonJS 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup</li> <li>React 已经将构建工具从 Webpack 换成了 Rollup</li></ol></li> <li><p><strong>Gulp</strong>：是基于 <strong>流</strong> 的 <strong>前端自动化构建工具</strong>，采用代码优于配置的策略，更容易学习和使用，它让简单的任务简单，复杂的任务复杂</p> <ul><li><p><strong>优点</strong>：</p> <ol><li>gulp 文档简单，学习成本低，使用也比较简单</li> <li>对大量源文件可以进行流式处理，借助插件，可以对文件类型进行多种操作处理</li></ol></li> <li><p><strong>缺点</strong>：</p> <ol><li>不支持 tree-shaking、热更新、代码拆分等</li> <li>gulp 对 js 模块化方案无能为力，只是对静态资源做流式处理，处理之后并未做有效的优化整合</li></ol></li></ul> <p><strong>适用场景</strong>：静态资源密集操作型场景，主要用于 css、图片等静态资源的处理操作
<strong>比较 grunt</strong>:</p> <ol><li>易用，Gulp 相比于 Grunt 更简洁，而且遵循代码优于配置策略，维护 Gulp 更像是写代码</li> <li>高效，Gulp 核心设计是基于 Unix 的<strong>流</strong>的概念，通过<strong>管道</strong>连接，不需要写中间文件</li> <li>易学，Gulp 的核心 API 只有 5 个，之后可以通过管道流组合自己想要的任务</li> <li>流：使用 Grunt 的 I/O 过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。而使用 Gulp 的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次 I/O 的过程，流程更清晰，更纯粹</li> <li>代码优于配置：维护 Gulp 更像是写代码，而且 Gulp 遵循 CommonJS 规范，因此跟写 Node 程序没有区别</li></ol></li> <li><p><strong>Grunt</strong>：是一套 <strong>前端自动化工具</strong>，帮助处理反复重复的任务。一般用于：编译、压缩、合并文件，简单语法检查等</p> <ul><li><p><strong>特点</strong>：</p> <ol><li>Grunt 有一个完成的社区，插件丰富</li> <li>它简单易学，你可以随便安装插件并配置它们</li></ol></li></ul></li></ul> <p>Webpack 的定位是模块打包器，而 Gulp/Grunt 属于构建工具</p> <h3 id="_7-了解热更新原理吗？它是如何做到的？说说其原理？"><a href="#_7-了解热更新原理吗？它是如何做到的？说说其原理？" aria-hidden="true" class="header-anchor">#</a> 7. 了解热更新原理吗？它是如何做到的？说说其原理？</h3> <p>开启了 express 应用，添加了对 webpack 编译的监听，添加了和浏览器的 websocket 长连接，当文件变化触发 webpack 进行编译并完成后，会通过 socket 告诉浏览器准备刷新。而为了减少刷新的代价，就是<strong>不用刷新页面</strong>，而是<strong>刷新某个模块</strong>，webpack-dev-server 可以支持热更新，通过生成文件的 hash 来对比需要更新的模块，浏览器再进行热替换</p> <p><strong>扩展</strong>：hash、chunkhash、contenthash 三者的区别？</p> <ul><li><p>hash 一般是结合 CDN 缓存来使用的</p> <ol><li>hash：是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都公用相同的 hash 值（每一次构建都会生成新的 hash 值（不管文件是否有改动）-》导致没有办法实现缓存效果）</li> <li>chunkhash：和 hash 不一样，它根据不同的入口文件（entry）进行依赖文件解析，构建对于的 chunk，生成对应的哈希值。-》（同一个 chunk 的一个依赖改变了，其他的依赖哈希值也会变）</li> <li>contenthash：针对的是对应的内容是否改变</li></ol></li> <li><p>如何避免相同的随机值？</p> <p>webpack 在<code>计算hash后分割chunk</code>。<code>产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）</code></p></li></ul> <h3 id="_8-sourcemap-有哪些？对应的作用是什么？"><a href="#_8-sourcemap-有哪些？对应的作用是什么？" aria-hidden="true" class="header-anchor">#</a> 8. sourceMap 有哪些？对应的作用是什么？</h3> <h3 id="_9-babel-的原理？"><a href="#_9-babel-的原理？" aria-hidden="true" class="header-anchor">#</a> 9. Babel 的原理？</h3> <p>Babel 是 JS 语法转换器（将一些高级语法转换成浏览器可以识别的低级语法）</p> <p>Babel 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p> <ol><li>解析（Parse） ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li> <li>转换（Transform） ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li> <li>生成（Generate） ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li></ol> <ul><li><p><strong>Babel 的原理</strong>：</p> <ol><li>使用 babylon 将源代码进行解析 -&gt; 得到 AST</li> <li>使用 babel-traverse 对 AST 树进行遍历转义 -&gt; 得到新的 AST 树</li> <li>使用 babel-generator 通过 AST 树生成 ES5 代码</li></ol></li> <li><p><strong>Babel 的包构成</strong>：</p> <ol><li>babel-core: babel 的核心库，提供一下 babel 转义 API，如 babel.transform 等，用于对代码进行转译。（webpack 的 babel-loader 是调用这些 API 来完成转译的）</li> <li>babylon：js 的词法解析器</li> <li>babel-traverse：用于对 AST 的遍历</li> <li>babel-generator: 根据 AST 生成代码</li></ol></li> <li><p><strong>工具包和功能包</strong>：</p> <ol><li>babel-cli：babel 的命令行工具，通过命令行对 js 代码进行转译</li> <li>babel-register：通过绑定 node.js 的 require 来自动转译 require 引用的 js 代码文件</li> <li>babel-types：用于检验、构建和改变 AST 树的节点</li> <li>babel-polyfill：JS 标准新增的原生对象和 API 的 shim，实现上仅仅是 core-js 和 regenerator-runtime 两个包的封装</li> <li>babel-runtime：功能类似 babel-polyfill，一般用于 library 或 plugin 中，因为它不会污染全局作用域</li></ol></li></ul> <p><strong>扩展</strong>：<strong>babel-runtime 和 babel-polyfill 的区别？</strong></p> <p>babel 默认只转译新的 JS 语法，而不转译新的 API（如：Iterator、Set、Generator、Proxy、Symbol 等全局对象），以及一些定义在全局对象上的方法（如：Object.assign）都不会转译。如果想使用这些新的对象和方法，则需要为当前环境提供一个 ployfill</p> <ul><li>babel-ployfill，它会加载整个 polyfill 库，解决了 babel 不转译新 API 的问题。并且在代码中插入一些帮助函数
<strong>缺点</strong>：直接在代码中插入帮助函数，会导致污染了全局环境；并且全部引入，打包后会有很多重复的代码，导致编译后的代码体积变大</li> <li>babel-runtime：babel 为了解决以上问题，提供了单独的包，用以提供编译模块的工具函数。启用 babel-plugin-transform-runtime（它会帮我自动动态 require @babel/runtime 中的内容）后，babel 就会使用 babel-runtime 下的工具函数；<strong>这样可以避免自行引入 polyfill 时导致的污染全局命名空间的问题</strong></li> <li>babel-runtime 适合在组件，类库项目中使用，而 babel-polyfill 适合在业务项目中使用</li></ul> <p><strong>扩展</strong>：babel-runtime 为什么适合 JavaScript 库和工具包的实现？</p> <ol><li>避免 babel 编译的工具函数在每个模块里重复出现，减小库和工具包的体积</li> <li>在没有使用 babel-runtime 之前，库和工具包一般不会直接引入 polyfill。否则像 Promise 这样的全局对象会污染全局命名空间。在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了</li></ol> <p><strong>注意</strong>：具体项目还是需要使用 babel-polyfill，只使用 babel-runtime 的话，实例方法不能正常工作（例如 <code>&quot;foobar&quot;.includes(&quot;foo&quot;)</code>）</p> <h3 id="_10-module、chunk、bundle-分别是什么意思，有何区别？"><a href="#_10-module、chunk、bundle-分别是什么意思，有何区别？" aria-hidden="true" class="header-anchor">#</a> 10. module、chunk、bundle 分别是什么意思，有何区别？</h3> <ul><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 <strong>module</strong></li> <li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 <strong>chunk</strong> 文件，webpack 会对这个 chunk 文件进行一些操作</li> <li>webpack 处理好 chunk 文件后，最后会输出 <strong>bundle</strong> 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行</li></ul> <p><strong>总结</strong>：我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle</p> <h3 id="_11-webpack-optimize-有配置过吗-可以简单说说吗"><a href="#_11-webpack-optimize-有配置过吗-可以简单说说吗" aria-hidden="true" class="header-anchor">#</a> 11. Webpack optimize 有配置过吗?可以简单说说吗?</h3> <h2 id="八、经典面试题"><a href="#八、经典面试题" aria-hidden="true" class="header-anchor">#</a> 八、经典面试题</h2> <h3 id="_1-从输入-url-到页面展示经历了什么？"><a href="#_1-从输入-url-到页面展示经历了什么？" aria-hidden="true" class="header-anchor">#</a> 1. 从输入 URL 到页面展示经历了什么？</h3> <ul><li><p>总体流程如下：</p> <ol><li><p>URL 解析
完整的 URL：<code>协议 + 主机 + 端口 + 路径 + 参数 + 锚点</code>。如果为非 url 结构的字符串，交给浏览器默认引擎去搜索改字符串；若为 url 结构的字符串，浏览器主进程会交给 网络进程 ,开始干活。</p> <ul><li>encodeURI 和 encodeURIComponent 的区别？
encodeURI 是编码<code>整个URL</code>，而 encodeURIComponent 编码的是<code>参数</code>部分</li></ul></li> <li><p>检查资源缓存
在有效期内的缓存资源直接使用，称之为<code>强缓存</code>。返回 200，size 为 memory cache(资源从内存中取出)和 disk cache(资源从磁盘中取出)。当超过有效期的，则携带缓存的资源标识向服务器发起请求。返回 304，走<code>协商缓存</code>;返回 200,向服务器发起请求，将结果缓存起来，为下一次使用
<strong>通常来说</strong>：刷新页面会使用<code>内存缓存</code>; 关闭后重新打开会使用<code>磁盘缓存</code></p></li> <li><p>DNS 解析：将域名解析成 IP 地址
如果没有成功使用本地缓存，则需要发起网络请求，发起之前要做 DNS 解析，会依次搜索：<code>浏览器DNS缓存 -&gt; 操作系统DNS缓存 -&gt; 路由器DNS缓存 -&gt; 服务商DNS服务器查询 -&gt; 全球13台根域名服务器查询</code></p> <p>为了节约时间，可以在 HTML 头部做 DNS 的预解析：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://www.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>为了保证响应的及时，DNS 解析使用的是 UDP 协议</p> <p>用户向本地 DNS 服务器发起请求属于<code>递归请求</code>，本地 DNS 服务器向各级域名服务器发起请求属于<code>迭代请求</code></p></li> <li><p>TCP 连接：TCP 三次握手</p></li> <li><p>发送 HTTP 请求</p></li> <li><p>服务器处理请求并返回 HTTP 报文</p></li> <li><p>浏览器解析并渲染页面</p></li> <li><p>断开 TCP 连接：TCP 四次挥手</p></li></ol></li></ul> <h3 id="_2-长列表优化？"><a href="#_2-长列表优化？" aria-hidden="true" class="header-anchor">#</a> 2. 长列表优化？</h3> <h3 id="_3-大文件上传的方案有哪些？"><a href="#_3-大文件上传的方案有哪些？" aria-hidden="true" class="header-anchor">#</a> 3. 大文件上传的方案有哪些？</h3> <p><strong>核心</strong>：是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回原文件的某个切片</p> <p>根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的<strong>可并发性</strong>，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间</p> <ul><li><p>由于是并发，传输到服务端的顺序可能会发生变化 -》 所以我们还需要给每个切片<code>记录顺序</code></p></li> <li><p>服务端需要负责: 接受这些切片，并在接收到所有切片后<strong>合并切片</strong> <strong>两个问题</strong>:</p> <ul><li>何时合并切片，即切片什么时候传输完成?
<ol><li>需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并</li> <li>也可以额外发一个请求主动通知服务端进行切片的合并</li></ol></li> <li>如何合并切片?
使用 nodejs 的 api fs.appendFileSync，它可以同步地将数据追加到指定文件，也就是说，当服务端接受到所有切片后，先创建一个最终的文件，然后将所有切片逐步合并到这个文件中</li></ul></li> <li><p>接着实现比较重要的上传功能，上传需要做两件事</p> <ol><li><p>对文件进行切片
当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过一个常量 Length 控制，这里设置为 10，即将文件分成 10 个切片上传, createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回. 在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p> <p>随后调用 uploadChunks 上传所有的文件切片，将 <code>文件切片</code>，<code>切片 hash</code>，以及<code>文件名</code>放入 <code>FormData</code> 中，再调用上一步的 request 函数返回一个 promise，最后调用 <code>Promise.all 并发</code>上传所有的切片</p></li></ol></li></ul> <ol start="2"><li><p>将切片传输给服务端
<strong>接受切片</strong>: 使用 multiparty 包处理前端传来的 FormData, 在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p> <div class="language-js extra-class"><pre class="language-js"><code>server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">const</span> multipart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">multiparty<span class="token punctuation">.</span>Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  multipart<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fields<span class="token punctuation">,</span> files</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>chunk<span class="token punctuation">]</span> <span class="token operator">=</span> files<span class="token punctuation">.</span>chunk
    <span class="token keyword">const</span> <span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> fields<span class="token punctuation">.</span>hash
    <span class="token keyword">const</span> <span class="token punctuation">[</span>filename<span class="token punctuation">]</span> <span class="token operator">=</span> fields<span class="token punctuation">.</span>filename
    <span class="token keyword">const</span> chunkDir <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">UPLOAD_DIR</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filename<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
    <span class="token comment">// 切片目录不存在，创建切片目录</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fse<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>chunkDir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">await</span> fse<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span>chunkDir<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重命名文件</span>
    <span class="token keyword">await</span> fse<span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>path<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>chunkDir<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hash<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'received file chunk'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="http://www.yiyong.info/blog/article/20200303170508797.png" alt>
查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename 重命名的方式移动临时文件，也就是文件切片</p> <p>在接受文件切片时，需要先创建存储切片的文件夹，由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中
<img src="http://www.yiyong.info/blog/article/20200303170541632.png" alt></p> <p><strong>合并切片</strong>: 在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并
使用 fs.writeFileSync 先创建一个空文件，这个空文件的文件名就是切片文件夹名 + 后缀名组合而成，随后通过 fs.appendFileSync 从切片文件夹中不断将切片合并到空文件中，每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹</p></li> <li><p>显示上传进度条
上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度
<strong>切片进度条</strong>：
XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p> <p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数；每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可</p> <div class="language-js extra-class"><pre class="language-js"><code>onProgress<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createProgressHandler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">createProgressHandler</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   item<span class="token punctuation">.</span>percentage <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>loaded <span class="token operator">/</span> e<span class="token punctuation">.</span>total<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可
</code></pre></div><p><strong>文件进度条</strong>：
将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue <strong>计算属性</strong></p> <div class="language-js extra-class"><pre class="language-js"><code> computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   <span class="token function">uploadPercentage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>container<span class="token punctuation">.</span>file <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">const</span> loaded <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data
       <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>size <span class="token operator">*</span> item<span class="token punctuation">.</span>percentage<span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> acc <span class="token operator">+</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>loaded <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>container<span class="token punctuation">.</span>file<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><p><img src="http://www.yiyong.info/blog/article/20200303170719623.png" alt></p></li></ol> <ul><li><p>断点续传
断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能:</p> <ol><li>前端使用 localStorage 记录已上传的切片 hash</li> <li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片
第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以选取<strong>后者</strong></li></ol></li> <li><p>生成 hash
无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash，所以我们修改一下 hash 的生成规则. <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值</p> <p>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会引起 UI 的阻塞，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p> <p>由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了 importScripts 函数用于导入外部脚本，通过它导入 spark-md5.在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p> <p>主线程使用 postMessage 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 onMessage 事件拿到文件 hash</p> <p>至此前端需要将之前用文件名作为 hash 的地方改写为 worker 返回的这个 hash,服务端则使用 hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名</p></li> <li><p>文件秒传
所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功</p> <p>文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p></li> <li><p>暂停上传
断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传.原理是使用 XMLHttpRequest 的 abort 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">onProgress</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> e<span class="token punctuation">,</span>
    requestList
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      xhr<span class="token punctuation">.</span>upload<span class="token punctuation">.</span>onprogress <span class="token operator">=</span> onProgress<span class="token punctuation">;</span>
      xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span>
        xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> headers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
      xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      xhr<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将请求成功的 xhr 从列表中删除</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>requestList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> xhrIndex <span class="token operator">=</span> requestList<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> xhr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        requestList<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>xhrIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          data<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>response
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 暴露当前 xhr 给外部</span>
    requestList<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>xhr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了
<img src="http://www.yiyong.info/blog/article/20200303171006248.png" alt>
每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存正在上传切片的 xhr,之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p></li> <li><p>恢复上传
由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</p> <p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p> <ol><li>服务端已存在该文件，不需要再次上传</li> <li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把已上传的文件切片返回给前端</li></ol> <p>回到前端，前端有两个地方需要调用验证的接口:</p> <ol><li>点击上传时，检查是否需要上传和已上传的切片</li> <li>点击暂停后的恢复上传，返回已上传的切片</li></ol></li></ul> <p><strong>总结</strong>:</p> <ul><li>大文件上传
<ol><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li> <li>服务端接收切片并存储，收到合并请求后使用 fs.appendFileSync 对多个切片进行合并</li> <li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li> <li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ol></li> <li>断点续传
<ol><li>使用 spart-md5 根据文件内容算出文件 hash</li> <li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li> <li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li> <li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传</li></ol></li></ul> <h3 id="_4-自己有开发过组件库吗？"><a href="#_4-自己有开发过组件库吗？" aria-hidden="true" class="header-anchor">#</a> 4. 自己有开发过组件库吗？</h3> <h3 id="_5-说说你对项目的优化有哪些？有量化吗？"><a href="#_5-说说你对项目的优化有哪些？有量化吗？" aria-hidden="true" class="header-anchor">#</a> 5. 说说你对项目的优化有哪些？有量化吗？</h3> <h3 id="_6-有开发过脚手架库吗？"><a href="#_6-有开发过脚手架库吗？" aria-hidden="true" class="header-anchor">#</a> 6. 有开发过脚手架库吗？</h3> <ul><li>基本功能：
<ol><li>通过 tmc create projectName 命令创建项目</li> <li>询问用户需要选择下载的模板</li> <li>远程拉取模板</li></ol></li> <li>工具库：
<ol><li>inquirer: 命令行询问用户问题</li> <li>commander: 命令行自定义指令</li> <li>chalk: 控制台输出内容样式美化</li> <li>ora: 控制台 loading 效果</li> <li>download-git-repo: 下载远程模板</li> <li>cross-spawn: 跨平台 shell 工具（可以用来自动执行 shell 命令）</li> <li>figlet: logo
获取远程模板: axios.get('https://api.github.com/orgs/[仓库名]/repos')
获取远程版本: axios.get('https://api.github.com/repos/[仓库名]/${repo}/tags')
gitlab 获取方式：https://docs.gitlab.com/ee/api/repositories.html#get-file-archive</li></ol></li> <li>实现思路：#! /usr/bin/env node
<ol><li>创建 bin/cli.js 启动文件，package.json 中添加&quot;bin&quot;: {&quot;tmc&quot;: &quot;./bin/cli.js&quot;}, 然后 npm link 链接到全局：控制台执行 tmc</li> <li>使用 commander 创建启动命令，（command 定义命令和参数、description 描述、option 选项、action 动作），配置版本号信息，parse(process.argv)解析用户执行命令传入的参数</li> <li>创建项目之前要考虑：目录是否存在？</li></ol> <ul><li>若存在：</li></ul> <ol><li>当{force: true}时，直接移除原来的目录，直接创建</li> <li>当{force: false}时，询问用户是否覆盖</li></ol> <ul><li>若不存在，直接创建</li></ul> <ol start="4"><li>添加更多的 option 选项，logo</li> <li>通过 inquirer 询问用户当{force: false}时，是否覆盖</li> <li>通过 axios.get 获取项目列表和 tag 列表</li> <li>通过 download-git-repo 来下载远程模板（在获取之前显示 loading 关闭 loading）</li></ol></li></ul> <h3 id="_7-封装过哪些组件？"><a href="#_7-封装过哪些组件？" aria-hidden="true" class="header-anchor">#</a> 7. 封装过哪些组件？</h3> <ul><li><p>UI 组件：</p> <ol><li>柱状图组件（BarChart.vue）</li> <li>折线图组件（LineChart.vue）</li> <li>饼图组件（PieChart.vue）</li> <li>表格组件 （SaaSTable.vue）</li> <li>导入组件（SaaSUpdate.vue）</li> <li>放大弹框组件（ZoomCard.vue）</li> <li>漏斗组件（FunnelChart.vue）</li> <li>布局组件（SideMenu.vue/SideMenuItem.vue）</li> <li>面积图组件</li> <li>堆积图组件</li></ol></li> <li><p>业务组件：</p> <ol><li>盒子组件（SquareCard.vue）</li> <li>暂无数据组件（NoData.vue）</li> <li>动态表单搜索组件（DynamicSearch.vue）</li> <li>卡片组件（BaseCard.vue）</li> <li>卡片组合组件（Card.vue）</li> <li>统计组件（Statistics.vue）</li> <li>自动生成页面组件（TailerBillBoard.vue）</li> <li>自定义颜色组件</li></ol></li></ul> <h3 id="_8-你搭建的项目是从哪些方面入手的？"><a href="#_8-你搭建的项目是从哪些方面入手的？" aria-hidden="true" class="header-anchor">#</a> 8. 你搭建的项目是从哪些方面入手的？</h3> <h3 id="_9-说说你对前端模块化的理解？"><a href="#_9-说说你对前端模块化的理解？" aria-hidden="true" class="header-anchor">#</a> 9. 说说你对前端模块化的理解？</h3> <h3 id="_10-说说浏览器渲染原理？"><a href="#_10-说说浏览器渲染原理？" aria-hidden="true" class="header-anchor">#</a> 10. 说说浏览器渲染原理？</h3> <ul><li>解析 HTML，生成 DOM 树。解析 CSS，生成 CSSOM 树</li> <li>将 DOM 树和 CSS 树结合，生成渲染树（Render Tree）</li> <li>Layout(回流)：根据生成的渲染树，进行回流（Layout）,得到节点的几何信息（位置、大小）</li> <li>Painting(重绘)：根据渲染树以及回流得到节点的几何信息，从而得到节点的绝对像素</li> <li>Display：将像素发送给 GPU。展示在页面上</li></ul> <p><strong>注意</strong>：渲染树只包含<strong>可见的</strong>节点
<strong>扩展</strong>：为了构建渲染树，浏览器主要完成了以下工作：</p> <ol><li>从 DOM 树的根节点开始遍历每个可见节点</li> <li>对于每个可见的节点，找到 CSSOM 树中对于的规则，并应用它们</li> <li>根据每个可见节点以及其对应的样式，组合生成渲染树</li></ol> <p>不可见的节点包括：</p> <ul><li>一些不会渲染输出的节点：如：script、link、meta 等</li> <li>一些通过 CSS 进行隐藏的节点：如：display:none;</li></ul> <p><strong>注意</strong>：利用 visible 和 opacity 隐藏节点，还是会显示在渲染树上的</p> <h2 id="九、版本控制相关"><a href="#九、版本控制相关" aria-hidden="true" class="header-anchor">#</a> 九、版本控制相关</h2> <h3 id="_1-git-merge-和-git-rebase-的区别？"><a href="#_1-git-merge-和-git-rebase-的区别？" aria-hidden="true" class="header-anchor">#</a> 1. git merge 和 git rebase 的区别？</h3> <p>git 的 merge 和 rebase 都是用来合并分支的</p> <ul><li><p>git merge：</p> <ol><li>记录下合并动作，很多时候这种合并动作是垃圾信息</li> <li>不会修改原 commit ID</li> <li>分支看着不大整洁（不是线性），但是能看出合并的先后顺序</li> <li>记录了真实的 commit 情况，包括每个分支的详情</li></ol> <p>git merge 的优势是它保留了分支的结构与历史提交目录，但同时这也导致了提交历史会被大量的 merge 污染</p></li> <li><p>git rebase：</p> <ol><li>得到更简洁的项目历史，分支线性</li> <li>修改所有 commit ID</li></ol> <p>rebase 合并往往又被称为 「变基」，它是将把所有的提交压缩成一个 patch 。然后把 patch 添加到目标分支里。rebase 与 merge 不同的是：rebase 通过为原始分支中的每个提交创建全新的 commits 来重写项目历史记录</p> <p>git rebase 的优势是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；rebase 会产生完美线性的项目历史记录，你可以在 feature 分支上没有任何分叉的情况下一直追寻到项目的初始提交。但是， rebase 会丢失合并提交的上下文， 使我们无法看到真实的更改是何时合并到目标分支上的</p></li> <li><p>建议：</p> <ol><li>本地开发：应该使用 rebasing 而不是 merging ，这样历史记录会很清晰</li> <li>你的代码准备好了被 review ：它会让 pull request 的可塑性更强，也能避免历史突然丢失</li> <li>review 已经完成并且已经准备好了合并到目标分支：使用 merge</li></ol></li></ul> <h3 id="_2-git-pull-和-git-fetch-的区别？"><a href="#_2-git-pull-和-git-fetch-的区别？" aria-hidden="true" class="header-anchor">#</a> 2. git pull 和 git fetch 的区别？</h3> <ul><li>git fetch 的意思是将远程主机的最新内容拉到本地，用户再检查无误后再决定是否合并到工作本地分支中</li> <li>git pull 是将远程主机中的最新内容拉取下来后直接合并，即：git pull = git fetch+git merge，这样可能会产生冲突，需要手动解决</li></ul> <h3 id="_3-说一下-git-发生冲突后如何解决？"><a href="#_3-说一下-git-发生冲突后如何解决？" aria-hidden="true" class="header-anchor">#</a> 3. 说一下 git 发生冲突后如何解决？</h3> <ul><li><p>一般情况下，出现冲突的场景有如下：</p> <ol><li>多个分支代码合并到一个分支时</li> <li>多个分支向同一个远端分支推送</li></ol> <p>git stash -&gt; git checkout xxx -&gt; git stash pop -&gt; 解决冲突 -&gt; commit</p></li></ul> <h3 id="_4-git-flow-工作流的理解？"><a href="#_4-git-flow-工作流的理解？" aria-hidden="true" class="header-anchor">#</a> 4. git flow 工作流的理解？</h3> <p>Git flow: 使用 git 要遵循的一套规范（称为分之管理模型），有助于项目开发和发布的有序、高效</p> <ul><li><p>分支分类：</p> <ol><li>主分支：master、develop</li> <li>辅助分支：feature、release、hotfix</li></ol></li> <li><p>git flow 优缺点：</p> <ol><li>优点：各个分支明确，便于开发、并行、追溯</li> <li>缺点：分支间切换次数过多，合并次数较多</li></ol></li></ul> <h2 id="十、安全相关"><a href="#十、安全相关" aria-hidden="true" class="header-anchor">#</a> 十、安全相关</h2> <h3 id="_1-csrf-和-xss-、ssrf-的攻击原理-与防御措施？"><a href="#_1-csrf-和-xss-、ssrf-的攻击原理-与防御措施？" aria-hidden="true" class="header-anchor">#</a> 1. CSRF 和 XSS 、SSRF 的攻击原理 与防御措施？</h3> <p>CSRF（Cross-site request forgery）：跨站请求伪造: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式</p> <ul><li>CSRF 的攻击原理</li></ul> <p><img src="http://img.smyhvae.com/20180307_1735.png" alt></p> <p>从上图可以看出，要完成一次 CSRF 攻击，受害者必须满足两个必要的条件：</p> <ol><li>登录受信任网站 A，并在本地生成 Cookie。（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录）</li> <li>在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）</li></ol> <p><strong>温馨提示一下</strong>：cookie 保证了用户可以处于登录状态，但网站 B 其实拿不到 cookie</p> <ul><li><p>CSRF 如何防御</p> <ol><li>方法一、Token 验证：（用的最多）
服务器发送给客户端一个 token；客户端提交的表单中带着这个 token。如果这个 token 不合法，那么服务器拒绝这个请求。</li> <li>方法二、隐藏令牌：
把 token 隐藏在 http 的 head 头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</li> <li>方法三、Referer 验证：
Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</li></ol></li></ul> <p>XSS（Cross Site Scripting）：跨域脚本攻击: 是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式</p> <ul><li><p>XSS 的攻击原理
XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、html 代码块等）。导致：盗用 Cookie、破坏页面的正常结构，插入广告等恶意内容、D-doss 攻击</p></li> <li><p>XSS 的攻击方式</p> <ol><li>反射型
发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS</li> <li>存储型
存储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交 XSS 代码</li></ol></li> <li><p>XSS 的防范措施（encode + 过滤）</p> <ol><li>方法一、编码
对用户输入的数据进行 HTML Entity 编码;把字符转换成 转义字符</li> <li>方法二、过滤
移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言之，过滤掉一些不安全的内容）
移除用户输入的 Style 节点、Script 节点、Iframe 节点。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）</li> <li>方法三、校正
避免直接对 HTML Entity 进行解码;使用 DOM Parse 转换，校正不配对的 DOM 标签</li></ol></li> <li><p>CSRF 和 XSS 的区别:</p> <ol><li>CSRF：需要用户先登录网站 A，获取 cookie;XSS：不需要登录</li> <li>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api;XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容</li></ol></li> <li><p>SSRF</p></li></ul> <p><strong>扩展</strong>：v-html 的弊端？（利用 innerHTML）</p> <ol><li>可能会导致 xss 攻击</li> <li>v-html 会替换掉标签内部的子元素</li></ol> <h3 id="_2-知道第三方-cookie-吗？"><a href="#_2-知道第三方-cookie-吗？" aria-hidden="true" class="header-anchor">#</a> 2. 知道第三方 Cookie 吗？</h3> <ul><li><p>cookie 由哪些部分组成：</p> <ol><li>Name: 这个属性就表示 cookie 的名字，每个 cookie 的名字都是唯一的</li> <li>Value: 这个属性表示 cookie 的值</li> <li>Domain: 就是 cookie 所在的域名，如果没有设置 domain 的话，那么 cookie 会自动绑定到执行语句的当前域</li> <li>Path: 这个属性的默认值是/，匹配的是路由，这里匹配的是路由的意思就是比如你的域名是 www.xxx.xyz,那么路由如果是 www.xxx.xyz/auth/,那么实际上 cookie 绑定的是这个/auth</li> <li>Max-age: 这个属性是 http1.1 新增的属性，用来替代 expires 的，单位是秒，用来表示 cookie 在多少秒之后会失效</li> <li>Secure: 因为 http 是无状态协议，而且 http 在传输数据的过程中是以明文传输的，因此很容易遭到第三方网站的窃取，如果我们使用 secure 的话，就能够确保 cookie 是在 https 协议下进行传输的，但是这不代表会将 cookie 加密</li> <li>HttpOnly: 这个属性表示不能够被 js 脚本访问，因为 js 能够通过 document.cookie 来获取 cookie，所以使用 HttpOnly 就能够阻止这种情况，在一定程度上防止 xss 攻击，也就是跨站脚本攻击</li> <li>SameSite: 用于限制第三方网站的 cookie 发送机制(cookie 每次随着请求会自动发送到服务器去的，这就给了其他站点发起 CSRF 攻击和用户追踪的机会)
<strong>具体如下</strong>：
<ol><li>Strict: 最严格的模式，完全禁止跨站点请求时携带 cookie，设置为 strict 之后，跨站行为都不会再携带 cookie</li> <li>Lax: 相对 strict 模式会宽松一点儿，允许导航到三方网站时携带 cookie，即 a 标签跳转，form 表单的 get 提交，以及 link 标签的 prerender</li> <li>None: 使用 None 显示的关闭 SameSite 模式控制，但是需要注意的是还需要加上 secure，即 cookie 只会在 HTTPS 中发送，如果只是设置了 SameSite=None 是没有效果的</li></ol></li></ol></li> <li><p>cookie 的分类：
第一方 Cookie 和第三方 Cookie，这两类 Cookie 都是网站保存在用户电脑上的一个文件，它们都由某个特定的域创建，并且只能被这个域访问</p> <p>第一方 Cookie 是由地址栏中列出的网站域设置的 Cookie，而第三方 Cookie 来自在网页上嵌入广告或图片等项的其他域来源。都是网站在客户端上存放的一小块数据。他们都由某个域存放，只能被这个域访问。他们的区别其实并不是<strong>技术上</strong>的区别，而是<strong>使用方式上</strong>的区别。</p></li></ul> <h2 id="十一、手写题"><a href="#十一、手写题" aria-hidden="true" class="header-anchor">#</a> 十一、手写题</h2> <h3 id="_1-bind、call、apply-的实现原理？"><a href="#_1-bind、call、apply-的实现原理？" aria-hidden="true" class="header-anchor">#</a> 1. bind、call、apply 的实现原理？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">与apply唯一不同的是，call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法接受的是一个参数列表
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Type Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span>
  context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

第一个参数是绑定的<span class="token keyword">this</span>，默认为window，第二个参数是数组或类数组
<span class="token comment">// Function.prototype.apply = function(context = window, args) {</span>
<span class="token comment">//   if(typeof this !== 'function') {</span>
<span class="token comment">//     throw new TypeError('Type Error')</span>
<span class="token comment">//   }</span>
<span class="token comment">//   const fn = Symbol('fn')</span>
<span class="token comment">//   context[fn] = this</span>

<span class="token comment">//   const res = context[fn](...args)</span>
<span class="token comment">//   delete context[fn]</span>
<span class="token comment">//   return res</span>
<span class="token comment">// }</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">apply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Type Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> res
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span>
  context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>


<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Type Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 保存this</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 考虑new的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">self</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-能否手写一个-new？"><a href="#_2-能否手写一个-new？" aria-hidden="true" class="header-anchor">#</a> 2. 能否手写一个 new？</h3> <ul><li><p>实现 new 操作符的步骤：</p> <ol><li>函数接受一个不定量的参数，第一个参数为构造函数，剩余的参数被构造函数使用</li> <li>内部创建一个空对象 obj</li> <li>因为 obj 对象需要访问到构造函数原型链上的属性，所有通过 setPrototype 将两者关联起来</li> <li>将 obj 绑定到构造函数上，并传入剩余参数</li> <li>判断构造函数返回值是否是对象，如果为对象就是要构造函数返回的值，否则返回 obj</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createNew</span><span class="token punctuation">(</span><span class="token parameter">Con<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Con <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Type Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">setPrototype</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token class-name">Con</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 等价于obj.__proto__ = Con.prototype</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Con</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意</strong>：当 new Object()不传参数时，字面量{}和 new 关键字创建的对象是 Object 的实例一样的；Object.create()传两个参数，第一个为新创建对象的原型对象，第二个为自身定义的属性;为 null，新对象是空对象，没有原型，不继承任何对象；arg 为指定对象，新对象的原型指向指定对象，继承指定对象</p></li></ul> <h3 id="_3-实现一个-instanceof？"><a href="#_3-实现一个-instanceof？" aria-hidden="true" class="header-anchor">#</a> 3. 实现一个 instanceof？</h3> <p>instanceof 用来检测一个对象在其原型链中是否存在一个构造函数的 prototype 属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> proto <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    proto <span class="token operator">=</span> proto<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 等价于proto = Object.getPrototypeOf(proto)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-实现一个-发布订阅-eventemitter？"><a href="#_4-实现一个-发布订阅-eventemitter？" aria-hidden="true" class="header-anchor">#</a> 4. 实现一个 发布订阅 EventEmitter？</h3> <p>发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。EventEmitter 的一个实例就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的 emit 方法发布事件，而订阅者则通过 on 进行订阅。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listeners <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 存储所有事件的监听器</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * 注册事件监听者
   * @param {*} type 事件类型
   * @param {*} cb 回调函数
   */</span>
  <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * 发布事件
   * @param {*} type 事件类型
   * @param  {...any} args 参数列表，把emit传递的参数赋给回调函数
   */</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">cb</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * 移除某个事件的一个监听者
   * @param {*} type 事件类型
   * @param {*} cb 回调函数
   */</span>
  <span class="token function">off</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> targetIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> cb<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>targetIndex <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>targetIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">offAll</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>特点</strong>: 发布订阅模式中，对于发布者 Publisher 和订阅者 Subscriber 没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件.松散耦合，灵活度高，常用作事件总线
<strong>缺点</strong>: 当事件类型越来越多时，难以维护，需要考虑事件命名的规范</p> <ul><li>观察者模式
角色很明确，没有事件调度中心作为中间者，目标对象 Subject 和观察者 Observer 都要实现约定的成员方法。双方联系更紧密，目标对象的主动性很强，自己收集和维护观察者，并在状态变化时主动通知观察者更新。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> cb <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Observer构造器必须传入函数类型！'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 被观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>observerList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 维护观察者列表</span>
  <span class="token punctuation">}</span>
  <span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>observerList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>observerList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-数组去重的方式？"><a href="#_5-数组去重的方式？" aria-hidden="true" class="header-anchor">#</a> 5. 数组去重的方式？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token comment">// =&gt; [1, '1', 17, true, false, 'true', 'a', {}, {}]</span>
</code></pre></div><ul><li>方式一、利用 Set</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方式二、利用 indexOf</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">unique</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// if(!res.includes(arr[i])) {</span>
    <span class="token comment">//   res.push(arr[i])</span>
    <span class="token comment">// }</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">unique</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然也可以用 include、filter，思路大同小异</p> <ul><li>方式三、两层 for 循环 + splice</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">unique</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">// 每删除一个树，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能</span>
        len<span class="token operator">--</span>
        j<span class="token operator">--</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><ul><li>方式四、利用 Map</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">unique</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    para
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_6-解析-url-参数？"><a href="#_6-解析-url-参数？" aria-hidden="true" class="header-anchor">#</a> 6. 解析 URL 参数？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parseParam</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> paramsStr <span class="token operator">=</span> <span class="token regex">/.+\?(.+)$/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 将?后面的字符串取出来</span>
  <span class="token keyword">const</span> paramsArr <span class="token operator">=</span> paramsStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span> <span class="token comment">// 将字符串以&amp;分割后存到数组里</span>
  <span class="token keyword">let</span> paramsObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 将params存到对象中</span>
  paramsArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/=/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 处理有value的参数</span>
      <span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span> <span class="token comment">// 分割key和value</span>
      val <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// 解码</span>
      val <span class="token operator">=</span> <span class="token regex">/^\d+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">:</span> val <span class="token comment">// 判断是否转为数字</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>paramsObj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果对象有key，则添加一个值</span>
        paramsObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>paramsObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果对象没有这个key，创建key并设置值</span>
        paramsObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 处理没有value的参数</span>
      paramsObj<span class="token punctuation">[</span>param<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> paramsObj
<span class="token punctuation">}</span>

<span class="token comment">// 创建一个URLSearchParams实例</span>
<span class="token keyword">const</span> urlSearchParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span>
<span class="token comment">// 把键值对列表转换为一个对象</span>
<span class="token keyword">const</span> params <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>urlSearchParams<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_7-版本比较？"><a href="#_7-版本比较？" aria-hidden="true" class="header-anchor">#</a> 7. 版本比较？</h3> <p>如果 version1 &gt; version2 返回 1， 如果 version1 &lt; version2 返回 -1， 除此之外返回 0</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">compileVersion</span><span class="token punctuation">(</span><span class="token parameter">version1<span class="token punctuation">,</span> version2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将两个版本号切割成由修订号组成的数组</span>
  <span class="token keyword">const</span> arr1 <span class="token operator">=</span> version1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> arr2 <span class="token operator">=</span> version2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
  <span class="token comment">// 比较数组长度，得到最大的数组长度</span>
  <span class="token keyword">const</span> maxLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span>length<span class="token punctuation">,</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span>

  <span class="token comment">// 遍历数组，分别比较同一个位置上的版本号</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从左到右依次比较版本号</span>
    <span class="token keyword">const</span> a <span class="token operator">=</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
    <span class="token keyword">const</span> b <span class="token operator">=</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
    <span class="token comment">// 忽略前导0，使用Number()转为数字</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 对比结束的时候就返回0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> maxLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">compileVersion</span><span class="token punctuation">(</span><span class="token string">'0.1'</span><span class="token punctuation">,</span> <span class="token string">'1.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_8-手写-防抖-和-节流？"><a href="#_8-手写-防抖-和-节流？" aria-hidden="true" class="header-anchor">#</a> 8. 手写 防抖 和 节流？</h3> <ul><li>debounce 防抖：触发高频时间后 n 秒内函数只会执行一次,如果 n 秒内高频时间再次触发,则重新计算时间（按最后一次算。比如说“停止输入 5s 后才发送请求”）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>防抖常应用于用户进行搜索输入节约请求资源，window 触发 resize 事件时进行防抖只触发一次</p> <ul><li>throttle 节流：高频时间触发,但 n 秒内只会执行一次,所以节流会稀释函数的执行频率（在 n 秒内只会执行一次，所以节流会稀释函数的执行频率）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>
    flag <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
      flag <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>节流常应用于鼠标不断点击触发、监听滚动事件</p> <h3 id="_9-你知道判断数组的几种方式？"><a href="#_9-你知道判断数组的几种方式？" aria-hidden="true" class="header-anchor">#</a> 9. 你知道判断数组的几种方式？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 通过原型链判断</span>
  <span class="token comment">// return arr.__proto__ === Array.prototype;</span>
  <span class="token comment">// 2. 通过 ES6 中 Array.isArray()判断</span>
  <span class="token comment">// return Array.isArray(arr);</span>
  <span class="token comment">// 3. 通过 instanceof 判断</span>
  <span class="token comment">// return arr instanceof Array;</span>
  <span class="token comment">// 4. 通过 Array.prototype.isPrototypeOf() 判断</span>
  <span class="token comment">// return Array.prototype.isPrototypeOf(arr);</span>
  <span class="token comment">// 5. 通过 Object.prototype.toString.call() 判断</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'Array'</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>扩展</strong>：isPrototypeOf 和 instanceof 的区别？</p> <ol><li>isPrototypeOf 表示对象是否在另一个对象的原型链上</li> <li>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</li></ol> <h3 id="_10-使用-reduce-实现-map"><a href="#_10-使用-reduce-实现-map" aria-hidden="true" class="header-anchor">#</a> 10. 使用 reduce 实现 map?</h3> <p>用数组的 reduce 方法实现 map 方法</p> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">previousValue<span class="token punctuation">,</span> currentValue<span class="token punctuation">,</span> currentIndex<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
initialValue<span class="token punctuation">)</span>
</code></pre></div><p>reduce 接受两个参数，第一个参数，指定了每次迭代调用的函数，函数的返回值为下一次迭代的 previousValue。第二个参数为初始值，是可选的。</p> <ol><li>若没有指定初始值，那么第一次的 previousValue 为 arr[0], currentValue 为 arr[1], currentIndex 为 1</li> <li>若指定初始值，那么第一次的 previousValue 为 initialValue, currentValue 为 arr[0], currentIndex 为 0</li> <li>第二个参数为 thisArg，可选的，表示执行函数时的 this
<strong>注意</strong>：如果 callback 为箭头函数时，里面的 this 执行外层代码块（非严格模式下为 window），此时指定的 thisArg 无效</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">MCmap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> thisArg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">MCmap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> item <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>
</code></pre></div><h3 id="_11-手写数据类型判断"><a href="#_11-手写数据类型判断" aria-hidden="true" class="header-anchor">#</a> 11. 手写数据类型判断?</h3> <div class="language-diff extra-class"><pre class="language-diff"><code>function typeOf(obj) {
  let res = Object.prototype.toString.call(obj).split(' ')[1]
  res = res.substring(0, res.length - 1).toLowerCase()
  return res
  // 更好的写法
  // return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}
typeOf([])        // 'array'
typeOf({})        // 'object'
typeOf(new Date)  // 'date'
</code></pre></div><h3 id="_12-手写继承"><a href="#_12-手写继承" aria-hidden="true" class="header-anchor">#</a> 12. 手写继承?</h3> <ul><li>原型链继承</li> <li>借用构造函数实现继承</li> <li>组合继承</li> <li>寄生式继承</li> <li>class 实现继承</li></ul> <h3 id="_13-偏函数-compose-柯里化？"><a href="#_13-偏函数-compose-柯里化？" aria-hidden="true" class="header-anchor">#</a> 13. 偏函数 &amp; compose &amp; 柯里化？</h3> <h3 id="_14-能实现一个-jsonp-吗？"><a href="#_14-能实现一个-jsonp-吗？" aria-hidden="true" class="header-anchor">#</a> 14. 能实现一个 JSONP 吗？</h3> <p>script 标签不遵循同源协议，可以用来进行跨域请求，优点就是兼容性好但仅限于 GET 请求</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">jsonp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">generateUrl</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dataSrc <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnPrototype</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dataSrc <span class="token operator">+=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;`</span></span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    dataSrc <span class="token operator">+=</span> <span class="token template-string"><span class="token string">`callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dataSrc<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> scriptEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
    scriptEle<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token function">generatorUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span>
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
      document<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_15-实现一下原生的-ajax？"><a href="#_15-实现一下原生的-ajax？" aria-hidden="true" class="header-anchor">#</a> 15. 实现一下原生的 AJAX？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">getJson</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> xhr <span class="token operator">=</span> XMLHttpRequest
      <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">'Microsoft.XMLHttp'</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_16-实现数组原型方法？"><a href="#_16-实现数组原型方法？" aria-hidden="true" class="header-anchor">#</a> 16. 实现数组原型方法？</h3> <ul><li><p>forEach</p></li> <li><p>map
用数组的 reduce 方法实现 map 方法</p> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">previousValue<span class="token punctuation">,</span> currentValue<span class="token punctuation">,</span> currentIndex<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
initialValue<span class="token punctuation">)</span>
</code></pre></div><p>reduce 接受两个参数，第一个参数，指定了每次迭代调用的函数，函数的返回值为下一次迭代的 previousValue。第二个参数为初始值，是可选的。</p> <ol><li>若没有指定初始值，那么第一次的 previousValue 为 arr[0], currentValue 为 arr[1], currentIndex 为 1</li> <li>若指定初始值，那么第一次的 previousValue 为 initialValue, currentValue 为 arr[0], currentIndex 为 0</li> <li>第二个参数为 thisArg，可选的，表示执行函数时的 this
<strong>注意</strong>：如果 callback 为箭头函数时，里面的 this 执行外层代码块（非严格模式下为 window），此时指定的 thisArg 无效</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">MCmap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> thisArg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">MCmap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> item <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>filter</p></li> <li><p>some</p></li> <li><p>reduce</p></li></ul> <h3 id="_17-实现-object-create-object-assign？"><a href="#_17-实现-object-create-object-assign？" aria-hidden="true" class="header-anchor">#</a> 17. 实现 Object.create &amp; Object.assign？</h3> <h3 id="_18-手写-promise？"><a href="#_18-手写-promise？" aria-hidden="true" class="header-anchor">#</a> 18. 手写 Promise？</h3> <ul><li><p>isPromise</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPromise</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>resolve</p></li> <li><p>reject</p></li> <li><p>all
返回一个 promise 对象，只有当所有 promise 都成功时返回的 promise 状态才成功</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'promises must be a array'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 存放结果</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 记录有几个resolved</span>

    <span class="token keyword">function</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> current <span class="token operator">=</span> promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPromise</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        current<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">processData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">processData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> current<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>缺陷</strong>：在并发请求中，只有有一个请求错误，promise 的状态就是 reject</p></li> <li><p>race</p></li> <li><p>allSettled
Promise.all 需要所有 promise 都成功时才 resolve 或者有一个失败时即 reject，Promise.allSettled 只关心所有 promise 是不是都被 settle 了，不管其是 rejected 状态的 promise，还是非 rejected 状态(即 fulfilled)的 promise, 我都可以拿到它的最终状态并对其进行处理</p> <ul><li>Promise.allSettled 的结果数组中可能包含以下两种格式的数据
<ol><li>{status:&quot;fulfilled&quot;, value:result} 对于成功的响应</li> <li>{status:&quot;rejected&quot;, reason:error} 对于 error</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 存放运行的结果</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 调用的次数和传入的参数个数一直的时候，resolve</span>
    <span class="token keyword">function</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>index <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> current <span class="token operator">=</span> promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPromise</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        current<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
          <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
              status<span class="token punctuation">:</span> <span class="token string">'fulfilled'</span><span class="token punctuation">,</span>
              value<span class="token punctuation">:</span> data<span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
            <span class="token function">processData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
              status<span class="token punctuation">:</span> <span class="token string">'rejected'</span><span class="token punctuation">,</span>
              value<span class="token punctuation">:</span> err<span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
            <span class="token function">processData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
          status<span class="token punctuation">:</span> <span class="token string">'fulfilled'</span><span class="token punctuation">,</span>
          value<span class="token punctuation">:</span> current<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token function">processData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> current<span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>any</p></li></ul> <p>https://juejin.cn/post/6946022649768181774#heading-38</p> <h3 id="_19-排序？"><a href="#_19-排序？" aria-hidden="true" class="header-anchor">#</a> 19. 排序？</h3> <ul><li>冒泡排序<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div></li> <li>选择排序</li> <li>插入排序</li> <li>快速排序</li> <li>归并排序</li> <li>希尔排序</li></ul> <h3 id="_20-类数组转化为数组的方法？"><a href="#_20-类数组转化为数组的方法？" aria-hidden="true" class="header-anchor">#</a> 20. 类数组转化为数组的方法？</h3> <p>类数组是具有 length 属性，但不具有数组原型上的方法。常见的类数组有 arguments、DOM 操作方法返回的结果。</p> <ul><li>方式一、Array.from()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方式二、Array.prototype.slice.call()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方式三、扩展运算符</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token operator">...</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><ul><li>方式四、利用 concat()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_21-列表转成树形结构-树形结构转成列表？"><a href="#_21-列表转成树形结构-树形结构转成列表？" aria-hidden="true" class="header-anchor">#</a> 21. 列表转成树形结构 &amp; 树形结构转成列表？</h3> <h3 id="_22-大数相加？"><a href="#_22-大数相加？" aria-hidden="true" class="header-anchor">#</a> 22. 大数相加？</h3> <h3 id="_23-数组扁平化？"><a href="#_23-数组扁平化？" aria-hidden="true" class="header-anchor">#</a> 23. 数组扁平化？</h3> <p>数组扁平化是指将一个多维数组变为一个一维数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>
<span class="token comment">// =&gt; [1, 2, 3, 4, 5, 6]</span>
</code></pre></div><ul><li>方法一、使用 flat()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方法二、使用正则</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\[|\]/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token function">数据类型都会变为字符串</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token function">正则改良版本</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'['</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\[|\]/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方法三、使用 reduce</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">:</span> cur<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
</code></pre></div><ul><li>方式四、函数递归</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
</code></pre></div><ul><li>方式五、toString</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token comment">// 有缺陷，toString 后无法保持之前的类型</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>方式六、rest 运算符</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// concat方法本身就会把参数中的数组展开，相当于[].concat('1', 2, [3, 4])</span>
    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_24-算法-全排列？"><a href="#_24-算法-全排列？" aria-hidden="true" class="header-anchor">#</a> 24. 算法 -&gt; 全排列？</h3> <p>给定一个字符串，输出该字符串所有排列的可能。如输入“abc”，输出“abc,acb,bca,bac,cab,cba”。</p> <ul><li>思路：定义一个数组存放全排列的情况并返回。判断输入的字符串是否为单个字符串的情况。是，返回其本身。不是，则遍历字符串中的每一个元素，并将字符串中除了该元素的其他元素及你想全排列</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fullPermutation</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> left <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// 当前元素</span>
      <span class="token comment">// 除了当前元素的其他元素组合</span>
      <span class="token keyword">var</span> rest <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
      <span class="token comment">// 上一次递归返回的全排列</span>
      <span class="token keyword">var</span> preResult <span class="token operator">=</span> <span class="token function">fullPermutation</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span>
      <span class="token comment">// 结合在一起</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> preResult<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> temp <span class="token operator">=</span> left <span class="token operator">+</span> preResult<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_25-算法-二分查找？"><a href="#_25-算法-二分查找？" aria-hidden="true" class="header-anchor">#</a> 25. 算法 -&gt; 二分查找？</h3> <p>二分搜索法，也称折半搜索，是一种在<strong>有序数组</strong>中查找特定元素的搜索算法。</p> <ul><li>实现步骤：
<ol><li>首先从数组中间开始查找对比，若相等则找到，直接返回中间元素的索引</li> <li>若查找值小于中间值，则在小于中间值的那一部分执行步骤 1 的操作</li> <li>若查找值大于中间值，则在大于中间值的那一部分执行步骤 1 的操作</li> <li>否则，返回结果为查不到，返回-1</li></ol></li> <li>实现方法：
<ol><li>非递归方式，采用 while 方式，判断是否符合要求</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {*} arr 已排好的数组
 * @param {*} key 想要查找的值
 */</span>
<span class="token keyword">function</span> <span class="token function">binary_search1</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    high <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// var mid = parseInt((low + high) / 2); // 得到中间的数</span>
    <span class="token keyword">var</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 得到中间的数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> mid
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明在右边</span>
      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明在左边</span>
      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>递归方式，采用 if 方式，依次递归，找到相应的值</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">binary_search2</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">/**
   * @param {*} arr 已排好的数组
   * @param {*} key 想要查找的值
   * @param {*} low 第一个值的索引
   * @param {*} high 最后一个值的索引
   * @returns
   */</span>
  <span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> key<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&gt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> mid
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明在右边</span>
      <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 说明在左边</span>
      <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> key<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><strong>时间复杂度</strong>：O(log2n) =&gt; O(logn).<strong>优点</strong>：比较次数少，查找速度快，平均性能好。<strong>缺点</strong>：要求待查表为有序表，且插入删除困难。<strong>结论</strong>：适用于不经常变动而查找频繁的有序列表。</li></ul> <h2 id="十二、性能优化"><a href="#十二、性能优化" aria-hidden="true" class="header-anchor">#</a> 十二、性能优化</h2> <h3 id="_1-vue-项目优化方式有哪些？"><a href="#_1-vue-项目优化方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 1. Vue 项目优化方式有哪些？</h3> <ul><li><p>使用计算属性
特点：可以被缓存</p></li> <li><p>使用函数式组件
例如：对于某些组件，如果我们只是用来显示一些数据，不需要管理状态，监听数据等，那么就可以用函数式组件。</p> <p>函数式组件是无状态的，无实例的，在初始化时不需要初始化状态，不需要创建实例，也不需要去处理生命周期等，相比有状态组件，会更加轻量，同时性能也更好。</p></li> <li><p>结合场景使用 v-show 和 v-if
两者的作用都是用来控制某些组件或 DOM 的显示/隐藏</p> <p>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景</p> <p>v-show 适用于需要非常频繁切换条件的场景</p> <ol><li>v-if 的部分被转换成了一个三元表达式,visible 为 true 时，创建组件的 vnode，否则创建一个空 vnode。在 patch 的时候，新旧节点不一样，就会移除旧的节点或创建新的节点，这样的话组件也会跟着创建/销毁。如果组件里有很多 DOM，或者要执行很多初始化/销毁逻辑，那么随着 visible 的切换，势必会浪费掉很多性能</li> <li>v-show 被编译成了 directives，它其实是通过切换元素的 display 属性来控制的，和 v-if 相比，不需要在 patch 阶段创建/移除节点，只是根据 v-show 上绑定的值来控制 DOM 元素的 style.display 属性，在频繁切换的场景下就可以节省很多性能</li></ol> <p>如果初始值是 false 时，v-if 并不会创建隐藏的节点，但是 v-show 会创建，并通过设置 style.display='none'来隐藏，虽然外表看上去这个 DOM 都是被隐藏的，但是 v-show 已经完整的走了一遍创建的流程，造成了性能的浪费
<strong>总结</strong>：v-if 的优势体现在初始化时，v-show 体现在更新时（初始化性能压力大）
<strong>扩展补充</strong>：display:none、visibility:hidden 和 opacity:0 之间的区别？</p> <ul><li><p>相同点：都是隐藏</p></li> <li><p>不同点：</p> <ol><li>是否占据空间
<ul><li>display: none, 隐藏之后不占据空间</li> <li>visibility: hidden、opacity: 0;隐藏后任然占据空间</li></ul></li> <li>子元素是否继承
<ul><li>display: none, 不会被子元素继承，父元素都不存在了，紫云山也不会显示</li> <li>visibility: hidden, 会被子元素继承，通过设置子元素,visibility: visible 来显示子元素</li> <li>opacity: 0, 会被子元素继承，但是不能设置子元素 opacity 来重新显示</li></ul></li> <li>事件绑定
<ul><li>display: none, 元素都不在了，所以无法触发它绑定的事件</li> <li>visibility: hidden, 不会触发它上面绑定的事件</li> <li>opacity: 0, 元素上面绑定的事件是可以触发的</li></ul></li> <li>过渡动画
<ul><li>transition: 对于 display 是无效的</li> <li>transition: 对于 visibility 是无效的</li> <li>transition: 对于 opacity 是有效的</li></ul></li></ol></li></ul></li> <li><p>使用 keep-alive
keep-alive 的作用就是将它包裹的组件在第一次渲染后就缓存起来，下次需要时就直接从缓存里面取，避免了不必要的性能浪费</p></li> <li><p>避免 v-for 和 v-if 同时使用
Vue2 中，v-for 的优先级比 v-if 高；Vue3 中，v-if 的优先级比 v-for 高
<strong>总结</strong>：使用计算属性代替</p></li> <li><p>给 v-for 添加 key, 并且不要将 index 作为 key</p></li> <li><p>延迟渲染
延迟渲染就是分批渲染，假设我们某个页面里有一些组件在初始化时需要执行复杂的逻辑，这将会占用很长时间，导致帧数下降、卡顿，其实可以使用分批渲染的方式来进行优化，就是先渲染一部分，再渲染另一部分</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Heavy v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;defer(1)&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      displayPriority<span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runDisplayPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">runDisplayPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token function-variable function">step</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>displayPriority<span class="token operator">++</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>displayPriority <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">defer</span><span class="token punctuation">(</span><span class="token parameter">priority</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>displayPriority <span class="token operator">&gt;=</span> priority
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p><strong>原理</strong>：主要是维护 displayPriority 变量，通过 requestAnimationFrame 在每一帧渲染时自增，然后我们就可以在组件上通过 v-if=&quot;defer(n)&quot;使 displayPriority 增加到某一值时再渲染，这样就可以避免 js 执行时间过长导致的卡顿问题了</p></li> <li><p>使用非响应式数据
在 Vue 组件初始化数据时，会递归遍历在 data 中定义的每一条数据，通过 Object.defineProperty 将数据改成响应式，这就意味着如果 data 中的数据量很大的话，在初始化时将会使用很长的时间去执行 Object.defineProperty,也就会带来性能问题，这个时候我们可以强制使数据变为非响应式，从而节省时间</p> <p><strong>解决</strong>：Object.freeze()
<strong>扩展</strong>：为什么 Object.freeze()会有这样的效果呢？
对某一对象使用 Object.freeze()后，将不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值</p> <p>而 Vue 在将数据改造成响应式之前有个判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> asRootData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略其他逻辑</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    shouldObserve <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...省略其他逻辑</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个判断条件中有一个 Object.isExtensible(value)，这个方法是判断一个对象是否是可扩展的，由于我们使用了 Object.freeze()，这里肯定就返回了 false，所以就跳过了下面数据劫持的过程，没有了收集依赖的过程，自然也就节省了性能。</p> <p><strong>问题</strong>：数据都不是响应式的，可以只对这种数据的某一层使用 Object.freeze()，同时配合使用上文中的延迟渲染、函数式组件等，可以极大提升性能。</p> <p>Vue2/3 Template Explorer</p></li> <li><p>computed、watch、methods 区分使用场景</p> <ol><li>computed: 一个数据受多个数据影响的。</li> <li>watch: 一个数据影响多个数据的。当数据变化时，需要执行异步或开销较大的操作时。如果数据变化时请求一个接口。</li> <li>methods: 希望数据是实时更新，不需要缓存。</li></ol></li> <li><p>防抖和节流</p> <ol><li>防抖：触发事件后规定时间内事件只会执行一次。简单来说就是防止手抖，短时间操作了好多次。</li> <li>节流：事件在规定时间内只执行一次。</li> <li>应用场景： 节流不管事件有没有触发还是频繁触发，在规定时间内一定会只执行一次事件，而防抖是在规定时间内事件被触发，且是最后一次被触发才执行一次事件。</li></ol></li> <li><p>图片大小优化和懒加载</p> <ol><li>图片大小的优化，可以用 image-webpack-loader 进行压缩图片</li> <li>图片懒加载，可以用 vue-lazyload 插件实现</li></ol></li> <li><p>利用挂载节点会被替换的特性优化白屏问题
我们可以在<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>里添加首屏的静态页面。等真正的首屏加载出来后就会把<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这块结构都替换掉，给人一种视觉上的误差，就不会产生白屏</p></li> <li><p>组件库按需引入
如 element UI 库，用 babel-plugin-component 插件实现按需引入</p> <p>在根目录下.babelrc.js 文件中按如下配置：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token punctuation">{</span>
    <span class="token string">&quot;presets&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;es2015&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">&quot;modules&quot;</span><span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string">&quot;plugins&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">[</span>
        <span class="token string">&quot;component&quot;</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token string">&quot;libraryName&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;element-ui&quot;</span><span class="token punctuation">,</span>
          <span class="token string">&quot;styleLibraryName&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;theme-chalk&quot;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>其中 libraryName 为组件库的名称，styleLibraryName 为组件库打包后样式存放的文件夹名称。</p> <p><strong>问题</strong>：babel-plugin-component 是如何做到按需加载的？</p> <p>其实 babel-plugin-component 插件是 element 用 babel-plugin-import 插件改造后特定给 element UI 使用。一般的组件库还是 babel-plugin-import 插件实现按需引入。</p></li> <li><p>打包优化：</p> <ol><li><p>webpack-bundle-analyzer 可以帮助你可视化的分析打包后的各个资源的大小</p></li> <li><p>利用 import()异步引入组件实现按需引入
路由懒加载，所谓的懒加载就是用 import()异步引入组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">component</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'views/home.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token function-variable function">component</span><span class="token punctuation">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'views/home.vue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
</code></pre></div><p>resolve 方式打包会把所有组件的代码都打包在一个 js 文件。预期应该是每个组件的代码都被打包成对应的 js 文件，加载组件时会对应加载 js 文件，这才是懒加载。</p> <ul><li>可以使用 webpackChunkName: chunk 文件的名称， [request]表示实际解析的文件名</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;[request]&quot; */</span> <span class="token template-string"><span class="token string">`views/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>component<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>使用懒加载后，浏览器的 network 就会出现 Purpose: prefetch，只是预取（prefetch）一下，没有返回内容的。目的是告诉浏览器，空闲的时候给我加载这个 js 文件。直到真正加载这个路由组件时，这个 js 文件再次被加载</li></ul> <p><strong>扩展</strong>：prelink 和 prefetch 的区别
preload、prefetch 去提前加载，还可以使用 DNS Prefetch、Prerender、Preconnect</p></li> <li><p>利用 externals 提取第三方依赖并用 CDN 引入
在 Webpack 中的 externals 配置选项，可避免将第三方依赖打包，而是在项目运行时从外部获取第三方依赖。</p></li> <li><p>利用 SplitChunks 插件提取公共 js 代码和分割 js 代码</p></li> <li><p>压缩图片、HTML、CSS、JS 等静态资源</p></li></ol></li> <li><p>项目部署的优化</p> <ol><li><p>识别 gzip 压缩是否开启
只要看响应头部（Response headers）中 有没有 Content-Encoding: gzip 这个属性即可，有代表有开启 gzip 压缩。</p></li> <li><p>在 Nginx 上开启 gzip 压缩
在 nginx/conf/nginx.conf 中配置</p> <div class="language-sh extra-class"><pre class="language-text"><code>http {
   // on | off ，默认为off，on为开启gzip，off为关闭gzip
   gzip  on;
   // number，压缩起点，文件大于多少才进行压缩，单位默认为字节，也可用k表示千字节
   gzip_min_length 1k;
   // 压缩级别，1-9，数字越大，压缩后的大小越小，也越占用CPU，花费时间越长
   gzip_comp_level 5;
   // 需要进行压缩的文件类型。类型去Response headers中看Content-Type属性
   gzip_types application/javascript image/png image/gif image/jpeg text/css text/plain;
   // number size，设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流(例如 4 4k代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。如原始数据大小为17K，则申请 （17/4）*4 = 17k内存)
   gzip_buffers 4 4k;
   // 设置gzip压缩针对的HTTP协议版本以上
   gzip_http_version 1.1;
   // on | off，是否在http header中添加Vary:Accept-Encoding，on表示添加。Vary:Accept-Encoding告诉代理服务器缓存两种版本的资源：压缩和非压缩，避免一个浏览器不支持压缩资源，而先请求了服务器，服务器缓存了非压缩的资源，然后一个浏览器支持压缩资源，再去请求了服务器，结果得到非压缩资源，但是又去解压它，结果会出错。所以建议设置为on
   gzip_vary on;
}
</code></pre></div></li> <li><p>在 Webpack 上开启 gzip 压缩
利用 CompressionWebpack 插件来实现 gzip 压缩</p> <ul><li>CompressionWebpack 参数详解：
<ol><li>test：String|RegExp|Array&lt;String|RegExp&gt;，资源的名称符合条件的才会被压缩，默认为 undefined，即全部符合，例如只要压缩 js 文件</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
     <span class="token keyword">new</span> <span class="token class-name">CompressionPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
         test<span class="token punctuation">:</span> <span class="token regex">/\.js(\?.*)?$/i</span><span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><ol start="2"><li>include：String|RegExp|Array&lt;String|RegExp&gt;，资源的名称符合条件的才会被压缩，默认为 undefined，是在 test 参数的范围内在进行筛选，满足 test 参数的条件，且满足 include 参数的条件的资源才会被压缩</li> <li>exclude：String|RegExp|Array&lt;String|RegExp&gt;，压缩时排除资源的名称符合条件的资源，默认为 undefined，是在 test 参数的范围内在进行排除，满足 test 参数的条件，不满足 exclude 参数的条件的资源才会被压缩</li> <li>algorithm：压缩算法/功能，默认 gzip，一般不做更改</li> <li>compressionOptions，对 algorithm 参数所选用的压缩功能的参数设置，一般用来设置压缩级别，1-9，数字越大，压缩后的大小越小，也越占用 CPU，花费时间也越长</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CompressionPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        compressionOptions<span class="token punctuation">:</span> <span class="token punctuation">{</span> level<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><ol start="6"><li>threshold：Number，设置被压缩资源的最小大小，单位为字节。默认为 0</li> <li>minRatio：Number，设置压缩比率，压缩比率 = 压缩后的资源的大小/压缩后的资源，小于压缩比率的资源才会被压缩。和 threshold 参数是‘与’的关系</li> <li>filename：类型：String|Function，设置压缩资源后的名称，默认值：[path].gz[query]，[file]被替换为原始资产文件名。 [path]替换为原始资产的路径。 [dir]替换为原始资产的目录。 [name]被替换为原始资产的文件名。 [ext]替换为原始资产的扩展名。 [query]被查询替换</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">CompressionPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">filename</span><span class="token punctuation">(</span><span class="token parameter">info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>info<span class="token punctuation">.</span>path<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.gz</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>info<span class="token punctuation">.</span>query<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p>Nginx 和 Webpack 压缩的区别</p></li></ol> <ul><li>不管 Nginx 还是 Webpack 压缩，在 Nginx 中都要开启 gzip 压缩，不然浏览器加载还是未压缩的资源。
还可以在 Nginx 加上 gzip_static on;的配置。gzip_static 启用后， 浏览器请求资源时，Nginx 会先检查是否存该资源名称且后缀为.gz 的文件，如果有则直接返回该 gz 文件内容，可以避免 Nginx 对该资源再进行 gzip 压缩，浪费服务器的 CPU。</li> <li>用 Nginx 压缩会占用服务器的 CPU，浏览器每次请求资源，Nginx 会对该资源实时压缩，压缩完毕后才会返回该资源，如果资源很大的话，还是压缩级别设置很高，都会导致返回资源的时间过长，造成不好的用户体验。</li> <li>用 Webpack 会使打包时间变长。但是用 CompressionPlugin 插件压缩，会有缓存，可以相对减少打包时间。</li> <li>建议 Nginx 和 Webpack 压缩都开启压缩，且在 Nginx 加上 gzip_static on;的配置，减少服务器的 CPU 的使用，当然还是要根据项目的情况实际选择。</li></ul> <ol start="5"><li>nginx 配置 vue 项目缓存</li></ol> <ul><li>vue 的所有资源修改后打包出来的名称都会改变，所以可以使用强缓存，对 css、js、png、ttf、jpg 等</li></ul> <div class="language-sh extra-class"><pre class="language-text"><code>location ~* \.(css|js|png|jpg|jpeg|gif|gz|svg|mp4|ogg|ogv|webm|htc|xml|woff)$ {
    access_log off;
    add_header Cache-Control max-age=604800;
}
</code></pre></div><ul><li>html 文件因为名称不会改变，所以使用协商缓存，html 文件有改动就会立即更新,max-age=no-cache 代表进入协商缓存，文件改动会自动更新，不改动会返回 304</li></ul> <div class="language-sh extra-class"><pre class="language-text"><code>location ~* \.(html)$ {
    access_log off;
    add_header  Cache-Control  max-age=no-cache;
}
</code></pre></div></li></ul> <h3 id="_2-常见的优化手段？"><a href="#_2-常见的优化手段？" aria-hidden="true" class="header-anchor">#</a> 2. 常见的优化手段？</h3> <h2 id="十三、项目重难点"><a href="#十三、项目重难点" aria-hidden="true" class="header-anchor">#</a> 十三、项目重难点</h2> <h3 id="_1-前端性能监控？"><a href="#_1-前端性能监控？" aria-hidden="true" class="header-anchor">#</a> 1. 前端性能监控？</h3> <p>前端监控：它指的是通过一定的手段来获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，为产品优化指明方向，为用户提供更加精确、完善的服务。</p> <p>前端监控一般分为三大类：</p> <ul><li>数据监控（监控用户行为）
<ol><li>PV/UV：PV 即页面浏览器或点击率；UV 即访问某个站点或点击某条新闻的不同 IP 地址的人数</li> <li>用户在每一个页面的停留时间</li> <li>用户通过什么入口来访问该网页</li> <li>用户在相应的页面中触发的行为...等</li></ol></li> <li>性能监控（监控页面性能）
<ol><li>不同用户，不同机型和不同系统下的首屏加载时间</li> <li>白屏时间</li> <li>http 等请求的响应时间</li> <li>静态资源整体下载时间</li> <li>页面渲染时间...等</li></ol></li> <li>异常监控（监控产品、系统异常）
<ol><li>JavaScript 的异常监控</li> <li>样式丢失的异常监控...等</li></ol></li></ul> <h3 id="_2-前端性能埋点？"><a href="#_2-前端性能埋点？" aria-hidden="true" class="header-anchor">#</a> 2. 前端性能埋点？</h3> <ul><li><p>埋点的三种方法：</p> <ol><li>手动埋点（代码埋点）：在需要埋点的业务逻辑功能位置调用接口，上报埋点数据（像友盟、百度统计、神策）
<strong>缺点</strong>：项目工程量大，需要埋点的位置太多</li> <li>可视化埋点（通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离）
<strong>缺点</strong>：埋点的控件有限，不能手动定制</li> <li>无埋点（前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据）
<strong>优点</strong>：前端只要一次加载埋点脚本；<strong>缺点</strong>：流量和采集的数据过于庞大，服务器性能压力大</li></ol></li> <li><p>埋点上报的方式：</p> <ol><li>图片（优先考虑 GIF）
<strong>优点</strong>：防止跨域、防止阻塞页面加载，影响用户体验、相比 PNG/JPG，GIF 的体积最小</li></ol> <p>大多采用的是 1*1 像素的透明 GIF 来上报</p> <ol start="2"><li>Beacon 用于将数据异步发送到服务器。navigator.sendBeacon(url, data);</li></ol></li></ul> <h2 id="十四、开放性相关"><a href="#十四、开放性相关" aria-hidden="true" class="header-anchor">#</a> 十四、开放性相关</h2> <h3 id="_1-jsbridge-通信？"><a href="#_1-jsbridge-通信？" aria-hidden="true" class="header-anchor">#</a> 1. JSBridge 通信？</h3> <p>主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间<strong>消息通信的通道</strong>，而且这个通信的通道是<strong>双向的</strong>。</p> <ul><li><p>JSBridge 的通信原理</p> <ol><li><p>JavaScript 调用 Native 的方式
主要有两种：<code>注入API</code> 和 <code>拦截URL SCHEME</code></p> <ul><li>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的</li> <li>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作
在时间过程中，这种方式有一定的缺陷：1. 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。2. 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长</li></ul> <p><strong>因此</strong>：JavaScript 调用 Native 推荐使用注入 API 的方式</p></li> <li><p>Native 调用 JavaScript 的方式
相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，直接执行拼接好的 JavaScript 代码即可。从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。</p></li></ol></li></ul> <p><strong>扩展</strong>：RN 与 webView 的通信</p> <ul><li>webview 中点击事件代码
通过 postMessage（）方法，传递两个参数。一个是 type 值，是我们做判断时候用的。判断是哪种类型的消息。另一个是我们想传递的其他参数。这里记得参数传递前做一次：JSON.stringify()方法，解析 json 字符串</li> <li>RN 中获取传过来的参数
Webview 组件的 onMessage 方法中接受：JSON.parse(event.nativeEvent.data)</li></ul> <h3 id="_2-小程序-与-vue-有什么区别？"><a href="#_2-小程序-与-vue-有什么区别？" aria-hidden="true" class="header-anchor">#</a> 2. 小程序 与 Vue 有什么区别？</h3> <ul><li><p>生命周期：相比之下，小程序的钩子函数要简单得多。vue 的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样</p> <ol><li>onLoad：页面加载
一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数</li> <li>onShow: 页面显示
每次打开页面都会调用一次</li> <li>onReady: 页面初次渲染完成
一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置</li> <li>onHide: 页面隐藏
当 navigateTo 或底部 tab 切换时调用</li> <li>onUnload: 页面卸载
当 redirectTo 或 navigateBack 的时候调用</li></ol></li> <li><p>数据请求
在页面加载请求数据时，两者钩子的使用有些类似，vue 一般会在 created 或者 mounted 中请求数据，而在小程序，会在 onLoad 或者 onShow 中请求数据</p></li> <li><p>数据绑定</p> <ol><li>Vue: vue 动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>imgSrc<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="2"><li>小程序: 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{imgSrc}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>列表渲染</p> <ol><li>Vue: <code>&lt;li v-for=&quot;item in items&quot;&gt;&lt;/li&gt;</code></li> <li>小程序: <code>&lt;text wx:for=&quot;&quot;&gt;&lt;/text&gt;</code></li></ol></li> <li><p>显示与隐藏元素</p> <ol><li>Vue: 使用 v-if 和 v-show 控制元素的显示和隐藏</li> <li>小程序: 使用 wx-if 和 hidden 控制元素的显示和隐藏</li></ol></li> <li><p>事件处理</p> <ol><li>Vue: 使用 v-on:event 绑定事件，或者使用@event 绑定事件</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>counter += 1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Add 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>counter += 1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Add 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>小程序: 全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>noWork<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>明天不上班<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">catchtap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>noWork<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>明天不上班<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>数据双向绑定</p> <ol><li>Vue: 表单元素上加 v-model</li> <li>小程序: 通过监听输入框事件 bindinput,调用 setData({})方法进行模拟</li></ol></li> <li><p>取值</p> <ol><li>Vue: 通过 this.xxx 取值</li> <li>小程序: 通过 this.data.xxx 取值</li></ol></li> <li><p>绑定事件传参</p> <ol><li>Vue: 绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>say('明天不上班')<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>小程序: 不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>tr<span class="token punctuation">&quot;</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>toApprove<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{item.id}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
toApprove(e) { let id = e.currentTarget.dataset.id; }
</code></pre></div></li></ul> <blockquote><p>小程序实现原理解析</p></blockquote> <ul><li><p>小程序目录结构
一个完整的小程序主要由以下几部分组成：</p> <ol><li>一个入口文件：app.js</li> <li>一个全局样式：app.wxss</li> <li>一个全局配置：app.json</li></ol> <p>页面：pages 下，每个页面再按文件夹划分，每个页面 4 个文件</p> <ol><li>视图：
wxml, wxss</li> <li>逻辑：
js, json(页面配置, 不是必须)</li></ol></li> <li><p>小程序架构
微信小程序的框架包含两部分：<code>View视图层</code>、<code>App Service逻辑层</code>. View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用，它们在两个进程（两个 Webview）里运行</p> <p>视图层和逻辑层通过系统层的 JSBridge 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjE1NzI0ODkx?x-oss-process=image/format,png" alt></p> <p><strong>扩展</strong>：小程序不允许打开超过 5 个层级的页面？
小程序的视图和逻辑处理是用多个 webview 实现的，逻辑处理的 JS 代码全部加载到一个 Webview 里面，称之为 AppService，整个小程序只有一个，并且整个生命周期常驻内存。而所有的视图（wxml 和 wxss）都是单独的 Webview 来承载，称之为 AppView。所以一个小程序打开至少就会有 2 个 webview 进程，正式因为每个视图都是一个独立的 webview 进程，考虑到性能消耗</p> <p>原理上，微信 App 里包含 javascript 运行引擎、WXML/WXSS 处理引擎，最终会把界面翻译成系统原生的界面，并展示出来。这样做的目的是为了提供和原生 App 性能相当的用户体验。</p> <ul><li>在 ios 中，小程序的 javascript 运行在 javascriptCore 中</li> <li>在 Android 中,小程序的 javascript 是通过 X5 内核来解析的</li></ul></li></ul> <blockquote><p>小程序的优劣势</p></blockquote> <ul><li>优势：
<ol><li>无需下载，通过搜索和扫一扫就可以打开</li> <li>良好的用户体验：打开速度快</li> <li>开发成本要比 App 要低</li> <li>安卓上可以添加到桌面，与原生 App 差不多</li> <li>为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的</li></ol></li> <li>劣势：
<ol><li>限制较多。页面大小不能超过 1M。不能打开超过 5 个层级的页面</li> <li>样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航</li> <li>推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制</li> <li>依托于微信，无法开发后台管理功能</li></ol></li></ul> <h3 id="_3-团队的开发流程？"><a href="#_3-团队的开发流程？" aria-hidden="true" class="header-anchor">#</a> 3. 团队的开发流程？</h3> <h3 id="_4-如何防止首页白屏？"><a href="#_4-如何防止首页白屏？" aria-hidden="true" class="header-anchor">#</a> 4. 如何防止首页白屏？</h3> <p>先说下 Spa 单页面的加载过程: 首先就是 html,也就是 FP 阶段;然后是静态资源 css，js，之后解析 js，生成 HTML,也就是 FCP 阶段，css,js 资源加载下来了，首次的内容绘制，有一个大结构了;到最后,就是 FMP,ajax 请求数据之后,首次有效绘制,就是页面加载差不多了，但是可能图片还没加载出来</p> <p><strong>总结</strong>: 从 FP 到 FMP 这个过程全是白屏，可能你的 header 如果有啥大背景色啊，这个背景色或许会出来,ajax 之后，才会真正去解析我们的数据,把数据放入我们的 html 标签中
<img src="https://img-blog.csdnimg.cn/20201020201657375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM4OTA1MQ==,size_16,color_FFFFFF,t_70#pic_center" alt></p> <ul><li>解决办法：
<ol><li>预渲染</li> <li>SSR</li> <li>路由懒加载</li> <li>使用 Gzip 压缩</li> <li>webpack entry 多页应用</li> <li>骨架屏（原理）</li> <li>loading
在首页 index.html 里加一个 loading css 效果，当页面加载完成消失</li></ol></li></ul> <h3 id="_5-怎么理解前端工程化、模块化、组件化"><a href="#_5-怎么理解前端工程化、模块化、组件化" aria-hidden="true" class="header-anchor">#</a> 5. 怎么理解前端工程化、模块化、组件化?</h3> <ul><li><strong>工程化</strong>：是一种思想而不是某种技术，而模块化和组件化是为工程化思想下相对较具体的开发方式。可以简单的认为模块化和组件化是工程化的表现形式</li> <li><strong>模块化开发</strong>：一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块
<ul><li>模块化开发的好处：
<ol><li>提高代码复用率和维护性</li> <li>避免变量污染、命名冲突</li></ol></li></ul></li> <li><strong>组件化开发</strong>：就是将一个页面拆分成很多的小组件</li></ul> <h3 id="_6-微前端中的渲染、js-沙箱、样式隔离、数据通信"><a href="#_6-微前端中的渲染、js-沙箱、样式隔离、数据通信" aria-hidden="true" class="header-anchor">#</a> 6. 微前端中的渲染、JS 沙箱、样式隔离、数据通信?</h3> <h3 id="_7-如何实现扫码登录功能？"><a href="#_7-如何实现扫码登录功能？" aria-hidden="true" class="header-anchor">#</a> 7. 如何实现扫码登录功能？</h3> <ul><li><p>访问 PC 端二维码生成页面，PC 端请求服务端获取 <code>二维码ID</code></p></li> <li><p>服务端生成相应的<code>二维码ID</code>，设置二维码的过期时间，状态等。</p></li> <li><p>PC 获取<code>二维码ID</code>，生成相应的二维码。</p></li> <li><p>手机端扫描二维码，获取<code>二维码ID</code>。</p></li> <li><p>手机端将<code>手机端token</code>和<code>二维码ID</code>发送给服务端，确认登录。</p></li> <li><p>服务端校验<code>手机端token</code>，根据<code>手机端token</code>和<code>二维码ID</code>生成 PC 端<code>token</code></p></li> <li><p>PC 端通过<code>轮询方式</code>请求服务端，通过二维码 ID 获取二维码状态，如果已成功，返回 PC token，登录成功。</p> <p><strong>扩展</strong>：轮询方式有哪些，以及它们各自的优缺点？</p> <ul><li><p>轮询
基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
<strong>优点</strong>: 是比较简单，易于理解，实现起来也没有什么技术难点。
<strong>缺点</strong>: 由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源. 人数越多，服务器端压力越大，这是很不合理的。</p></li> <li><p>长轮询
服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。
<strong>优点</strong>: 减少了很多不必要的 http 请求次数，相比之下节约了资源
<strong>缺点</strong>: 接挂起也会导致资源的浪费</p> <p>轮询与长轮询都是基于 HTTP 的</p></li> <li><p>长连接（SSE）
SSE 是 HTML5 新增的功能，全称为 Server-Sent Events。它可以允许服务推送数据到客户端。SSE 在本质上就与之前的长轮询、短轮询不同，虽然都是基于 http 协议的，但是轮询需要客户端先发送请求。而 SSE 最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。
<strong>优点</strong>: 它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能</p></li> <li><p>WebSocket
WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议可以实现服务器与客户端之间全双工通信</p></li></ul></li></ul> <h3 id="_8-如何防止重复发送请求？"><a href="#_8-如何防止重复发送请求？" aria-hidden="true" class="header-anchor">#</a> 8. 如何防止重复发送请求？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">firstPromise</span><span class="token punctuation">(</span><span class="token parameter">promiseFunction</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 请求的实例，已存在意味着正在请求中，直接返回实例，不触发新的请求</span>
    <span class="token keyword">return</span> p
      <span class="token operator">?</span> p
      <span class="token punctuation">:</span> <span class="token comment">// 否则发送请求，且在finally时将p置空，那么下一次请求可以重新发起</span>
        <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token function">promiseFunction</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>扩展</strong>：前端做后台管控系统，在某些接口请求时间过长的场景下，需要防止用户反复发起请求，实现方式也有好几种：</p> <ol><li>在按钮点击发起请求后，弹个蒙层，显示个 loading，等请求数据返回了将蒙层隐藏掉</li> <li>在按钮点击发起请求后，将按钮禁用掉，同样等数据返回了将按钮禁用解除</li></ol> <p>以上两种方案优点仅仅是简单，但是每个需要处理的页面都要单独写一串重复的代码，哪怕利用 mixin 也要多不少冗余代码。利用指令的方式仅仅需要在合适的地方加上个一条 v-xxxx，其他都在指令的逻辑内统一处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> forbidClick <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> el <span class="token operator">=</span> e
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token function-variable function">forbidClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span>disabled <span class="token operator">=</span> <span class="token boolean">true</span>
      el<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'is-disabled'</span><span class="token punctuation">)</span>
      timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>currentRes<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
          el<span class="token punctuation">.</span>disabled <span class="token operator">=</span> <span class="token boolean">false</span>
          el<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'is-disabled'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> forbidClick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> forbidClick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
再考虑请求，记录当前请求是否完成。请求拦截器中，接口请求时长超过<span class="token number">3</span>s，则视为完成，不管请求结果成功或失败
</code></pre></div><p>这样就实现了只要在按钮上加上了 v-clickForbidden。按钮点击后就会被禁用，仅当某个请求返回数据或者 3s 后将按钮的禁用解除</p> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/chapter16/performance.html" class="prev">
          开放性
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.c45b4ff4.js" defer></script><script src="/assets/js/71.e941d084.js" defer></script>
  </body>
</html>
