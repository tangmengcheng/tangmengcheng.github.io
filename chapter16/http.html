<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. 说一下 GET 和 POST 的区别？ | 技术博客文章总结</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.c45b4ff4.js" as="script"><link rel="preload" href="/assets/js/70.e4e45ab1.js" as="script"><link rel="prefetch" href="/assets/js/10.9cdf722f.js"><link rel="prefetch" href="/assets/js/100.9b45b75e.js"><link rel="prefetch" href="/assets/js/101.95c4d653.js"><link rel="prefetch" href="/assets/js/102.09cdc274.js"><link rel="prefetch" href="/assets/js/103.985d4863.js"><link rel="prefetch" href="/assets/js/104.66cfb550.js"><link rel="prefetch" href="/assets/js/105.78c4c309.js"><link rel="prefetch" href="/assets/js/106.34be9d25.js"><link rel="prefetch" href="/assets/js/107.0df352d3.js"><link rel="prefetch" href="/assets/js/108.901d6014.js"><link rel="prefetch" href="/assets/js/109.76339f5d.js"><link rel="prefetch" href="/assets/js/11.d22cc24d.js"><link rel="prefetch" href="/assets/js/110.c6e9ec88.js"><link rel="prefetch" href="/assets/js/111.d390a797.js"><link rel="prefetch" href="/assets/js/112.cf502784.js"><link rel="prefetch" href="/assets/js/113.aa449169.js"><link rel="prefetch" href="/assets/js/114.fc2133ce.js"><link rel="prefetch" href="/assets/js/115.523542e3.js"><link rel="prefetch" href="/assets/js/116.c3507815.js"><link rel="prefetch" href="/assets/js/117.23b5b1f0.js"><link rel="prefetch" href="/assets/js/118.5df8c262.js"><link rel="prefetch" href="/assets/js/119.8e1342c2.js"><link rel="prefetch" href="/assets/js/12.636890c7.js"><link rel="prefetch" href="/assets/js/120.01f21153.js"><link rel="prefetch" href="/assets/js/121.7b546d27.js"><link rel="prefetch" href="/assets/js/122.bd8c0286.js"><link rel="prefetch" href="/assets/js/123.f4f16ed2.js"><link rel="prefetch" href="/assets/js/124.ab5935d4.js"><link rel="prefetch" href="/assets/js/125.b29cf321.js"><link rel="prefetch" href="/assets/js/126.ddf1b9eb.js"><link rel="prefetch" href="/assets/js/127.4d63b823.js"><link rel="prefetch" href="/assets/js/128.f63c61cb.js"><link rel="prefetch" href="/assets/js/129.e74fb4b4.js"><link rel="prefetch" href="/assets/js/13.74a454d8.js"><link rel="prefetch" href="/assets/js/130.05f02f04.js"><link rel="prefetch" href="/assets/js/131.bac5f9b9.js"><link rel="prefetch" href="/assets/js/132.a98fffcf.js"><link rel="prefetch" href="/assets/js/133.5b34ebb6.js"><link rel="prefetch" href="/assets/js/14.ffe8d211.js"><link rel="prefetch" href="/assets/js/15.1bcc034f.js"><link rel="prefetch" href="/assets/js/16.87d6c8f3.js"><link rel="prefetch" href="/assets/js/17.576aa97e.js"><link rel="prefetch" href="/assets/js/18.8c80ffa6.js"><link rel="prefetch" href="/assets/js/19.bd2abc77.js"><link rel="prefetch" href="/assets/js/2.0379b669.js"><link rel="prefetch" href="/assets/js/20.56b31195.js"><link rel="prefetch" href="/assets/js/21.81d1d011.js"><link rel="prefetch" href="/assets/js/22.b52a1bed.js"><link rel="prefetch" href="/assets/js/23.76785e7d.js"><link rel="prefetch" href="/assets/js/24.4bcce340.js"><link rel="prefetch" href="/assets/js/25.b2de599f.js"><link rel="prefetch" href="/assets/js/26.944ed78e.js"><link rel="prefetch" href="/assets/js/27.0bbcee1a.js"><link rel="prefetch" href="/assets/js/28.223ed5b6.js"><link rel="prefetch" href="/assets/js/29.b88c0c25.js"><link rel="prefetch" href="/assets/js/3.b3231975.js"><link rel="prefetch" href="/assets/js/30.5754e2d0.js"><link rel="prefetch" href="/assets/js/31.038ca76a.js"><link rel="prefetch" href="/assets/js/32.7f0c55a6.js"><link rel="prefetch" href="/assets/js/33.7fd80664.js"><link rel="prefetch" href="/assets/js/34.8dcb3109.js"><link rel="prefetch" href="/assets/js/35.8b1fdc43.js"><link rel="prefetch" href="/assets/js/36.cf886fc0.js"><link rel="prefetch" href="/assets/js/37.f7abfe5d.js"><link rel="prefetch" href="/assets/js/38.f63c0deb.js"><link rel="prefetch" href="/assets/js/39.9b06b340.js"><link rel="prefetch" href="/assets/js/4.c1de1412.js"><link rel="prefetch" href="/assets/js/40.490eed30.js"><link rel="prefetch" href="/assets/js/41.b5abbdbc.js"><link rel="prefetch" href="/assets/js/42.1f6e4a3a.js"><link rel="prefetch" href="/assets/js/43.5e85acae.js"><link rel="prefetch" href="/assets/js/44.11b7ef0a.js"><link rel="prefetch" href="/assets/js/45.9774ff29.js"><link rel="prefetch" href="/assets/js/46.2cf4bc5b.js"><link rel="prefetch" href="/assets/js/47.bc79b4ef.js"><link rel="prefetch" href="/assets/js/48.0d80c17f.js"><link rel="prefetch" href="/assets/js/49.4fcabf82.js"><link rel="prefetch" href="/assets/js/5.1d97952d.js"><link rel="prefetch" href="/assets/js/50.7d65f488.js"><link rel="prefetch" href="/assets/js/51.2545cb57.js"><link rel="prefetch" href="/assets/js/52.36a2cca1.js"><link rel="prefetch" href="/assets/js/53.64484c50.js"><link rel="prefetch" href="/assets/js/54.52e5411a.js"><link rel="prefetch" href="/assets/js/55.4f773e83.js"><link rel="prefetch" href="/assets/js/56.a5437204.js"><link rel="prefetch" href="/assets/js/57.24dd7861.js"><link rel="prefetch" href="/assets/js/58.86388619.js"><link rel="prefetch" href="/assets/js/59.c9912d49.js"><link rel="prefetch" href="/assets/js/6.210e38ca.js"><link rel="prefetch" href="/assets/js/60.b29d00e8.js"><link rel="prefetch" href="/assets/js/61.13ff4966.js"><link rel="prefetch" href="/assets/js/62.8efcf596.js"><link rel="prefetch" href="/assets/js/63.5fa9582a.js"><link rel="prefetch" href="/assets/js/64.bbd14fec.js"><link rel="prefetch" href="/assets/js/65.bae7fd4f.js"><link rel="prefetch" href="/assets/js/66.8e3958d7.js"><link rel="prefetch" href="/assets/js/67.dac9beaa.js"><link rel="prefetch" href="/assets/js/68.1c7432eb.js"><link rel="prefetch" href="/assets/js/69.363a3505.js"><link rel="prefetch" href="/assets/js/7.1b6e0d8a.js"><link rel="prefetch" href="/assets/js/71.e941d084.js"><link rel="prefetch" href="/assets/js/72.6c657f6c.js"><link rel="prefetch" href="/assets/js/73.910ec668.js"><link rel="prefetch" href="/assets/js/74.92f12f63.js"><link rel="prefetch" href="/assets/js/75.984c2f19.js"><link rel="prefetch" href="/assets/js/76.e4dddf5f.js"><link rel="prefetch" href="/assets/js/77.1304118a.js"><link rel="prefetch" href="/assets/js/78.36d67468.js"><link rel="prefetch" href="/assets/js/79.bebe2f90.js"><link rel="prefetch" href="/assets/js/8.23102c69.js"><link rel="prefetch" href="/assets/js/80.4f2da588.js"><link rel="prefetch" href="/assets/js/81.666e12e9.js"><link rel="prefetch" href="/assets/js/82.00e1d25e.js"><link rel="prefetch" href="/assets/js/83.6f17555a.js"><link rel="prefetch" href="/assets/js/84.71aca979.js"><link rel="prefetch" href="/assets/js/85.5da240e9.js"><link rel="prefetch" href="/assets/js/86.e9b29015.js"><link rel="prefetch" href="/assets/js/87.0c138ef2.js"><link rel="prefetch" href="/assets/js/88.d122fecd.js"><link rel="prefetch" href="/assets/js/89.ccb42cfb.js"><link rel="prefetch" href="/assets/js/9.7477a4ab.js"><link rel="prefetch" href="/assets/js/90.620b4440.js"><link rel="prefetch" href="/assets/js/91.a231af75.js"><link rel="prefetch" href="/assets/js/92.0bb536ea.js"><link rel="prefetch" href="/assets/js/93.a8d3b09d.js"><link rel="prefetch" href="/assets/js/94.4e3d0336.js"><link rel="prefetch" href="/assets/js/95.263fdc93.js"><link rel="prefetch" href="/assets/js/96.2886b194.js"><link rel="prefetch" href="/assets/js/97.d085eef0.js"><link rel="prefetch" href="/assets/js/98.eaf95a18.js"><link rel="prefetch" href="/assets/js/99.fbafbf7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术博客文章总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Vue 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6+</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>H5</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端设计模式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>面试总结</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级进阶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>源码手写</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>高级面试题汇总</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/chapter16/" class="sidebar-link">前端面试大纲</a></li><li><a href="/chapter16/html.html" class="sidebar-link">HTML 部分</a></li><li><a href="/chapter16/css.html" class="sidebar-link">CSS 部分</a></li><li><a href="/chapter16/js.html" class="sidebar-link">JS 部分</a></li><li><a href="/chapter16/vue.html" class="sidebar-link">Vue 部分</a></li><li><a href="/chapter16/react.html" class="sidebar-link">React 部分</a></li><li><a href="/chapter16/webpack.html" class="sidebar-link">Webpack 部分</a></li><li><a href="/chapter16/http.html" class="active sidebar-link">HTTP 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter16/http.html#_1-说一下-get-和-post-的区别？" class="sidebar-link">1. 说一下 GET 和 POST 的区别？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_2-http1-0、http1-1、http2、http3-的区别？" class="sidebar-link">2. HTTP1.0、HTTP1.1、HTTP2、HTTP3 的区别？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_3-dns-解析过程及原理？回源是什么？dns-劫持听说过吗？" class="sidebar-link">3. DNS 解析过程及原理？回源是什么？DNS 劫持听说过吗？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_4-tcp-和-udp-区别是什么？" class="sidebar-link">4. TCP 和 UDP 区别是什么？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_5-如何理解-tcp-ip-五层模型-osi-七层模型？" class="sidebar-link">5. 如何理解 TCP/IP 五层模型 OSI 七层模型？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_6-为什么-https-比-http-安全？https-是如何保证安全的？" class="sidebar-link">6. 为什么 HTTPS 比 HTTP 安全？HTTPS 是如何保证安全的？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_7-http-常见的状态码有哪些？适用的场景？" class="sidebar-link">7. HTTP 常见的状态码有哪些？适用的场景？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_8-知道-http-的缓存吗？（浏览器强缓存和协商缓存）" class="sidebar-link">8. 知道 HTTP 的缓存吗？（浏览器强缓存和协商缓存）</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_9-前端错误的分类有哪些？" class="sidebar-link">9. 前端错误的分类有哪些？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_10-说说为什么前端会有跨域？如何解决跨域？知道-option-请求吗？" class="sidebar-link">10. 说说为什么前端会有跨域？如何解决跨域？知道 option 请求吗？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_11-tcp-三次握手-四次挥手（短连接-长连接）？" class="sidebar-link">11. TCP 三次握手 &amp; 四次挥手（短连接 &amp; 长连接）？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_12-知道第三方-cookie-吗？" class="sidebar-link">12. 知道第三方 Cookie 吗？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_13-csrf-和-xss-、ssrf-的攻击原理-与防御措施？" class="sidebar-link">13. CSRF 和 XSS 、SSRF 的攻击原理 与防御措施？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_14-v8-中执行一段-js-代码的整个过程" class="sidebar-link">14. V8 中执行一段 JS 代码的整个过程</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_14-从输入-url-到页面展示经历了什么？" class="sidebar-link">14. 从输入 URL 到页面展示经历了什么？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_15-说说浏览器渲染原理？" class="sidebar-link">15. 说说浏览器渲染原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_16-前端需要注意哪些-seo？" class="sidebar-link">16. 前端需要注意哪些 SEO？</a></li><li class="sidebar-sub-header"><a href="/chapter16/http.html#_17-什么是堆？什么是栈？它们之间有什么区别和联系？" class="sidebar-link">17. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li></ul></li><li><a href="/chapter16/algorithm.html" class="sidebar-link">算法部分</a></li><li><a href="/chapter16/optimize.html" class="sidebar-link">优化部分</a></li><li><a href="/chapter16/performance.html" class="sidebar-link">开放性</a></li><li><a href="/chapter16/inter.html" class="sidebar-link">2022</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="_1-说一下-get-和-post-的区别？"><a href="#_1-说一下-get-和-post-的区别？" aria-hidden="true" class="header-anchor">#</a> 1. 说一下 GET 和 POST 的区别？</h2> <ul><li><p><code>GET</code> 在浏览器回退时是 <code>无害的</code>，而 <code>POST</code> 会 <code>再次提交</code> 请求</p></li> <li><p><code>GET</code> 请求只能进行 <code>url 编码</code>，而 <code>POST</code> 支持 <code>多种编码</code> 方式</p></li> <li><p><code>GET</code> 请求参数会被完整保留在浏览器历史记录里，而 <code>POST</code> 中的参数不会保留</p></li> <li><p><code>GET</code> 请求参数通过 <code>URL 传递</code> 且参数是 <code>有长度限制</code> 的（2083 字符，中文字符的话只有 2083/9=231 个字符），而 <code>POST</code> 参数放在 <code>Request body</code> 中是没有限制的</p> <p><strong>注意</strong>：<code>HTTP 协议</code> 未规定 <code>GET</code> 和 <code>POST</code> 的长度限制；<code>GET</code> 的最大长度显示是因为 <code>浏览器</code> 和 <code>web 服务器</code> 限制了 <code>URI</code> 的长度。不同的 <code>浏览器</code> 和 <code>WEB 服务器</code>，限制的最大长度不一样，要支持 <code>IE</code>，则最大长度为 2083byte，若只支持 <code>Chrome</code>，则最大长度 8182byte</p></li> <li><p>对参数的数据类型，<code>GET</code> 只接受 <code>ASCII 字符</code>（如果非 <code>ASCII</code> 字符会进行 <code>转码</code>），而 <code>POST</code> 没有限制</p></li> <li><p><code>GET</code> 和 <code>POST</code> 本质上就是 <code>TCP 连接</code>, <code>GET</code> 产生 <strong>一个</strong> <code>TCP 数据包</code>；<code>POST</code> 产生 <strong>两个</strong> <code>TCP 数据包</code></p> <p><strong>注意</strong>：并不是所有浏览器都会在 <code>POST</code> 中发送两次包，<code>Firefox</code> 就只发送一次</p> <ol><li>对于 <code>GET</code> 方式的请求，浏览器会把 <code>http header</code> 和 <code>data</code> 一并发送出去，服务器响应 200（返回数据）</li> <li>对于 <code>POST</code>，浏览器先发送 <code>header</code>，服务器响应 <code>100 continue</code>，浏览器再发送 <code>data</code>，服务器响应 200 ok（返回数据）</li></ol></li></ul> <h2 id="_2-http1-0、http1-1、http2、http3-的区别？"><a href="#_2-http1-0、http1-1、http2、http3-的区别？" aria-hidden="true" class="header-anchor">#</a> 2. HTTP1.0、HTTP1.1、HTTP2、HTTP3 的区别？</h2> <blockquote><p>HTTP 1.0(1996 年)</p></blockquote> <ul><li>任意数据类型都可以发送</li> <li>有 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 三种方法</li> <li>无法复用 <code>TCP 连接</code>(长连接)</li> <li>有丰富的请求响应头信息。以 <code>header</code> 中的 <code>Last-Modified/If-Modified-Since</code> 和 <code>Expires</code> 作为缓存标识</li></ul> <blockquote><p>HTTP 1.1(1997 年)</p></blockquote> <ul><li>引入更多的请求方法类型 <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></li> <li>引入 <code>长连接</code>，就是 <code>TCP 连接</code> 默认不关闭，可以被多个请求复用，通过请求头 <code>connection: keep-alive</code> 设置</li> <li>引入 <code>管道</code> 连接机制，可以在同一 <code>TCP</code> 连接里，同时发送多个请求</li> <li>强化了缓存管理和控制 <code>Cache-Control</code>、<code>ETag/If-None-Match</code></li> <li>支持 <code>分块响应</code>，<code>断点续传</code>，利于大文件传输，能过请求头中的 <code>Range</code> 实现</li></ul> <blockquote><p>HTTP 2.0(2015 年)</p></blockquote> <ul><li>使用新的 <code>二进制协议</code>，不再是纯文本，避免文本歧义，缩小了请求体积</li> <li><code>多路复用</code>，同域名下所有通信都是在单链接(双向数据流)完成，提高连接的复用率，在拥塞控制方面有更好的能力提升</li> <li>允许服务端主动推送数据给客户端</li> <li>使用 <code>HPACK</code> 算法将 <code>头部压缩</code>，用 <code>哈夫曼编码</code> 建立索表，传送索引大大节约了带宽</li></ul> <blockquote><p>HTTP 3.0/QUIC</p></blockquote> <p><strong>缺点</strong>：主要是连接缓慢，服务器只能按顺序响应，如果某个请求花了很长时间，就会出现请求 <code>队头阻塞</code></p> <blockquote><p>HTTP1 和 HTTP2</p></blockquote> <ul><li><code>HTTP2</code> 是一个 <code>二进制协议</code>，<code>HTTP1</code> 是 <code>超文本协议</code>，传输的内容都不是一样的</li> <li><code>HTTP2</code> <code>报头压缩</code>，可以使用 <code>HPACK</code> 进行头部压缩，<code>HTTP1</code> 则不论什么请求都会发送</li> <li><code>HTTP2</code> 服务端推送(<code>Server push</code>)，允许服务器预先将网页所需要的资源 <code>push</code> 到浏览器的内存当中</li> <li><code>HTTP2</code> 遵循 <code>多路复用</code>，代替同一域名下的内容，只建立一次连接，<code>HTTP1.x</code> 不是，对域名有 6~8 个连接限制</li></ul> <blockquote><p>HTTP 请求方法(9 种)</p></blockquote> <p><code>HTTP1.0</code>： <code>GET</code>、<code>POST</code>、<code>HEAD</code></p> <p><code>HTTP1.1</code>： <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></p> <p><code>HTTP</code> 全称 <code>Hyper Text Transfer Protocol</code>，即超文本传输协议。<code>HTTP</code> 是一个 <strong>应用层协议</strong>。</p> <p><code>HTTP</code> 的报文结构：<code>请求行</code> + <code>请求头</code> + <code>请求体</code></p> <blockquote><p>Accept 字段与 Content-type 字段：</p></blockquote> <ul><li><code>Accept</code>: 用于客户端向服务器发送报文时表示自己可接收的响应内容类型，如：<code>Accept: text/plain</code> (文本类型)
<ol><li><code>Accept-Charset</code>: 表示可接收的字符集</li> <li><code>Accept-Encoding</code>: 表示可接受的响应内容的压缩方式</li> <li><code>Accept-Language</code>: 表示可接受的响应内容语言列表</li> <li><code>Accept-Datetime</code>: 表示可接受的按照时间来表示的响应内容版本</li></ol></li> <li><code>Content-Type</code>: 字段用于服务器回应时，告诉客户端，本次数据的格式是什么
<ol><li><code>Content-Encoding</code>: 表示服务器返回的数据使用什么压缩格式</li></ol></li> <li><code>Host</code> 字段: 用于客户端发送请求时，用来指定服务器的域名。例如：<code>Host: www.baidu.com</code></li> <li><code>Connection</code> 字段: 最常用于客户端要求服务器使用 <code>TCP</code> 持久连接，以便其他请求复用 <code>keep-alive</code></li> <li><code>Content-Length</code> 字段: 表明本次回应的数据长度</li></ul> <h3 id="http-存在的问题"><a href="#http-存在的问题" aria-hidden="true" class="header-anchor">#</a> HTTP 存在的问题</h3> <ul><li><p>性能问题</p> <p>在 <code>HTTP/1.0</code> 中，每次发起一个 <code>HTTP</code> 请求，都需要去建立一次 <code>TCP 连接</code>，而且还是串行请求，这使得 <code>HTTP</code> 在 <code>TCP 的连接</code> 建立上花费了大量的开销。对于这种问题，<code>HTTP/1.1</code> 中提出了<strong>长连接</strong>的通信方式，也叫<code>持久连接</code>。<strong>好处</strong>: 在于减少了 <code>TCP 连接</code> 的重复建立和断开所造成的额外开销，减轻了服务器端的负载</p> <p><code>HTTP/1.1</code> 采用了 <code>长连接</code> 的方式，使得<code>管道（Pipeline）</code>网络传输成为了可能。即在同一个 <code>TCP 连接</code> 里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。<strong>但是</strong> 服务器还是按照顺序，先回应第一个请求，完成后再回应第二个请求，以此类推。要是前面的请求回应得特别慢，后面就会有许多请求阻塞着，这就是所谓的【<strong>队头阻塞</strong>】</p></li></ul> <p><strong>总结</strong>： <code>HTTP/1.0</code> 或是 <code>HTTP/1.1</code> 性能都不是很完美</p> <ul><li><p>安全问题</p> <p><code>HTTP</code> 的内容是 <code>明文传输</code> 的，明文数据会经过 <code>中间代理服务器</code>、<code>路由器</code>、<code>WIFI热点</code>、<code>通信服务运行商</code> 等多个物理节点，如果信息在传输过程中被劫持，传输的内容久完全暴露了，劫持者还可以篡改传输的信息且不被双方察觉，这就是 <strong>中间人攻击</strong></p> <p>总结一下，<code>HTTP</code> 在安全方面有以下三个问题：</p> <ol><li>使用明文通信，一些重要的内容会被窃听</li> <li>不能验证对方身份，可能是伪造的信息</li> <li>无法验证报文的完整性，有可能被修改</li></ol></li></ul> <blockquote><p><code>HTTP/2</code> 有哪些改进？</p></blockquote> <ol><li>头部压缩</li> <li>多路复用</li> <li>服务器推送</li> <li>二进制传输</li></ol> <blockquote><p>HTTP 的特点和缺点</p></blockquote> <ul><li><p>特点：<strong>无连接</strong> (<code>请求完就断开，不保持连接</code>)、<strong>无状态</strong> (<code>每个请求都是独立的</code>)、<strong>灵活</strong> (<code>http 协议中头部的 Content-Type 标记，可以传输任意数据类型的数据对象（文本、图像、视频等。比较灵活）</code>)、<strong>简单快速</strong> (<code>请求访问某个资源时，只需传送请求方法和 URL 就可以了，使用简单</code>)</p></li> <li><p>缺点：<strong>无状态</strong>、<strong>不安全</strong> (<code>明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改</code>)、<strong>明文传输</strong>、<strong>队头阻塞</strong> (<code>一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态</code>)</p></li> <li><p>什么是 <strong>持久连接/长连接</strong>?</p> <p><code>http1.0</code> 协议采用的是 &quot;请求-应答&quot; 模式，每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接(<code>http</code> 协议为无连接的协议)</p> <p><code>http1.1</code> 版本支持 <code>长连接</code>，即请求头添加 <code>Connection: Keep-Alive</code>，使用 <code>Keep-Alive</code> 模式(又称 <code>持久连接</code>，<code>连接复用</code>)建立一个 <code>TCP</code> 连接后使客户端到服务端的连接持续有效，可以发送/接受多个 <code>http</code> 请求/响应，当出现对服务器的后续请求时，<code>Keep-Alive</code> 功能避免了建立或者重新建立连接</p> <ul><li>长连接优缺点?
<ul><li>优点
<ol><li>减少 CPU 及内存的使用，因为不需要经常建立和关闭连接</li> <li>支持管道化的请求及响应模式</li> <li>减少网络堵塞，因为减少了 TCP 请求</li> <li>减少了后续请求的响应时间，因为不需要等待建立 TCP、握手、挥手、关闭 TCP 的过程</li> <li>发生错误时，也可在不关闭连接的情况下进行错误提示</li></ol></li> <li>缺点
<ol><li>一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数</li> <li>还有就是可能造成 <code>队头堵塞</code></li></ol></li></ul></li> <li>如何避免长连接资源浪费？
<ol><li>客户端请求头声明：<code>Connection: close</code>，本次通信后就关闭连接</li> <li>服务端配置：如 <code>Nginx</code>，设置 <code>keepalive_timeout</code> 设置 <code>长连接超时时间</code>，<code>keepalive_requests</code> 设置 <code>长连接请求次数上限</code></li></ol></li></ul></li> <li><p>什么是 <strong>管线化(管道化)</strong>?</p> <p><code>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</code></p> <p><code>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</code></p> <p><strong>管线化</strong>: 是在同一个 <code>TCP 连接</code>里 <code>发一个请求后不必等其回来就可以继续发请求出去</code>，这可以减少整体的响应时间，但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题 <strong>队头堵塞</strong></p> <ul><li><code>管线化</code> 的特点：
<ol><li><code>管线化</code> 机制通过 <code>持久连接</code> 完成，在 <code>http1.1</code> 版本才支持</li> <li>只有 <code>GET</code> 请求和 <code>HEAD</code> 请求才可以进行管线化，而 <code>POST</code> 有所限制</li> <li><code>管线化</code> 不会影响响应到来的顺序，响应返回的顺序就是请求的顺序</li> <li>初次创建连接时不应启动管线化机制，因为服务器不一定支持 <code>http1.1</code> 版本的协议</li></ol></li></ul></li> <li><p>如何解决 <code>HTTP</code> 的 <strong>队头阻塞</strong> 问题?</p> <ol><li><p><strong>并发连接</strong>
（现在的浏览器标准中一个域名并发连接可以有 6~8 个，记住是 6~8 个，不是 6 个(Chrome6 个/Firefox8 个)）</p></li> <li><p><strong>域名分片</strong>
（一个域名最多可以并发 6~8 个，那咱就多来几个域名，多准备几个二级域名，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了）</p> <p><strong>注意</strong>：在 <code>HTTP2.0</code> 下，可以一瞬间加载出来很多资源，因为支持 <code>多路复用</code>，可以在<code>一个 TCP 连接中发送多个请求</code></p></li></ol></li></ul> <h2 id="_3-dns-解析过程及原理？回源是什么？dns-劫持听说过吗？"><a href="#_3-dns-解析过程及原理？回源是什么？dns-劫持听说过吗？" aria-hidden="true" class="header-anchor">#</a> 3. DNS 解析过程及原理？回源是什么？DNS 劫持听说过吗？</h2> <ul><li><p>解析域名的查找过程：</p> <p>浏览器的 DNS 缓存 -&gt; 操作系统的 DNS 缓存 -&gt; 本地域名服务器(<strong>递归查询</strong> 自己的 DNS 缓存) -&gt; 上级域名服务器(进行<strong>迭代查询</strong>)【本地域名服务器 -&gt; 根域名服务器(会返回顶级域名的服务器地址); 本地域名服务器 -&gt; 顶级域名服务器(返回权威域名服务器地址，全球 13 台) 】 -》解析到的 IP 地址返回给操作系统，并缓存起来。-》操作系统将 IP 地址返回给浏览器，并缓存起来，供下次使用。</p></li></ul> <p><strong>DNS 劫持</strong>，是指通过 <code>攻击域名解析服务器</code>（DNS）或 <code>伪造域名解析服务器</code>（DNS）的方法，把目标网站域名解析到错误的 IP 地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定 IP 地址（网站）的目的。</p> <ul><li>通常来说存在三种情况：
<ol><li><code>路由器</code> 被入侵</li> <li><code>DNS 服务器</code> 被入侵</li> <li>运营商流量劫持</li></ol></li></ul> <h2 id="_4-tcp-和-udp-区别是什么？"><a href="#_4-tcp-和-udp-区别是什么？" aria-hidden="true" class="header-anchor">#</a> 4. TCP 和 UDP 区别是什么？</h2> <p><strong>TCP 是一个面向连接的（需要三次握手）、可靠的、基于字节流的传输层协议</strong>。而<strong>UDP 是一个面向无连接（无需建立连接）的传输层协议</strong>。(就这么简单，其它 TCP 的特性也就没有了)。</p> <ul><li><p>和 <code>UDP</code> 相比，<code>TCP</code> 有三大核心特性:</p> <ol><li><p><strong>面向连接</strong>。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，<code>TCP</code> 需要三次握手建立连接，而 <code>UDP</code> 没有相应建立连接的过程。</p></li> <li><p><strong>可靠性</strong>。<code>TCP</code> 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是 <code>有状态</code>，另一个是 <code>可控制</code>。</p> <p>TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是 <strong>有状态</strong>。</p> <p>当意识到 <code>丢包了</code> 或者 <code>网络环境不佳</code>，TCP 会根据具体情况调整自己的行为，控制自己的 <code>发送速度</code> 或者 <code>重发</code>。这是 <strong>可控制</strong>。</p> <p>相应的，UDP 就是<code>无状态</code>, <code>不可控的</code>。</p> <ul><li>为什么可靠？
<ol><li><code>顺序编号</code>（tcp 在传输文件的时候，会将文件拆分为多个 tcp 数据包，会将这些数据包顺序编号）</li> <li><code>确认机制</code>（当数据包成功的被发送方发送给接收方，接收方会根据 tcp 协议反馈给发送方一个成功接收的 ACK 信号，信号中包含了当前包的序号）</li> <li><code>超时重传</code>（当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的 ACK 信号，会再次发送该数据包，直到收到接收方的 ACK 信号或者连接已断开）</li> <li><code>校验信息</code>（tcp 首部校验信息较多，udp 首部校验信息较少）</li></ol></li></ul></li> <li><p><strong>面向字节流</strong>。<code>UDP</code> 的数据传输是基于<code>数据包</code>的，这是因为仅仅只是继承了 IP 层的特性，而 <code>TCP</code> 为了维护状态，将一个个 <code>IP</code> 包变成了 <strong>字节流</strong>。</p></li> <li><p><code>tcp</code> 连接过程中出现的延时增加了被攻击的可能，安全性不高，而 udp 不需要连接，安全性较高</p></li> <li><p><code>tcp</code> 是可靠的，保证数据传输的正确性，不易丢包，<code>udp</code> 是不可靠的，易丢包</p></li> <li><p><code>tcp</code> 传输速率较慢，实时性差，<code>udp</code> 传输速率较快</p></li> <li><p><code>tcp</code> 是 <code>字节流</code> 模式，<code>udp</code> 是 <code>数据包</code> 模式</p></li></ol></li> <li><p><code>UDP</code> 的特点：</p> <ol><li><code>无连接</code> : 不需要握手和挥手就可以直接发送数据</li> <li><code>不可靠性</code> <ul><li>为什么不可靠？
<ol><li>传输数据之前不需要先建立连接</li> <li>不保证消息交付，远程主机的传输层在接收到 UDP 报文后，不需要确认</li> <li>不保证将会顺序，不设置包序号、不重排、不会发生队首阻塞</li> <li>不进行拥塞控制，没有内置反馈机制，不重传、无超时</li></ol></li></ul></li> <li><code>支持广播</code></li> <li><code>首部开销小</code>: (tcp 建立连接需要耗时，并且 tcp 首部信息太多，每次传输的有用信息较少，实时性差)</li> <li><code>是面向报文的</code></li> <li><code>无拥塞控制</code></li></ol></li> <li><p><code>tcp/udp</code> 的使用场合？</p> <ol><li>对数据可靠性的要求。<code>tcp</code> 适用于可靠性高的场合，<code>udp</code> 适用于可靠性低的场合</li> <li>应用的实时性。<code>tcp</code> 有延时较大，<code>udp</code> 延时较小</li> <li>网络的可靠性。网络不好的情况下使用 <code>tcp</code>，网络条件好的情况下，使用 <code>udp</code></li></ol> <p><code>UDP</code> 适用于 <code>实时应用</code>，例如：视频会议、直播等。<code>TCP</code> 适用于要求 <code>可靠性传输</code> 的应用，例如：文件传输等。</p></li></ul> <h2 id="_5-如何理解-tcp-ip-五层模型-osi-七层模型？"><a href="#_5-如何理解-tcp-ip-五层模型-osi-七层模型？" aria-hidden="true" class="header-anchor">#</a> 5. 如何理解 TCP/IP 五层模型 OSI 七层模型？</h2> <blockquote><p>TCP/IP 五层模型（应、传、网、数、物）</p></blockquote> <ol><li>应用层：最高层，提供特定于应用程序的协议，运行在该层的协议有 HTTP、FTP、SSH、WebSocket 等</li> <li>传输层：为两个主机进程通信提供通用的数据传输协议，如 TCP、UDP</li> <li>网络层：负责寻址和路由功能，将数据包发送到特定的计算机，主要协议是 IP 协议，路由器就是在这一层</li> <li>数据链路层：负责将二进制数据包和网络信号相互转换，交换机、网卡就是在这一层(PPP 协议)</li> <li>物理层：主要有接收器、发送器、中继器、光纤电缆等</li></ol> <blockquote><p>OSI 七层模型（应、表、会、传、网、数、物）</p></blockquote> <ol><li>应用层</li> <li>表示层</li> <li>会话层</li> <li>传输层</li> <li>网络层</li> <li>数据链路层</li> <li>物理层</li></ol> <h2 id="_6-为什么-https-比-http-安全？https-是如何保证安全的？"><a href="#_6-为什么-https-比-http-安全？https-是如何保证安全的？" aria-hidden="true" class="header-anchor">#</a> 6. 为什么 HTTPS 比 HTTP 安全？HTTPS 是如何保证安全的？</h2> <p>HTTPS 在 HTTP 的基础上增加了<code>加密处理</code>、<code>认证机制</code>和<code>完整性保护</code>，我们可以将  <code>HTTPS = HTTP + 加密 + 认证 + 完整性保护</code></p> <ul><li><p>加密</p> <p>因为 <code>HTTP</code> 使用明文传输，中间会经过多个物理节点，可能会被劫持窃听，针对这一问题，<code>HTTPS</code> 采用了加密的方式解决</p> <ol><li><p><strong>对称加密</strong></p> <p>就是拥有一个密钥，在内容被进行加密后，需要用同一个密钥对加密内容进行解密，才能看到原本的内容。可以看作我们日常生活中的钥匙。<strong>注意</strong>：密钥在浏览器和服务器之间传输时，可能被<code>截取</code>，因此引入<code>非对称加密</code></p></li> <li><p><strong>非对称加密</strong></p> <p>非对称加密有两把密钥，通常一把叫做公钥，另外一把叫做私钥。用公钥加密的内容必须用私钥才能解开，同样的，私钥加密的内容需要用公钥才能解开。<code>公钥加密私钥解密（数据加密） 也可用私钥加密公钥解密（签名）</code></p></li> <li><p><strong>改良版非对称加密</strong></p> <p>通过一组公钥、私钥已经能保证单个方向传输的安全性，那用两组公钥私钥是不是就能保证双向传输都安全了（HTTPS 的加密却没有使用这种方案）。<strong>注意</strong>：原因是非对称加密算法<code>非常耗时</code>，特别是加密解密一些较大数据的时候有些力不从心。相反，对称加密就要快很多。</p></li> <li><p><strong>混合加密</strong>（HTTPS 采用这种方式加密）</p> <p><strong>思路</strong>：我们在传递过程把我们的 <code>对称加密</code> 中的 <code>密钥</code> 用 <code>非对称加密</code> 的方式去传递</p> <ul><li><p>“<code>对称加密</code> + <code>非对称加密</code>”结合的形式来实现对 HTTP 的加密</p> <ol><li>客户端生成 <code>会话秘钥</code> 就是我们 <code>对称加密生成的密钥</code></li> <li>它用 <code>公钥加密</code> 之后进行传递(这个时候被加密的不是数据 是这个会话秘钥 等于把钥匙加密了) 这里的 <code>公钥</code> 就是 <code>非对称加密中的公钥</code> 他是由服务器传递过去的（<code>对外公开</code>）</li> <li>服务端用 <code>非对称加密</code> 的 <code>私钥</code> 去 <code>解密</code> 拿到我们的 <code>会话秘钥</code></li> <li>客户端和服务端都能用同一个会话秘钥进行加解密了</li></ol></li></ul></li></ol> <p>就算传输过程被攻击者截取到了被加密的会话秘钥 他没有服务器的私钥是无法得到会话秘钥的。上一步我们已经解决了 <code>数据加密</code> 的问题 虽然攻击者无法 <code>解密数据</code> 但是他可以<strong>篡改数据</strong> 我们怎么知道数据没被动过呢？</p></li> <li><p>认证</p> <ol><li><strong>中间人攻击</strong> <ol><li>某网站拥有用于 <code>非对称加密</code> 的<code>公钥 A</code>、<code>私钥 A</code>；</li> <li>浏览器向网站服务器发起请求，服务器把 <code>公钥 A</code> 明文给传输浏览器；</li> <li><code>中间人劫持到公钥 A，保存下来，把数据包中的公钥 A 替换成自己伪造的公钥 B（它当然也拥有公钥 B 对应的私钥 B’）；</code></li> <li>浏览器随机生成一个用于 <code>对称加密</code> 的 <code>密钥 X</code>，用 <code>公钥 B</code>（浏览器不知道公钥被替换了）加密后传给服务器；</li> <li><code>中间人劫持后用私钥 B’ 解密得到密钥 X，再用公钥 A 将 X 加密后传给服务器；</code></li> <li>服务器拿到后用 <code>私钥 A</code> 解密得到 <code>密钥 X</code>。
<img src="https://s3.51cto.com/images/blog/202106/03/b8077653c5d3239dd98afdeca17927c7.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></li></ol></li></ol> <p>在双方都不会发生异常的情况下，中间人得到了 <code>密钥 X</code>，这其中的根本原因就是<strong>浏览器无法确认自己收到的公钥是不是网站的</strong>, 如何解决这一问题呢？ - <strong>数字证书</strong></p> <ol start="2"><li><p><strong>数字证书</strong>（解决 <code>身份伪装</code> 问题）</p> <p>如何证明浏览器收到的公钥一定是该网站的公钥？</p> <p>这里就需要有一个 <code>公信机构</code> 给网站颁发一个“身份证”了。网站在使用 HTTPS 前，需要向 <code>“CA 机构”</code> 申请颁发一份 <code>数字证书</code>，数字证书里有 <code>证书持有者</code>、<code>证书持有者的公钥</code> 等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如同身份证一样，可以证明“该公钥对应该网站”。</p> <p>然而到这里还是有一个问题，<code>如何保证证书在传输的过程不会被篡改</code>，<strong>身份证本身有防伪的技术</strong>，那么如何保证证书的防伪呢？</p></li> <li><p><strong>数字签名</strong>（解决 <code>数据篡改</code> 问题）</p> <ul><li><p>如何保证证书不被篡改？</p> <p>我们把证书内容生成一份“签名”，比对 <code>证书内容</code> 和 <code>签名</code> 是否一致就能察觉是否被修改，这种技术就称为: <strong>数字签名</strong></p></li> <li><p>数字签名的制作过程？</p> <ol><li>CA 拥有 <code>非对称加密</code> 的 <code>私钥</code> 和 <code>公钥</code>；</li> <li>CA 对证书明文信息进行 <code>Hash</code>；</li> <li>对 <code>Hash</code> 后的值用 <code>私钥</code> 加密，得到 <code>数字签名 S</code>；</li></ol> <p><code>将明文和数字签名共同组成数字证书，这样一份证书就可以颁发给网站了。</code></p></li> <li><p>浏览器得到证书后如何验证这份证书的真实性？</p> <ol><li>拿到服务器发送过来的证书，得到 <code>明文 T</code>，<code>数字签名 S</code>；</li> <li>用 <code>CA 机构</code> 的 <code>公钥</code> 对 <code>S 解密</code>（由于是浏览器信任的机构，所以浏览器保有 CA 的公钥），得到 <code>S</code>‘；</li> <li>浏览器用证书说明的 <code>Hash 算法</code> 对 <code>明文 T</code> 进行 <code>Hash</code> 得到 <code>T</code>；</li> <li>比较 <code>S</code> 是否等于 <code>T</code>，等于则代表证书可信。</li></ol></li> <li><p>浏览器如何得到权威机构的公钥？</p> <p>上面提到，如何要对服务器发过来的证书进行解密，那么就需要到 CA 的公钥，因为其被 CA 的私钥给加密了。那么浏览器是如何拥有 CA 的公钥呢？</p> <p>实际上权威机构的公钥并不需要传输，因为权威机构会和主流的浏览器或操作系统合作，将他们的公钥内置在浏览器或操作系统环境中。客户端收到证书之后，只需要从证书中找到权威机构的信息，并从本地环境中找到权威机构的公钥，就能正确解密 CA 公钥。</p></li> <li><p>中间人有可能篡改证书吗？(<strong>不可以</strong>)</p></li></ul></li></ol></li> <li><p>HTTPS 的请求流程</p> <ol><li>客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口</li> <li>服务器端有一个密钥对，即 <code>公钥</code> 和 <code>私钥</code>，是用来进行非对称加密使用的，服务器端保存着 <code>私钥</code>，不能将其泄露，<code>公钥</code> 可以发送给任何人</li> <li>服务器将自己的 <code>公钥</code> 包含在 <code>权威机构发布的证书</code> 中发送给客户端</li> <li>客户端收到服务器端的 <code>证书</code> 之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么 HTTPS 传输就无法继续。严格的说，这里应该是验证服务器发送的 <code>数字证书</code> 的合法性，关于客户端如何验证数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行 <code>对称加密</code> 的 <code>密钥</code>，我们将该密钥称之为 <code>client key</code>，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束；</li> <li>客户端会发起 HTTPS 中的第二个 HTTP 请求，将被公钥所加密之后的客户端密钥发送给服务器</li> <li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是 <code>客户端密钥</code>，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文</li> <li>然后服务器用对称加密的密钥（即客户端密钥）对报文进行加密，并将加密后的报文发送给客户端</li> <li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成</li></ol> <p><img src="https://s4.51cto.com/images/blog/202106/03/df5c8faaaba3b977afa23a588d9b0b2f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></p></li></ul> <h2 id="_7-http-常见的状态码有哪些？适用的场景？"><a href="#_7-http-常见的状态码有哪些？适用的场景？" aria-hidden="true" class="header-anchor">#</a> 7. HTTP 常见的状态码有哪些？适用的场景？</h2> <ul><li>1.xx: 信息类</li> <li>2.xx: 成功类
<ol><li>【200 OK】：请求成功</li> <li>【204 No Content】: 与 200 基本相同，但响应头没有 body 数据</li> <li>【206 Partial Content】: 应用于 HTTP <code>分块下载</code>或 <code>断点续传</code>。表示响应返回的 body 数据并不是资源的全部，而是其中的一分部</li></ol></li> <li>3.xx: 重定向
<ol><li>【301 Moved Permanently】:永久重定向，说明请求资源不存在了，需改用新的 URL 再次访问</li> <li>【302 Found】:临时重定向，说明请求资源还在，但暂时需要用另一个 URL 来访问</li></ol></li> <li>4.xx: 客户端错误
<ol><li>【400 Bad Request】:表示客户端请求报文有错误</li> <li>【403 Forbidden】: 表示服务器禁止访问资源，并不是客户端请求出错</li> <li>【404 Not Found】:表示请求资源在服务器上不存在或未找到</li></ol></li> <li>5.xx: 服务端错误
<ol><li>【500 Internal Server Error】:与 400 类似，是个笼统的错误码，表示服务器发生了错误</li> <li>【501 No Implement】: 表示客户端请求的功能还不支持</li> <li>【502 Bad Gatwy】:通常服务器作为网关或代理时返回的错误码</li> <li>【503 Service Unavailable】: 表示服务器当前很忙，暂时无法响应</li></ol></li></ul> <h2 id="_8-知道-http-的缓存吗？（浏览器强缓存和协商缓存）"><a href="#_8-知道-http-的缓存吗？（浏览器强缓存和协商缓存）" aria-hidden="true" class="header-anchor">#</a> 8. 知道 HTTP 的缓存吗？（浏览器强缓存和协商缓存）</h2> <p><strong>强缓存</strong>: 是利用 <code>Expires</code>（<code>http1.0</code>）和 <code>Cache-Control</code>（<code>http1.1</code>）这两个字段来控制的，控制资源缓存的时间，在有效期内不会去向服务器请求了，同时存在，优先 <code>Cache-Control</code></p> <ul><li><code>Expires</code> 的值为一个 <code>绝对时间</code>（由于 <code>Expires</code> 是依赖于客户端系统时间，当修改了本地时间后，缓存可能会失效）</li> <li>给 <code>Cache-Control</code> 设置 <code>max-age</code> ，表示缓存的最长时间是多少秒，是一个 <code>相对时间</code>。</li> <li><code>Catch-Control</code> 的值：<code>public</code> 都缓存；<code>private</code> 客服端缓存，服务器不缓存；<code>no-cache</code>：表示不进行强缓存，发送 <code>HTTP</code> 请求，用协商缓存来验证；<code>no-store</code> 所有内容都不缓存；<code>s-maxage</code>：这和 <code>max-age</code> 长得比较像，但是<strong>区别</strong>: 在于 <code>s-maxage</code> 是针对 <code>代理服务器</code> 的缓存时间</li></ul> <p><strong>协商缓存</strong>: 是由服务器来确定缓存资源是否可用，是利用 <code>Last-Modified</code>（<code>http1.0</code>）（表示被请求资源在服务器端的最后一次修改时间）/ <code>If-Modified-Since</code> 和 <code>ETag</code>（每次文件修改后服务端那边会生成一个新的 <code>ETag</code>）/<code>if-None-Match</code> 来控制的，同时存在，优先 <code>ETag</code></p> <ul><li><p><code>Last-Modified/if-Modified-Since</code> 的<strong>缺点</strong>：（文件有可能在 1s 内修改内容、文件内容修改后又复原）</p></li> <li><p><code>ETag</code> 性能上的不足, 只要文件发生改变,<code>ETag</code>就会发生改变. <code>ETag</code>需要服务器通过算法来计算出一个 hash 值</p></li> <li><p>缓存位置</p> <ol><li><code>Service Worker</code> <code>Service Worker</code> 借鉴了 <code>Web Worker</code> 的 思路，即让 <code>JS 运行</code>在 <code>主线程</code> 之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如 <code>离线缓存</code>、<code>消息推送</code> 和 <code>网络代理</code> 等功能。其中的离线缓存就是 <code>Service Worker Cache</code>。</li> <li><code>Memory Cache</code></li> <li><code>Disk Cache</code></li> <li><code>Push Cache</code>（HTTP2）</li></ol></li></ul> <p>浏览器的本地存储主要分为 <code>Cookie</code>、<code>WebStorage</code> 和 <code>IndexedDB</code>, 其中 <code>WebStorage</code> 又可以分为 <code>localStorage</code> 和 <code>sessionStorage</code>。</p> <h2 id="_9-前端错误的分类有哪些？"><a href="#_9-前端错误的分类有哪些？" aria-hidden="true" class="header-anchor">#</a> 9. 前端错误的分类有哪些？</h2> <ul><li>前端错误类型：
<ol><li><code>SyntaxError</code> (语法错误)</li> <li><code>ReferenceError</code> (引用错误)</li> <li><code>TypeError</code> (类型错误)</li> <li><code>RangeError</code> (范围越界错误)</li></ol></li> <li>前端错误分类：
<ol><li>代码执行的错误</li> <li>资源加载的错误</li></ol></li> <li>前端错误捕获：
<ol><li>try...catch
能捕获 <code>同步运行时</code> 错误。不能捕获 <code>语法错误</code>、<code>异步任务错误</code>、<code>promise</code>、<code>资源加载错误</code> 等</li> <li>window.onerror
能捕获所有同步错误、普通的异步错误。不能捕获语法、async 任务、promise 错误和资源加载错误等（例如：iframe）</li> <li>window.addEventListener('error', function() {})
可捕获资源加载错误(如果资源加载错误，说明跨域，添加 crossorigin)</li> <li>window.addEventListener('unhandledrejection', function() {})
捕获 promise 错误（没有写 <code>catch</code> 的 <code>Promise</code> 中抛出的错误无法被 <code>onerror</code> 或 <code>try-catch</code> 捕获到。为了防止有漏掉的 Promise 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>）</li> <li>Vue 项目异常：Vue.config.errorHandler = (err, vm, info) =&gt; {}</li> <li>崩溃和卡顿：利用 <code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code> 事件</li></ol></li> <li>总结：
<ol><li>可疑区域使用： <code>Try...Catch</code></li> <li>全局监控 JS 异常使用：<code>window.onerror</code></li> <li>全局监控静态资源异常使用：<code>window.addEventListener</code></li> <li>捕获没有 catch 的 Promise 异常使用：<code>unhandledrejection</code></li> <li><code>Vue errorHandler</code> 和 <code>React componentDidCatch</code></li> <li>监控网页崩溃和卡顿使用：<code>window</code> 对象的 <code>loader</code> 和 <code>beforeunload</code></li> <li>跨域：添加 <code>crossOrigin</code></li></ol></li> <li>上报方式有哪些：
<ol><li><code>XMLHttpRequest</code>
有跨域限制，携带 cookie 问题；上报请求可能会阻塞业务；请求容易丢失</li> <li><code>Image</code>
可跨域、get 请求，大小限制</li> <li>SendBean</li></ol></li></ul> <h2 id="_10-说说为什么前端会有跨域？如何解决跨域？知道-option-请求吗？"><a href="#_10-说说为什么前端会有跨域？如何解决跨域？知道-option-请求吗？" aria-hidden="true" class="header-anchor">#</a> 10. 说说为什么前端会有跨域？如何解决跨域？知道 option 请求吗？</h2> <p>不同域之间相互请求资源，称为”跨域“；浏览器的 同源策略（同源：<code>url</code> 是由协议、域名、端口和路径等组成。如果两个路径的协议、域名、端口都相同则表示再同一个域上）</p> <p>在浏览器上 <code>script</code>、<code>img</code>、<code>link</code>、<code>iframe</code> 等标签都可以加载跨域资源 且不受同源限制</p> <ul><li><p>非同源限制：</p> <ol><li>无法读取非同源网页的 Cookie、LocalStorage、IndexedDB</li> <li>无法接触非同源网页的 DOM</li> <li>无法向非同源地址发起 ajax 请求</li></ol></li> <li><p>解决跨域的方式：</p> <ol><li><strong>设置 document.domain 解决无法读取非同源网页的 Cookie 问题</strong></li></ol> <p>浏览器是通过 <code>document.domain</code> 属性来检查两个页面是否同源，因此只要通过设置相同的 <code>document.domain</code>，两个页面就可以共享 Cookie。</p> <p><strong>缺点</strong>：此方案仅限主域相同，子域不同的跨域应用场景</p> <ol start="2"><li><strong>JSONP</strong> 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本 IE），</li></ol> <p><strong>缺点</strong>：是只支持 <code>get 请求</code>， 需要后台配合，将返回结果包装成 <code>callback(res)</code>的形式。原理是利用 <code>script</code> 元素的跨域能力</p> <p><strong>核心思想</strong>：网页通过添加一个<code>script</code>元素，向服务器请求 <code>JSON</code> 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来</p> <ul><li><p><code>原生 js 实现</code>【请求地址后面添加?callback=&quot;xxx&quot;,然后在 script 中添加 xxx 方法其参数返回结果】</p></li> <li><p><code>jQuery 的 ajax</code>【dataType: 'jsonp', 请求方式为 jsonp；jsonpCallback: 'handleCallback' 自定义回调函数】</p> <blockquote><p>扩展：</p></blockquote> <ol><li><code>script</code> 的 <code>src</code> 和 <code>img</code> 的 <code>src</code> 跨域的区别？</li></ol> <p>原理上都是利用标签的 <code>src</code> 可绕过同源限制，跨域请求的特点；<strong>区别</strong>在于：<code>img 只能单向发送 get 请求，不可访问响应内容（只是展现），而 script 可对其进行解析</code></p> <ol start="2"><li>如果黑客植入 <code>script</code> 脚本通过 <code>jsonp</code> 的方式对服务器进行攻击，怎么办？</li></ol> <p>可以通过页面设置的<code>内容安全协议 csp</code> 进行防范</p> <ol start="3"><li>为什么 <code>jsonp</code> 只支持 <code>get</code> 请求？</li></ol> <p><code>JSONP</code> 是一种【请求一段 <code>JS 脚本</code>，把执行这段脚本的结果当做数据】的玩法。</p> <p><code>JSONP</code> 的实现原理就是 <code>document.createElement('script')</code> 生成一个 <code>script 标签</code>，然后插 <code>body</code> 里而已。在这里根本没有<code>设置请求格式</code>的余地）. 所以 <code>jsonp</code> 不会对服务器端代码或者内容做更改</p></li></ul> <ol start="3"><li><p><strong>H5 提供的 postMessage</strong></p> <p><code>postMessage</code> 事件发送消息，<code>message</code> 事件接受消息</p></li> <li><p><strong>跨域资源共享 CORS</strong>【常用】</p> <p>浏览器将 <code>CORS</code> 请求分成两类：<code>简单请求</code>和<code>非简单请求</code>；当发出简单请求，只需要在头信息之中增加一个 <code>Origin 字段</code>。当发出 <code>CORS</code> 非简单请求，会在正式通信之前，增加一次 <code>OPTIONS</code> 查询请求，称为&quot;预检&quot;请求（<code>preflight</code>）。</p> <p>设置响应头的 <code>Access-Control-Allow-Origin： *</code></p> <ul><li>扩展：简单请求同时满足的三个条件？
<ol><li>请求方式只能是：<code>GET</code>、<code>POST</code>、<code>HEAD</code></li> <li><code>HTTP</code> 请求头限制这几种字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Last-Event-ID</code></li> <li><code>Content-type</code> 只能取：<code>application/x-www-form-urlencoded</code>(是 Jquery 的 Ajax 请求默认方式)、<code>multipart/form-data</code>、<code>text/plain</code></li></ol></li></ul> <p>预检请求(<code>preflight</code>)：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 <code>HTTP</code> 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就报错。</p> <p><strong>重点</strong>：服务端如何避免每次都发出预检请求？（<code>缓存</code>）</p> <ol><li><code>Access-Control-Max-Age</code> 该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求（全局和局部方式）【常用】</li> <li><code>@CrossOrigin</code> 注解，可细粒度精确到单个请求级别</li></ol></li> <li><p><strong>window.name</strong></p> <p><code>name</code>值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 <code>name</code> 值（2MB）</p></li> <li><p><strong><code>vue</code> 中 <code>proxy</code> 配置本地代理</strong></p> <p><strong>扩展</strong>：说说 <code>Webpack Proxy</code> 工作原理？</p> <p><code>proxy</code> 工作原理实质上是利用 <strong>http-proxy-middleware</strong> 这个 <code>http</code> 代理中间件，实现请求转发给其他服务器</p></li> <li><p><strong>H5 中的 websocket</strong></p></li> <li><p><strong>Nginx 代理</strong></p></li></ol></li></ul> <p><strong>扩展</strong>：跨域请求如何携带 Cookie?</p> <ol><li>前端请求时在 <code>request</code> 对象中配置：<code>withCredentials: true</code></li> <li>服务端在 <code>response</code> 的 <code>header</code> 中配置：<code>Access-Control-Allow-Origin: &quot;http://xxx.com&quot;</code></li> <li>服务器在 <code>response</code> 的 <code>header</code> 中配置：<code>Access-Control-Allow-Credentials: true</code></li></ol> <h2 id="_11-tcp-三次握手-四次挥手（短连接-长连接）？"><a href="#_11-tcp-三次握手-四次挥手（短连接-长连接）？" aria-hidden="true" class="header-anchor">#</a> 11. TCP 三次握手 &amp; 四次挥手（短连接 &amp; 长连接）？</h2> <p>三次握手的主要作用，需要确认双方的两样能力: <code>发送的能力</code>和<code>接收的能力</code> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723de9b8aa08b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p> <p>从最开始双方都处于 <code>CLOSED</code> 状态。然后服务端开始监听某个端口，进入了 <code>LISTEN</code> 状态。</p> <ol><li>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>seq</code>。此时客户端处于 <code>SYN_SEND</code> 状态。</li> <li>服务端接收到，返回 <code>SYN</code> 和 <code>ACK</code>(对应客户端发来的 SYN)，确认号 <code>ack</code>,自己变成了 <code>SYN-REVD</code></li> <li>之后客户端再发送 确认应答 <code>ACK</code> 报文 给服务端，自己变成了 <code>ESTABLISHED</code> 状态；服务端收到 <code>ACK</code> 之后，也变成了 <code>ESTABLISHED</code> 状态。</li></ol> <ul><li><p>为什么不是两次？</p> <p><strong>根本原因</strong>: <code>无法确认客户端的接收能力。</code></p> <ol><li>第一次握手：客户端发送网络包，服务端收到了。服务端就能得出结论：<code>客户端的发送能力</code>、<code>服务端的接收能力</code>是正常的</li> <li>第二次握手：服务端发包，客户端收到了。客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<strong>注意</strong>：此时服务器并不能确认客户端的<code>接收能力是否正常</code></li> <li>第三次握手：客户端发包，服务端收到了。服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ol></li> <li><p>为什么不是四次？</p> <p><strong>三次握手的目的</strong>: 是确认双方<code>发送</code>和<code>接收</code>的能力，四次也可以。没必要</p></li> <li><p>什么是半连接队列？</p> <p>三次握手前，服务端的状态从 <code>CLOSED</code> 变为 <code>LISTEN</code>, 同时在内部创建了两个队列：<code>半连接队列</code> 和 <code>全连接队列</code>，即 <code>SYN 队列</code> 和 <code>ACCEPT 队列</code>。</p> <p><strong>半连接队列</strong>: 当客户端发送 <code>SYN</code> 到服务端，服务端收到以后回复 <code>ACK</code> 和 <code>SYN</code>，状态由 <code>LISTEN</code> 变为 <code>SYN_RCVD</code>，此时这个连接就被推入了 <code>SYN 队列</code>，也就是 <code>半连接队列</code>。</p> <p><strong>全连接队列</strong>: 就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现 <code>丢包</code> 现象。</p> <p><strong>补充一点</strong> 关于 <code>SYN-ACK</code> 重传次数的问题：</p> <p>服务器发送完 <code>SYN-ACK 包</code>，如果未收到客户确认包，服务器进行 <code>首次重传</code>，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p></li> <li><p>三次握手过程中可以携带数据么？</p> <p><code>第三次握手的时候，可以携带。前两次握手不能携带数据</code>。</p> <p>(假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 <code>SYN 报文</code>中放入大量的数据。这会让服务器花费很多时间、内存空间来接收这些报文。原因就是会让服务器更加容易受到攻击了)</p></li> <li><p><code>SYN 攻击</code> 是什么?</p> <p><strong>SYN 攻击</strong>: 就是 <code>Client</code> 在短时间内伪造大量不存在的 <code>IP 地址</code>，并向 <code>Server</code> 不断地发送 <code>SYN 包</code>，<code>Server</code> 则回复确认包，并等待 <code>Client</code> 确认，由于源地址不存在，因此 <code>Server</code> 需要不断重发直至超时，这些伪造的 <code>SYN 包</code> 将长时间占用<code>未连接队列</code>，导致正常的 <code>SYN</code> 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<code>SYN 攻击</code> 是一种典型的 <code>DoS/DDoS 攻击</code>。</p> <p>在 <code>Linux/Unix</code> 上可以使用系统自带的 <code>netstats</code> 命令来检测 <code>SYN 攻击</code>。<code>netstat -n -p TCP | grep SYN_RECV</code></p> <ul><li>常见的防御 <code>SYN 攻击</code> 的方法有如下几种：
<ol><li>缩短超时（<code>SYN Timeout</code>）时间</li> <li>增加最大半连接数</li> <li>过滤网关防护</li> <li><code>SYN cookies</code> 技术</li></ol></li></ul></li> <li><p><code>TCP</code> 的半关闭（<code>half-close</code>）</p> <p>所谓的<strong>半关闭</strong>，其实就是 <code>TCP</code> 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p></li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723e5c0e05829~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p> <p>刚开始双方处于 <code>ESTABLISHED</code> 状态</p> <ul><li><p>客户端要断开了，向服务器发送 <code>FIN 报文</code>，发送后客户端变成了 <code>FIN-WAIT-1</code> 状态。
<strong>注意</strong>, 这时候客户端同时也变成了 <code>half-close</code>(半关闭)状态，即无法向服务端发送报文，只能接收。</p> <ul><li>关闭 <code>TCP 连接</code>的挥手，客户端和服务端都可以发起关闭操作，以客户端发起为例:
<ol><li>浏览器先发送 <code>FIN 报文</code>、<code>Seq</code> 初始化序列号给服务器，并停止发送数据，但仍可以接受服务端响应的数据</li> <li>服务器收到后，发送 <code>ACK=浏览器序列号+1</code> 给浏览器，表明收到</li> <li>服务器数据都发完了，给浏览器发送 <code>FIN 报文</code>、<code>Seq</code> 序列号给浏览器</li> <li>浏览器收到后，发送 <code>ACK=服务器序列号+1</code> 给服务器，表明收到</li></ol></li></ul></li> <li><p>为什么是 <code>四次挥手</code> 而不是 <code>三次</code>？</p> <p>因为服务端在接收到 <code>FIN</code>, 往往不会立即返回 <code>FIN</code>, 必须等到服务端所有的报文都发送完毕了，才能发 <code>FIN</code>。因此先发一个 <code>ACK</code> 表示已经收到客户端的 <code>FIN</code>，延迟一段时间才发 <code>FIN</code>。这就造成了 <code>四次挥手</code>。</p> <ul><li>如果是 <code>三次挥手</code> 会有什么问题？</li></ul> <p>(等于说服务端将 <code>ACK</code> 和 <code>FIN</code> 的发送合并为一次挥手，这个时候 <code>长时间的延迟</code> 可能会导致客户端误以为 <code>FIN</code> 没有到达客户端，从而让客户端不断的重发 <code>FIN</code>。)</p></li> <li><p>等待 <code>2MSL</code> 的意义(为什么要等一段时间再关闭，不等不行吗？)</p> <p>这是为了防止发送给服务器的确认报文段 <code>丢失</code> 或者 <code>出错</code>，从而导致服务端不能正常关闭。等待时间是 <code>2MSL</code>，这也是报文在网络上的最大生存时间，超过这个时间就会被丢弃。<code>RFC793</code> 中规定 <code>MSL</code> 为 2 分钟，如果超过这个时间，那么主动关闭者就会发送一个 <code>RST</code> 状态位的包，表示 <code>重置连接</code>，这时候被关闭者就知道对方已经关闭了连接。</p></li></ul> <h2 id="_12-知道第三方-cookie-吗？"><a href="#_12-知道第三方-cookie-吗？" aria-hidden="true" class="header-anchor">#</a> 12. 知道第三方 Cookie 吗？</h2> <ul><li><p><code>cookie</code> 由哪些部分组成：</p> <ol><li><code>Name</code>: 这个属性就表示 <code>cookie</code> 的名字，每个 <code>cookie</code> 的名字都是唯一的</li> <li><code>Value</code>: 这个属性表示 <code>cookie</code> 的值</li> <li><code>Domain</code>: 就是 <code>cookie</code> 所在的域名，如果没有设置 <code>domain</code> 的话，那么 <code>cookie</code> 会自动绑定到执行语句的当前域</li> <li><code>Path</code>: 这个属性的默认值是/，匹配的是路由，这里匹配的是路由的意思就是比如你的域名是 <code>www.xxx.xyz</code>,那么路由如果是 <code>www.xxx.xyz/auth/</code>,那么实际上 <code>cookie</code> 绑定的是这个 <code>/auth</code></li> <li><code>Max-age</code>: 这个属性是 <code>http1.1</code> 新增的属性，用来替代 <code>expires</code> 的，单位是秒，用来表示 <code>cookie</code> 在多少秒之后会失效</li> <li><code>Secure</code>: 因为 <code>http</code> 是无状态协议，而且 <code>http</code> 在传输数据的过程中是以明文传输的，因此很容易遭到第三方网站的窃取，如果我们使用 <code>secure</code> 的话，就能够确保 <code>cookie</code> 是在 <code>https</code> 协议下进行传输的，但是这不代表会将 <code>cookie</code> 加密</li> <li><code>HttpOnly</code>: 只能通过 <code>HTTP</code> 协议传输，不能通过 <code>JS 访问</code>。这个属性表示不能够被 <code>js 脚本</code>访问，因为 <code>js</code> 能够通过 <code>document.cookie</code> 来获取 <code>cookie</code>，所以使用 <code>HttpOnly</code> 就能够阻止这种情况，在一定程度上防止 <code>xss 攻击</code>，也就是 <code>跨站脚本攻击</code></li> <li><code>SameSite</code>: 用于限制第三方网站的 <code>cookie</code> 发送机制(<code>cookie</code> 每次随着请求会自动发送到服务器去的，这就给了其他站点发起 <code>CSRF 攻击</code> 和用户追踪的机会)
<strong>具体如下</strong>：
<ol><li><code>Strict</code>: 最严格的模式，完全禁止跨站点请求时携带 <code>cookie</code>，设置为 <code>strict</code> 之后，跨站行为都不会再携带 <code>cookie</code></li> <li><code>Lax</code>: 相对 <code>strict 模式</code> 会宽松一点儿，允许导航到三方网站时携带 <code>cookie</code>，即 <code>a 标签跳转</code>，<code>form 表单的 get 提交</code>，以及 <code>link 标签的 prerender</code></li> <li><code>None</code>: 使用 <code>None</code> 显示的关闭 <code>SameSite</code> 模式控制，但是需要注意的是还需要加上 <code>secure</code>，即 <code>cookie</code> 只会在 <code>HTTPS</code> 中发送，如果只是设置了 <code>SameSite=None</code> 是没有效果的</li></ol></li></ol></li> <li><p><code>Cookie</code> 的分类：</p> <p><strong>第一方 Cookie</strong> 和 <strong>第三方 Cookie</strong>，这两类 <code>Cookie</code> 都是网站保存在用户电脑上的一个文件，它们都由某个特定的域创建，并且只能被这个域访问</p> <p><code>第一方 Cookie</code> 是由地址栏中列出的网站域设置的 <code>Cookie</code>，而 <code>第三方 Cookie</code> 来自在网页上嵌入广告或图片等项的其他域来源。都是网站在客户端上存放的一小块数据。他们都由某个域存放，只能被这个域访问。</p> <p>他们的区别其实并不是<strong>技术上</strong>的区别，而是<strong>使用方式上</strong>的区别。</p></li> <li><p><code>Cookie</code> 的特性：</p> <ol><li><strong>生命周期</strong>: <code>Expires</code>(过期时间) 和 <code>Max-Age</code>(单位秒)设置</li> <li><strong>作用域</strong>: <code>Domain</code> 和 <code>Path</code> 设置。<strong>注意</strong>：<code>/</code>表示域名下的任何路径都允许使用 <code>Cookie</code></li> <li><strong>安全相关</strong> <ol><li>如果带上 <code>Secure</code>，说明只能通过 <code>HTTPS</code> 传输 <code>cookie</code></li> <li>如果 <code>cookie</code> 字段带上 <code>HttpOnly</code>，说明只能通过 <code>HTTP</code> 协议传输，不能通过 <code>JS 访问</code>。也是预防 <code>XSS 攻击</code> 重要手段</li> <li><code>SameSite</code> 属性有 <code>Strict</code>、<code>Lax</code>、<code>None</code>(默认)。也是预防 <code>CSRF 攻击</code> 的重要手段</li></ol></li></ol></li> <li><p><code>Cookie</code> 的缺点：</p> <ol><li><strong>容量缺陷</strong>：<code>Cookie</code> 的体积上限只有 <code>4KB</code>，只能用来存储少量的信息</li> <li><strong>性能缺陷</strong>：<code>Cookie</code> 紧跟域名，不管域名下面的某一个地址需不需要这个 <code>Cookie</code> ，请求都会携带上完整的 <code>Cookie</code>，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 <code>Domain</code> 和 <code>Path</code> 指定 <code>作用域</code> 来解决。</li> <li><strong>安全缺陷</strong>。由于 <code>Cookie</code> 以 <code>纯文本</code> 的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 <code>Cookie</code> 的有效期内重新发送给服务器，这是相当危险的。另外，在 <code>HttpOnly</code> 为 <code>false</code> 的情况下，<code>Cookie</code> 信息能直接通过 <code>JS 脚本</code> 来读取。</li></ol></li></ul> <h2 id="_13-csrf-和-xss-、ssrf-的攻击原理-与防御措施？"><a href="#_13-csrf-和-xss-、ssrf-的攻击原理-与防御措施？" aria-hidden="true" class="header-anchor">#</a> 13. CSRF 和 XSS 、SSRF 的攻击原理 与防御措施？</h2> <p><code>CSRF</code>（<code>Cross-site request forgery</code>）：<strong>跨站请求伪造</strong>: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式</p> <ul><li><code>CSRF</code> 的攻击原理</li></ul> <p><img src="http://img.smyhvae.com/20180307_1735.png" alt></p> <p>从上图可以看出，要完成一次 <code>CSRF 攻击</code>，受害者必须满足 <code>两个必要的条件</code>：</p> <ol><li>登录受信任 <code>网站 A</code>，并在本地生成 <code>Cookie</code>。（如果用户没有登录 <code>网站 A</code>，那么<code>网站 B</code> 在诱导的时候，请求<code>网站 A</code> 的 <code>api 接口</code> 时，会提示你登录）</li> <li>在不登出 <code>A</code> 的情况下，访问危险网站 <code>B</code>（其实是利用了 ∂<code>网站 A</code> 的漏洞）</li></ol> <p><strong>温馨提示一下</strong>：<code>cookie</code> 保证了用户可以处于登录状态，但<code>网站 B</code> 其实拿不到 <code>cookie</code></p> <ul><li><p><code>CSRF</code> 如何防御</p> <ol><li><p>方法一、<code>Token</code> 验证：（用的最多）</p> <p>服务器发送给客户端一个 <code>token</code>；客户端提交的表单中带着这个 <code>token</code>。如果这个 <code>token</code> 不合法，那么服务器拒绝这个请求。</p></li> <li><p>方法二、<code>隐藏令牌</code>：</p> <p>把 <code>toke</code>n 隐藏在 <code>http</code> 的 <code>head</code> 头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p></li> <li><p>方法三、<code>Referer</code> 验证：</p> <p><code>Referer</code> 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</p></li></ol></li></ul> <p><code>XSS</code>（<code>Cross Site Scripting</code>）：<strong>跨域脚本攻击</strong>: 是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式</p> <ul><li><p><code>XSS</code> 的攻击原理</p> <p><code>XSS 攻击</code> 的<strong>核心原理</strong>是：不需要你做任何的登录认证，它会通过合法的操作（比如在 <code>url 中输入</code>、在 <code>评论框中输入</code>），向你的页面注入脚本（可能是 <code>js</code>、<code>html 代码块</code>等）。导致：盗用 <code>Cookie</code>、破坏页面的正常结构，插入广告等恶意内容、D-doss 攻击</p></li> <li><p><code>XSS</code> 的攻击方式</p> <ol><li><p><strong>反射型</strong></p> <p>发出请求时，<code>XSS 代码</code> 出现在 <code>url</code> 中，作为输入提交到服务器端，服务器端解析后响应，<code>XSS 代码</code> 随响应内容一起传回给浏览器，最后浏览器解析执行 <code>XSS</code> 代码。这个过程像一次反射，所以叫<code>反射型 XSS</code></p></li> <li><p><strong>存储型</strong></p> <p><code>存储型 XSS</code> 和 <code>反射型 XSS</code> 的<strong>差别在于</strong>，提交的代码会存储在服务器端（<code>数据库</code>、<code>内存</code>、<code>文件系统</code>等），下次请求时目标页面时不用再提交 <code>XSS 代码</code></p></li></ol></li> <li><p><code>XSS</code> 的防范措施（<code>encode</code> + <code>过滤</code>）</p> <ol><li><p>方法一、<code>编码</code></p> <p>对用户输入的数据进行 <code>HTML Entity</code> 编码;把字符转换成 转义字符</p></li> <li><p>方法二、<code>过滤</code></p> <p>移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（<strong>总而言之</strong>，过滤掉一些不安全的内容）
移除用户输入的 <code>Style 节点</code>、<code>Script 节点</code>、<code>Iframe 节点</code>。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）</p></li> <li><p>方法三、<code>校正</code></p> <p>避免直接对 <code>HTML Entity</code> 进行解码; 使用 <code>DOM Parse</code> 转换，校正不配对的 <code>DOM</code> 标签</p></li></ol></li> <li><p><code>CSRF</code> 和 <code>XSS</code> 的区别:</p> <ol><li><strong>CSRF</strong>：需要用户先登录 <code>网站 A</code>，获取 <code>cookie</code>; <strong>XSS</strong>：不需要登录</li> <li><code>CSRF</code>：是利用<code>网站 A</code> 本身的漏洞，去请求 <code>网站 A</code> 的 <code>api</code>;<strong>XSS</strong>：是向 <code>网站 A</code> 注入 <code>JS 代码</code>，然后<code>执行 JS</code> 里的代码，篡改 <code>网站 A</code> 的内容</li></ol></li> <li><p>SSRF</p></li></ul> <p><strong>扩展</strong>：<code>v-html</code> 的弊端？（利用 <code>innerHTML</code>）</p> <ol><li>可能会导致 <code>xss 攻击</code></li> <li><code>v-html</code> 会替换掉标签内部的子元素</li></ol> <h2 id="_14-v8-中执行一段-js-代码的整个过程"><a href="#_14-v8-中执行一段-js-代码的整个过程" aria-hidden="true" class="header-anchor">#</a> 14. V8 中执行一段 JS 代码的整个过程</h2> <ol><li>首先通过 <code>词法分析</code> 和 <code>语法分析</code> 生成 <code>AST</code> <ul><li><strong>词法分析</strong> 即 <code>分词</code>，它的工作就是将一行行的代码分解成一个个 <code>token</code>。</li> <li><strong>语法分析</strong> ，将生成的这些 <code>token</code> 数据，根据一定的语法规则转化为 <code>AST</code>。</li></ul></li> <li>将 <code>AST</code> 转换为 <code>字节码</code></li> <li>由 <code>解释器</code> 逐行执行 <code>字节码</code> ，遇到<code>热点代码</code>启动<code>编译器</code>进行编译，生成对应的<code>机器码</code>, 以优化执行效率
（现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。）</li></ol> <p><strong>注意</strong>：因为机器码相比字节码的体积太大，引发了严重的内存占用问题。机器只认识机器码</p> <p><code>JS 运行</code>可以分为 <strong>编译阶段</strong> 和 <strong>执行阶段</strong></p> <ul><li><p><strong>函数体内</strong> 的 <code>编译</code> 四步曲，发生在函数 <code>执行之前</code>:</p> <ol><li>创建 <code>AO</code> 对象, (<code>activation object</code>)</li> <li>找<code>形参</code>和<code>变量</code>声明，将形参和变量声明作为 <code>AO</code> 对象的属性名，值为 <code>undefined</code></li> <li>将<code>实参</code>和<code>形参</code>相统一</li> <li>在函数体里找函数声明，将函数名作为 <code>AO</code> 对象的属性名，值赋予函数体</li></ol></li> <li><p><strong>全局下</strong> 的 <code>编译</code> 三步曲，发生在代码 <code>最前面</code>:</p> <ol><li>创建 <code>GO</code> 对象</li> <li>找变量声明，将变量声明作为 <code>GO</code> 对象的属性名，值赋予 <code>undefined</code></li> <li>找全局里的函数声明，将函数名作为 <code>GO</code> 对象的属性名，值赋予函数体</li></ol></li></ul> <h2 id="_14-从输入-url-到页面展示经历了什么？"><a href="#_14-从输入-url-到页面展示经历了什么？" aria-hidden="true" class="header-anchor">#</a> 14. 从输入 URL 到页面展示经历了什么？</h2> <ul><li><p>总体流程如下：</p> <ol><li><p>URL 解析
完整的 URL：<code>协议 + 主机 + 端口 + 路径 + 参数 + 锚点</code>。如果为非 url 结构的字符串，交给浏览器默认引擎去搜索改字符串；若为 url 结构的字符串，浏览器主进程会交给 网络进程 ,开始干活。</p> <ul><li>encodeURI 和 encodeURIComponent 的区别？
encodeURI 是编码<code>整个URL</code>，而 encodeURIComponent 编码的是<code>参数</code>部分</li></ul></li> <li><p>检查资源缓存
在有效期内的缓存资源直接使用，称之为<code>强缓存</code>。返回 200，size 为 memory cache(资源从内存中取出)和 disk cache(资源从磁盘中取出)。当超过有效期的，则携带缓存的资源标识向服务器发起请求。返回 304，走<code>协商缓存</code>;返回 200,向服务器发起请求，将结果缓存起来，为下一次使用
<strong>通常来说</strong>：刷新页面会使用<code>内存缓存</code>; 关闭后重新打开会使用<code>磁盘缓存</code></p></li> <li><p>DNS 解析：将域名解析成 IP 地址
如果没有成功使用本地缓存，则需要发起网络请求，发起之前要做 DNS 解析，会依次搜索：<code>浏览器DNS缓存 -&gt; 操作系统DNS缓存 -&gt; 路由器DNS缓存 -&gt; 服务商DNS服务器查询 -&gt; 全球13台根域名服务器查询</code></p> <p>解析域名的查找过程：浏览器的 DNS 缓存 -&gt; 操作系统的 DNS 缓存 -&gt; 本地域名服务器(<strong>递归查询自己的 DNS 缓存</strong>) -&gt; 上级域名服务器(<strong>进行迭代查询</strong>)【本地域名服务器 -&gt; 根域名服务器(会返回顶级域名的服务器地址); 本地域名服务器 -&gt; 顶级域名服务器(返回权威域名服务器地址，全球 13 台) 】 -》解析到的 IP 地址返回给操作系统，并缓存起来。-》操作系统将 IP 地址返回给浏览器，并缓存起来，供下次使用。</p> <p>为了节约时间，可以在 HTML 头部做 DNS 的预解析：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 在HTTPS下开启 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://www.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>为了保证响应的及时，DNS 解析使用的是 UDP 协议。浏览器根据自定义的规则，提前去解析后面可能用到的域名，来加速网站的访问速度。</p> <p><strong>注意</strong>：a 标签的 href 是可以在 chrome。firefox 包括高版本的 IE，但是在 HTTPS 下面不起作用，需要 meta 来强制开启功能。</p></li> <li><p>TCP 连接：TCP 三次握手</p> <ul><li><p>三次握手过程：</p> <ol><li>客户端发送一个带 SYN=1, Seq=X 的数据包到服务器（第一次握手，由浏览器发起，告诉服务器，我要发送请求了）</li> <li>服务器返回一个带 SYN=1, Ack=X+1, Seq=Y 的响应包确认信息给浏览器（第二次握手，由服务器发起，告诉浏览器我准备好了，你发吧）</li> <li>客户端回传一个带 ACK=Y+1, Seq=Z 的数据包，代表”握手结束“（第三次握手，由浏览器发起，告诉浏览器，我马上就发了，准备接受吧）</li></ol> <p><strong>扩展</strong>：为啥要三次握手？<strong>目的</strong>：为了防止已失效的连接请求报文突然又传送到服务器，因而产生错误。</p></li></ul></li> <li><p>发送 HTTP 请求</p></li> <li><p>服务器处理请求并返回 HTTP 报文</p></li> <li><p>浏览器解析并渲染页面</p></li> <li><p>断开 TCP 连接：TCP 四次挥手</p> <ul><li>四次挥手过程：
<ol><li>主动方发送一个 Fin=1 结束标志位，Ack=Z 组成的报文，并发送 Seq=X 序列号。并进入到 FIN_WAIT_1 状态（第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧）</li> <li>被动方发送 ACK=X+1 确认标志位报文，并发送 Seq=Z 的序列号。表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 阶段。（第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧）</li> <li>被动方发送 Fin=1 结束标志位，Ack=X 组成的报文，并发送 Seq=Y 的序列号。进入 LAST_ACK 状态(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li> <li>发送方发送 ACK=Y 确认标志位报文，并发送 Seq=Z 的序列号。进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ol></li></ul></li></ol></li></ul> <h2 id="_15-说说浏览器渲染原理？"><a href="#_15-说说浏览器渲染原理？" aria-hidden="true" class="header-anchor">#</a> 15. 说说浏览器渲染原理？</h2> <p>整个渲染流程，从 <code>HTML</code> 到 <code>DOM</code>、<code>样式计算</code>、<code>布局</code>、<code>图层</code>、<code>绘制</code>、<code>光栅化</code>、<code>合成</code>和<code>显示</code></p> <ul><li><p>解析 <code>HTML</code>，生成 <code>DOM</code> 树。解析 <code>CSS</code>，生成 <code>CSSOM</code> 树</p> <p>浏览器从磁盘或网络读取 <code>HTML</code> 的原始字节，并根据文件的指定编码（例如 <code>UTF-8</code>）将它们转换成字符串。</p> <p><strong>DOM 树构建步骤</strong>：<code>字节数据</code> =》<code>字符串</code> =》 <code>Token</code> =&gt; <code>Node</code>(节点对象) =》 <code>DOM</code></p> <p>生成节点对象并构建 <code>DOM</code>，每个 <code>Token</code> 被生成后，会立刻消耗这个 <code>Token</code> 创建出节点对象。<strong>注意</strong>：带有结束标签标识的 Token 不会创建节点对象。</p> <ul><li><p>关于 <code>CSS 样式</code>，它的来源一般是三种:</p> <ol><li><code>link 标签</code> 引用</li> <li><code>style 标签</code> 中的样式</li> <li>元素的<code>内嵌 style 属性</code></li></ol></li> <li><p><strong>格式化样式表</strong>：首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 <code>CSS 文本</code> 之后第一件事情就是将其转化为一个结构化的对象，即 <code>styleSheets</code></p></li> <li><p><strong>标准化样式属性</strong>：有一些 <code>CSS 样式</code> 的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如 <code>em-&gt;px</code>,<code>red-&gt;#ff0000</code>, <code>bold-&gt;700</code> 等等。</p></li> <li><p><strong>计算每个节点的具体样式</strong>：样式已经被 <code>格式化</code> 和 <code>标准化</code>, 接下来就可以计算每个节点的具体样式信息了。计算的方式也并不复杂，主要就是两个规则: <strong>继承</strong>和<strong>层叠</strong>。</p> <ol><li>每个子节点都会默认 <code>继承父节点</code> 的样式属性，如果父节点中没有找到，就会采用 <code>浏览器默认样式</code>，也叫 <code>UserAgent 样式</code>。这就是 <strong>继承规则</strong></li> <li>然后是 <code>层叠规则</code>，<code>CSS</code> 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果
<strong>注意</strong>：在计算完样式之后，所有的样式值会被挂在到 <code>window.getComputedStyle</code> 当中，也就是可以通过 <code>JS</code> 来获取计算后的样式</li></ol></li></ul></li> <li><p>将 <code>DOM 树</code> 和 <code>CSS 树</code> 结合，生成 <code>渲染/布局树</code>（<code>Render Tree</code>）
Chrome 团队已经做了大量的重构，已经没有生成 <code>Render Tree</code> 的过程了。而布局树的信息已经非常完善，完全拥有 <code>Render Tree</code> 的功能。</p> <ul><li><code>布局树</code> 生成的大致工作如下:
<ol><li>遍历生成的 <code>DOM 树</code> 节点，并把他们添加到布局树中。</li> <li>计算布局树节点的坐标位置。</li></ol></li></ul></li> <li><p><code>Layout</code> (回流)：根据生成的渲染树，进行 <code>回流</code>（Layout）,得到节点的几何信息（位置、大小）</p></li> <li><p><code>Painting</code> (重绘)：根据渲染树以及回流得到节点的几何信息，从而得到节点的绝对像素</p></li> <li><p><code>Display</code>：将像素发送给 <code>GPU</code>。展示在页面上</p></li></ul> <p><strong>注意</strong>：渲染树只包含<strong>可见的</strong>节点</p> <p><strong>扩展</strong>：为了构建渲染树，浏览器主要完成了以下工作：</p> <ol><li><p>从 <code>DOM 树</code> 的根节点开始遍历每个 <code>可见节点</code></p></li> <li><p>对于每个可见的节点，找到 <code>CSSOM 树</code> 中对于的规则，并应用它们</p></li> <li><p>根据每个可见节点以及其对应的样式，组合生成渲染树</p> <ul><li>不可见的节点包括：
<ol><li>一些不会渲染输出的节点：如：<code>script</code>、<code>link</code>、<code>meta</code> 等</li> <li>一些通过 <code>CSS</code> 进行隐藏的节点：如：<code>display: none</code></li></ol></li></ul></li></ol> <p><strong>注意</strong>：利用 <code>visible</code> 和 <code>opacity</code> 隐藏节点，还是会显示在渲染树上的</p> <p><strong>分层</strong>：渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。完成图层树的构建后，渲染引擎会对图层树中的每个图层进行绘制，为图层绘制。然后进行栅格化（raster）操作（绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的），最后合成与显示。</p> <p><strong>扩展</strong>：CSS 加载会阻塞页面显示吗？</p> <ol><li>css 加载不会阻塞 DOM 树的解析</li> <li>css 加载会阻塞 DOM 树的渲染</li> <li>css 加载会阻塞后面 js 语句的执行</li></ol> <p>so, 为了防止 css 阻塞，引起页面白屏，可以提高页面加载速度:</p> <ol><li>使用 cdn</li> <li>对 css 进行压缩</li> <li>合理利用缓存</li> <li>减少 http 请求，将多个 css 文件合并</li></ol> <h2 id="_16-前端需要注意哪些-seo？"><a href="#_16-前端需要注意哪些-seo？" aria-hidden="true" class="header-anchor">#</a> 16. 前端需要注意哪些 SEO？</h2> <ol><li>合理的 <code>title</code>、<code>description</code>、<code>keywords</code></li> <li>语义化 <code>HTML 代码</code></li> <li>重要内容 <code>HTML 代码</code> 放在前面（搜索引擎抓取 <code>HTML</code> 顺序是从上到下），不要用 <code>js 输出</code>（爬虫不会执行 js）</li> <li>少用 <code>iframe</code>（搜索引擎不会抓取 `iframe 中的内容）</li> <li>非装饰性图片必须加 <code>alt</code></li> <li>提高网站速度（网站速度是搜索引擎排序的一个重要指标）</li></ol> <h2 id="_17-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#_17-什么是堆？什么是栈？它们之间有什么区别和联系？" aria-hidden="true" class="header-anchor">#</a> 17. 什么是堆？什么是栈？它们之间有什么区别和联系？</h2> <p>堆和栈的概念存在于<code>数据结构</code>中和<code>操作系统内存</code>中。</p> <ul><li>在数据结构中，栈中数据的存取方式为 <code>先进后出</code>。而堆是一个<code>优先队列</code>，是按优先级来进行排序的，优先级可以按照大小来规定。完全 二叉树是堆的一种实现方式。</li> <li>在操作系统中，内存被分为<code>栈区</code>和<code>堆区</code>。栈区内存由<code>编译器自动分 配释放</code>，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由<code>程序员分配释放</code>，若程序员不释放，程序结束时可能由<code>垃圾回收机制回收</code>。</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/chapter16/webpack.html" class="prev">
          Webpack 部分
        </a></span> <span class="next"><a href="/chapter16/algorithm.html">
          算法部分
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.c45b4ff4.js" defer></script><script src="/assets/js/70.e4e45ab1.js" defer></script>
  </body>
</html>
