<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. Vue3 和 Vue2 有哪些区别？ | 技术博客文章总结</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.c45b4ff4.js" as="script"><link rel="preload" href="/assets/js/76.e4dddf5f.js" as="script"><link rel="prefetch" href="/assets/js/10.9cdf722f.js"><link rel="prefetch" href="/assets/js/100.9b45b75e.js"><link rel="prefetch" href="/assets/js/101.95c4d653.js"><link rel="prefetch" href="/assets/js/102.09cdc274.js"><link rel="prefetch" href="/assets/js/103.985d4863.js"><link rel="prefetch" href="/assets/js/104.66cfb550.js"><link rel="prefetch" href="/assets/js/105.78c4c309.js"><link rel="prefetch" href="/assets/js/106.34be9d25.js"><link rel="prefetch" href="/assets/js/107.0df352d3.js"><link rel="prefetch" href="/assets/js/108.901d6014.js"><link rel="prefetch" href="/assets/js/109.76339f5d.js"><link rel="prefetch" href="/assets/js/11.d22cc24d.js"><link rel="prefetch" href="/assets/js/110.c6e9ec88.js"><link rel="prefetch" href="/assets/js/111.d390a797.js"><link rel="prefetch" href="/assets/js/112.cf502784.js"><link rel="prefetch" href="/assets/js/113.aa449169.js"><link rel="prefetch" href="/assets/js/114.fc2133ce.js"><link rel="prefetch" href="/assets/js/115.523542e3.js"><link rel="prefetch" href="/assets/js/116.c3507815.js"><link rel="prefetch" href="/assets/js/117.23b5b1f0.js"><link rel="prefetch" href="/assets/js/118.5df8c262.js"><link rel="prefetch" href="/assets/js/119.8e1342c2.js"><link rel="prefetch" href="/assets/js/12.636890c7.js"><link rel="prefetch" href="/assets/js/120.01f21153.js"><link rel="prefetch" href="/assets/js/121.7b546d27.js"><link rel="prefetch" href="/assets/js/122.bd8c0286.js"><link rel="prefetch" href="/assets/js/123.f4f16ed2.js"><link rel="prefetch" href="/assets/js/124.ab5935d4.js"><link rel="prefetch" href="/assets/js/125.b29cf321.js"><link rel="prefetch" href="/assets/js/126.ddf1b9eb.js"><link rel="prefetch" href="/assets/js/127.4d63b823.js"><link rel="prefetch" href="/assets/js/128.f63c61cb.js"><link rel="prefetch" href="/assets/js/129.e74fb4b4.js"><link rel="prefetch" href="/assets/js/13.74a454d8.js"><link rel="prefetch" href="/assets/js/130.05f02f04.js"><link rel="prefetch" href="/assets/js/131.bac5f9b9.js"><link rel="prefetch" href="/assets/js/132.a98fffcf.js"><link rel="prefetch" href="/assets/js/133.5b34ebb6.js"><link rel="prefetch" href="/assets/js/14.ffe8d211.js"><link rel="prefetch" href="/assets/js/15.1bcc034f.js"><link rel="prefetch" href="/assets/js/16.87d6c8f3.js"><link rel="prefetch" href="/assets/js/17.576aa97e.js"><link rel="prefetch" href="/assets/js/18.8c80ffa6.js"><link rel="prefetch" href="/assets/js/19.bd2abc77.js"><link rel="prefetch" href="/assets/js/2.0379b669.js"><link rel="prefetch" href="/assets/js/20.56b31195.js"><link rel="prefetch" href="/assets/js/21.81d1d011.js"><link rel="prefetch" href="/assets/js/22.b52a1bed.js"><link rel="prefetch" href="/assets/js/23.76785e7d.js"><link rel="prefetch" href="/assets/js/24.4bcce340.js"><link rel="prefetch" href="/assets/js/25.b2de599f.js"><link rel="prefetch" href="/assets/js/26.944ed78e.js"><link rel="prefetch" href="/assets/js/27.0bbcee1a.js"><link rel="prefetch" href="/assets/js/28.223ed5b6.js"><link rel="prefetch" href="/assets/js/29.b88c0c25.js"><link rel="prefetch" href="/assets/js/3.b3231975.js"><link rel="prefetch" href="/assets/js/30.5754e2d0.js"><link rel="prefetch" href="/assets/js/31.038ca76a.js"><link rel="prefetch" href="/assets/js/32.7f0c55a6.js"><link rel="prefetch" href="/assets/js/33.7fd80664.js"><link rel="prefetch" href="/assets/js/34.8dcb3109.js"><link rel="prefetch" href="/assets/js/35.8b1fdc43.js"><link rel="prefetch" href="/assets/js/36.cf886fc0.js"><link rel="prefetch" href="/assets/js/37.f7abfe5d.js"><link rel="prefetch" href="/assets/js/38.f63c0deb.js"><link rel="prefetch" href="/assets/js/39.9b06b340.js"><link rel="prefetch" href="/assets/js/4.c1de1412.js"><link rel="prefetch" href="/assets/js/40.490eed30.js"><link rel="prefetch" href="/assets/js/41.b5abbdbc.js"><link rel="prefetch" href="/assets/js/42.1f6e4a3a.js"><link rel="prefetch" href="/assets/js/43.5e85acae.js"><link rel="prefetch" href="/assets/js/44.11b7ef0a.js"><link rel="prefetch" href="/assets/js/45.9774ff29.js"><link rel="prefetch" href="/assets/js/46.2cf4bc5b.js"><link rel="prefetch" href="/assets/js/47.bc79b4ef.js"><link rel="prefetch" href="/assets/js/48.0d80c17f.js"><link rel="prefetch" href="/assets/js/49.4fcabf82.js"><link rel="prefetch" href="/assets/js/5.1d97952d.js"><link rel="prefetch" href="/assets/js/50.7d65f488.js"><link rel="prefetch" href="/assets/js/51.2545cb57.js"><link rel="prefetch" href="/assets/js/52.36a2cca1.js"><link rel="prefetch" href="/assets/js/53.64484c50.js"><link rel="prefetch" href="/assets/js/54.52e5411a.js"><link rel="prefetch" href="/assets/js/55.4f773e83.js"><link rel="prefetch" href="/assets/js/56.a5437204.js"><link rel="prefetch" href="/assets/js/57.24dd7861.js"><link rel="prefetch" href="/assets/js/58.86388619.js"><link rel="prefetch" href="/assets/js/59.c9912d49.js"><link rel="prefetch" href="/assets/js/6.210e38ca.js"><link rel="prefetch" href="/assets/js/60.b29d00e8.js"><link rel="prefetch" href="/assets/js/61.13ff4966.js"><link rel="prefetch" href="/assets/js/62.8efcf596.js"><link rel="prefetch" href="/assets/js/63.5fa9582a.js"><link rel="prefetch" href="/assets/js/64.bbd14fec.js"><link rel="prefetch" href="/assets/js/65.bae7fd4f.js"><link rel="prefetch" href="/assets/js/66.8e3958d7.js"><link rel="prefetch" href="/assets/js/67.dac9beaa.js"><link rel="prefetch" href="/assets/js/68.1c7432eb.js"><link rel="prefetch" href="/assets/js/69.363a3505.js"><link rel="prefetch" href="/assets/js/7.1b6e0d8a.js"><link rel="prefetch" href="/assets/js/70.e4e45ab1.js"><link rel="prefetch" href="/assets/js/71.e941d084.js"><link rel="prefetch" href="/assets/js/72.6c657f6c.js"><link rel="prefetch" href="/assets/js/73.910ec668.js"><link rel="prefetch" href="/assets/js/74.92f12f63.js"><link rel="prefetch" href="/assets/js/75.984c2f19.js"><link rel="prefetch" href="/assets/js/77.1304118a.js"><link rel="prefetch" href="/assets/js/78.36d67468.js"><link rel="prefetch" href="/assets/js/79.bebe2f90.js"><link rel="prefetch" href="/assets/js/8.23102c69.js"><link rel="prefetch" href="/assets/js/80.4f2da588.js"><link rel="prefetch" href="/assets/js/81.666e12e9.js"><link rel="prefetch" href="/assets/js/82.00e1d25e.js"><link rel="prefetch" href="/assets/js/83.6f17555a.js"><link rel="prefetch" href="/assets/js/84.71aca979.js"><link rel="prefetch" href="/assets/js/85.5da240e9.js"><link rel="prefetch" href="/assets/js/86.e9b29015.js"><link rel="prefetch" href="/assets/js/87.0c138ef2.js"><link rel="prefetch" href="/assets/js/88.d122fecd.js"><link rel="prefetch" href="/assets/js/89.ccb42cfb.js"><link rel="prefetch" href="/assets/js/9.7477a4ab.js"><link rel="prefetch" href="/assets/js/90.620b4440.js"><link rel="prefetch" href="/assets/js/91.a231af75.js"><link rel="prefetch" href="/assets/js/92.0bb536ea.js"><link rel="prefetch" href="/assets/js/93.a8d3b09d.js"><link rel="prefetch" href="/assets/js/94.4e3d0336.js"><link rel="prefetch" href="/assets/js/95.263fdc93.js"><link rel="prefetch" href="/assets/js/96.2886b194.js"><link rel="prefetch" href="/assets/js/97.d085eef0.js"><link rel="prefetch" href="/assets/js/98.eaf95a18.js"><link rel="prefetch" href="/assets/js/99.fbafbf7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术博客文章总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Vue 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6+</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>H5</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端设计模式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>面试总结</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级进阶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>源码手写</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>高级面试题汇总</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/chapter16/" class="sidebar-link">前端面试大纲</a></li><li><a href="/chapter16/html.html" class="sidebar-link">HTML 部分</a></li><li><a href="/chapter16/css.html" class="sidebar-link">CSS 部分</a></li><li><a href="/chapter16/js.html" class="sidebar-link">JS 部分</a></li><li><a href="/chapter16/vue.html" class="active sidebar-link">Vue 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_1-vue3-和-vue2-有哪些区别？" class="sidebar-link">1. Vue3 和 Vue2 有哪些区别？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_2-说一下-vue2-和-vue3-的响应式原理？" class="sidebar-link">2. 说一下 Vue2 和 Vue3 的响应式原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_3-vue-实例挂载的过程发生了什么-（new-vue-发生了啥？）" class="sidebar-link">3. Vue 实例挂载的过程发生了什么?（new Vue()发生了啥？）</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_4-vue2-和-vue3-组件通信方式有哪些？" class="sidebar-link">4. Vue2 和 Vue3 组件通信方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_5-说一说-nexttick-的原理？" class="sidebar-link">5. 说一说 nextTick 的原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_6-你知道-vue-页面不刷新的情况有哪些？" class="sidebar-link">6. 你知道 Vue 页面不刷新的情况有哪些？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_7-keep-alive-的原理？" class="sidebar-link">7. keep-alive 的原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_8-vue3-中的-composition-api-和-vue2-中的-options-api-有什么不同？" class="sidebar-link">8. Vue3 中的 Composition API 和 Vue2 中的 Options API 有什么不同？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_9-spa-单页面的理解以及优缺点？ssr-了解吗？" class="sidebar-link">9. SPA 单页面的理解以及优缺点？SSR 了解吗？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_10-set、delete-的实现原理？" class="sidebar-link">10. set、delete 的实现原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_11-vue-源码设计用了哪些设计模式？" class="sidebar-link">11. Vue 源码设计用了哪些设计模式？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_12-vue-中常见的性能优化方式" class="sidebar-link">12. Vue 中常见的性能优化方式?</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_13-vue2-和-vue3-中计算属性的区别" class="sidebar-link">13. Vue2 和 Vue3 中计算属性的区别?</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_14-vue-和-react-的区别" class="sidebar-link">14. Vue 和 React 的区别?</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_15-你知道-vue2-的模板编译原理吗？和-vue3-做了哪些改进？" class="sidebar-link">15. 你知道 Vue2 的模板编译原理吗？和 Vue3 做了哪些改进？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_16-有写过自定义指令吗？自定义指令的应用场景？" class="sidebar-link">16. 有写过自定义指令吗？自定义指令的应用场景？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_17-前端路由的原理？" class="sidebar-link">17. 前端路由的原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_18-说一下-vue2-中-diff-算法？vue3-做了哪些改进？" class="sidebar-link">18. 说一下 Vue2 中 Diff 算法？Vue3 做了哪些改进？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_19-描述一下-vue2-以及-vue3-组件的渲染和更新的过程？" class="sidebar-link">19. 描述一下 Vue2 以及 Vue3 组件的渲染和更新的过程？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_20-简述一下-vuex-工作原理？" class="sidebar-link">20. 简述一下 Vuex 工作原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_21-vue-中事件绑定原理？" class="sidebar-link">21. Vue 中事件绑定原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_22-vue2-和-vue3-中-v-model-的实现原理？" class="sidebar-link">22. Vue2 和 Vue3 中 v-model 的实现原理？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#_23-vue3-0-是如何变得更快的？" class="sidebar-link">23. Vue3.0 是如何变得更快的？</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-基本原理" class="sidebar-link">Vue 基本原理</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-生命周期" class="sidebar-link">Vue 生命周期</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-组件间通信" class="sidebar-link">Vue 组件间通信</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vuex-的原理及理解" class="sidebar-link">Vuex 的原理及理解</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-router-的原理及理解" class="sidebar-link">Vue-Router 的原理及理解</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-组件间生命周期的调用顺序" class="sidebar-link">Vue 组件间生命周期的调用顺序</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-如何监听数组" class="sidebar-link">Vue 如何监听数组</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#provide-与-inject-用法" class="sidebar-link">Provide 与 inject 用法</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#eventbus" class="sidebar-link">EventBus</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#watch-高级用法" class="sidebar-link">Watch 高级用法</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-的优缺点" class="sidebar-link">Vue 的优缺点</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#assets-和-static-的区别" class="sidebar-link">Assets 和 Static 的区别</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-路由钩子函数" class="sidebar-link">Vue 路由钩子函数</a></li><li class="sidebar-sub-header"><a href="/chapter16/vue.html#vue-v-model-原理" class="sidebar-link">Vue v-model 原理</a></li></ul></li><li><a href="/chapter16/react.html" class="sidebar-link">React 部分</a></li><li><a href="/chapter16/webpack.html" class="sidebar-link">Webpack 部分</a></li><li><a href="/chapter16/http.html" class="sidebar-link">HTTP 部分</a></li><li><a href="/chapter16/algorithm.html" class="sidebar-link">算法部分</a></li><li><a href="/chapter16/optimize.html" class="sidebar-link">优化部分</a></li><li><a href="/chapter16/performance.html" class="sidebar-link">开放性</a></li><li><a href="/chapter16/inter.html" class="sidebar-link">2022</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="_1-vue3-和-vue2-有哪些区别？"><a href="#_1-vue3-和-vue2-有哪些区别？" aria-hidden="true" class="header-anchor">#</a> 1. Vue3 和 Vue2 有哪些区别？</h2> <ol><li>数据响应式原理变化，Vue2：<code>Object.defineProperty()</code>；Vue3：<code>Proxy</code></li> <li>Vue3 新增内置组件：<code>Fragment</code>(文档碎片)、<code>Suspense</code>(异步组件)、<code>Teleport</code>(瞬移组件)</li> <li>Vue3 提供 <code>Composition API</code>(可以自定义一些响应式数据, 而不是直接放在<code>data</code>选项中; 可以进行组合(把相同的功能放到方法里 <code>hooks</code>))；Vue2 是 <code>Options API</code>；自定义函数(hooks)</li> <li>Vue3 中生命周期前面都加了 <code>on</code>，移除了 <code>beforeCreate</code> 和 <code>created</code> 钩子函数, 用 <code>setup</code> 代替</li> <li>Vue3 源码采用 <code>TS</code> 开发，Vue2 采用 <code>flow</code>；-&gt; Vue3 对 TS 支持更加友好</li> <li>Vue3 源码采用 <code>monorepo</code> 方式进行管理，将模块拆分到 <code>packages</code> 目录中</li> <li>Vue3 支持 <code>tree-shaking</code>，不使用就不会打包，提升性能</li> <li>Vue3 中对模块编译进行了优化，编译时生成 <code>block tree</code>，可以对子节点进行收集。可以减少比较，并且采用了 <code>patchFlag</code> 标记动态节点。</li> <li>Vue3 中对全局 <code>API</code> 的改变</li> <li>新增 v-memo 指令</li> <li>新增了<code>开发环境</code>的两个钩子函数，在组件更新时 <code>onRenderTracked 会跟踪组件里所有变量和方法的变化、每次触发渲染时</code>onRenderTriggered` 会返回发生变化的新旧值，可以让我们进行有针对性调试</li> <li>支持在 <code>&lt;style&gt;&lt;/style&gt;</code> 里使用 <code>v-bind</code>，给 <code>CSS</code> 绑定 <code>JS 变量(color: v-bind(str))</code></li></ol> <p><strong>缺点</strong>：<code>Vue3</code> 不兼容 <code>IE11</code></p> <p><strong>扩展</strong>：<code>Vue3</code> 对于 <code>Vue2</code> 在性能上的优化（从 <code>compile</code> 和 <code>runtime</code> 两方面）？</p> <ul><li>Vue 设计思想
<ol><li><strong>拆分模块</strong>：<code>Vue3.0</code> 更注重模块上的<strong>拆分</strong>，在 2.0 中无法单独使用部分模块。需要引入完整的 <code>Vuejs</code>(例如，只想使用响应式部分，但需要引入完整的 <code>Vuejs</code>)，<code>Vue3</code> 中的模块之间<strong>耦合度低</strong>，模块可以独立使用。</li> <li><strong>重写 API</strong>：<code>Vue2</code> 中很多方法挂载到了实例中导致没有使用也会被打包（还有很多组件也是一样）。通过构建工具 <code>Tree-Shaking</code> 机制实现按需引入，减少打包后体积。</li> <li><strong>扩展更方便</strong>：<code>Vue3</code> 允许自定义渲染器，扩展能力强。不会发生以前的事情，改写 <code>Vue</code> 源码改造渲染方式。</li></ol></li></ul> <blockquote><p><strong>编译时</strong>：将模板变成虚拟节点；<strong>运行时</strong>：将虚拟节点变成真实节点</p></blockquote> <h2 id="_2-说一下-vue2-和-vue3-的响应式原理？"><a href="#_2-说一下-vue2-和-vue3-的响应式原理？" aria-hidden="true" class="header-anchor">#</a> 2. 说一下 Vue2 和 Vue3 的响应式原理？</h2> <p><strong>Vue2</strong>：当创建 <code>Vue</code> 实例时，<code>Vue</code> 会遍历 <code>data</code> 选项的属性，利用 <code>Object.defineProperty</code> 为属性添加 <code>getter</code> 和 <code>setter</code>（<code>getter</code> 用来依赖收集，<code>setter</code> 用来派发更新），并且在内部追踪依赖，在属性被访问和修改时通知变化。</p> <p><strong>Vue3</strong>：<code>Proxy</code></p> <p>在 <code>Vue.2x</code> 中，使用 <code>Object.defineProperty()</code> 对对象进行监听。而在 <code>Vue3.0</code> 中，改用 <code>Proxy</code> 进行监听。<code>Proxy</code> 比起 <code>Object.defineProperty()</code> 有如下优势：</p> <ol><li>可以监听属性的增删操作</li> <li>可以监听数组某个索引值的变化以及数组长度的变化</li></ol> <ul><li><p><code>reactive()</code> 的作用是将目标对象转换为响应式的 <code>proxy</code> 实例</p></li> <li><p><code>reactive</code> -&gt; <code>createReactiveObject</code> 方法的处理逻辑：</p> <ol><li>如果 <code>target</code> 不是对象，返回 <code>target</code></li> <li>如果 <code>target</code> 已经是 <code>proxy</code> 实例，或者 <code>readonly</code> 处理 <code>reactive</code> 对象，返回 <code>target</code></li> <li>通过 <code>isReadonly</code> 创建 <code>WeakMap</code>，判断是否监听过 <code>target</code>，存在，返回监听过后的 <code>existingProxy</code>，<strong>防止</strong>同一对象重复代理</li> <li>获取 <code>target</code> 类型，看是否是 <code>INVALID</code> 无效类型，返回 <code>target</code>.(如果是 <code>skip</code> 跳过或不可扩展属性就返回 <code>INVALID</code> 无效对象，否则是普通对象类型(<code>Object</code>、<code>Array</code>)或者集合类型(<code>Set</code>、<code>Map</code>、<code>WeakSet</code>、<code>WeakMap</code>))
<ul><li><code>Object.isExtensible(target)</code>检查是否可以向对象添加新属性</li></ul></li> <li>生成 <code>proxy</code> 实例，如果是集合类型就使用 <code>collectionHandlers</code>，否则使用 <code>baseHandlers</code></li> <li>使用 <code>proxyMap.set(target, proxy)</code>存起来，供第 3 做判断</li></ol></li></ul> <blockquote><p><code>Vue2</code> 是深层递归，<code>Vue3</code> 是懒递归（如果是嵌套对象，会继续递归将子对象转为响应式对象）</p></blockquote> <ul><li><code>proxy</code> 实例的种类：通过函数柯里化传入不同参数创建不同的 <code>proxy</code> 实例
<ol><li>完成响应式 <code>proxy</code> 实例，<code>reactive()</code></li> <li>只读的 <code>proxy</code> 实例，<code>readonly()</code></li> <li>浅层响应式 <code>proxy</code> 实例（对象第一层是响应式），<code>shallowReactive()</code></li> <li>只读的浅层的响应式 <code>proxy</code>，<code>shallowReadonly()</code></li></ol></li></ul> <blockquote><p>处理器种类：</p></blockquote> <ul><li><p>普通类型：<code>baseHandler.ts</code>，4 种 <code>proxy</code> 实例，对应着 4 种不同的处理器</p> <ol><li><code>mutationHandlers</code></li> <li><code>readonlyHandlers</code></li> <li><code>shallowReactiveHandlers</code></li> <li><code>shallowReadonlyHandlers</code></li></ol> <ul><li>处理器对五种操作进行了拦截，分别是：
<ol><li><code>get</code> 获取属性 <code>createGetter()</code></li> <li><code>set</code> 设置属性 <code>createSetter()</code></li> <li><code>deleteProperty</code> 删除属性 <code>deleteProperty()</code></li> <li><code>has</code> 是否拥有某个属性 <code>has()</code></li> <li><code>ownKeys</code>(可以拦截以下操作：<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.keys()</code>、<code>Object.ownKeys()</code>) <code>ownKeys()</code> <strong>注意</strong>：<code>get</code>、<code>has</code>、<code>ownKeys</code> 操作会 <code>依赖收集</code> -&gt; <strong>track</strong>, <code>set</code>、<code>deleteProperty</code> 操作会 <code>触发依赖</code> -&gt; <strong>trigger</strong></li></ol></li></ul></li> <li><p>集合类型：<code>collectionHandlers.ts</code></p></li> <li><p><code>track()</code> 将对象中的属性与 <code>effect</code> 关联起来</p></li> <li><p><code>trigger()</code></p></li> <li><p><code>effect()</code> -&gt; <code>createReactiveEffect()</code> 高阶函数
将自己设置为 <code>activeEffect</code>，然后执行 <code>fn</code> 函数，如果 <code>fn</code> 函数里有对响应式属性进行读取会触发 <code>get</code> 操作，从而收集依赖
<strong>注意</strong>： <code>effectStack</code> 函数栈来维护 <strong>属性</strong> 与 <strong>effect</strong> 的对应</p></li></ul> <p><code>reactive</code> 内部采用 <strong>proxy</strong>,<code>ref</code> 中内部的是 <strong>defineProperty</strong></p> <ul><li><p><code>Observer</code>(观察者)：主要给对象的属性添加 <code>getter</code> 和 <code>setter</code>，用于 <strong>依赖收集</strong></p></li> <li><p><code>Dep</code>(依赖的管理者和派发更新)：用于收集当前的响应式对象的依赖关系，每个响应式对象包括子对象都拥有一个 <code>Dep</code> 实例</p></li> <li><p><code>Watcher</code>(订阅者)：</p></li> <li><p>三者之间的关系？</p> <ol><li><code>Observer</code> 将数据定义为响应式，每个 <code>Observer</code> 实例都有自己的 <code>Dep</code> 来管理依赖，实例化 <code>Watcher</code> 的时候进行求值会触发 <code>getter</code>，进而执行 <code>dep.depend()</code>, 将当前的 <code>Watcher</code> 加入 <code>Dep</code> 维护的依赖列表 <code>subs</code>，这就是<strong>依赖收集</strong>的过程。</li> <li>数据发生变化触发 <code>setter</code>，进而执行 <code>dep.notify()</code>, <code>Dep</code> 会执行所有的依赖的 <code>update()</code>，并加入异步更新队列，这就是<strong>触发依赖</strong>的过程。</li></ol></li></ul> <h2 id="_3-vue-实例挂载的过程发生了什么-（new-vue-发生了啥？）"><a href="#_3-vue-实例挂载的过程发生了什么-（new-vue-发生了啥？）" aria-hidden="true" class="header-anchor">#</a> 3. Vue 实例挂载的过程发生了什么?（new Vue()发生了啥？）</h2> <ol><li><code>src/core/instance/index.js</code></li></ol> <p><code>new Vue()</code> -&gt; <code>this._init(options)</code> -&gt; <code>initMixin(Vue)</code>[原型上挂载 <code>_init</code> 方法]</p> <ol start="2"><li><code>scr/core/instance/init.js</code></li></ol> <p><code>Vue.prototype._init</code> -&gt; 合并配置 <code>mergeOptions()</code> -&gt; 初始化生命周期(<code>initLifecycle</code>) -&gt; 初始化事件中心(<code>initEvents</code>) -&gt; 初始化渲染(<code>initRender</code>) -&gt; 挂载 <code>beforeCreate</code> 钩子 -&gt; 初始化 <code>Inject</code>(<code>initInject</code>) -&gt; 初始化 <code>initState</code>(<code>data</code>、 <code>props</code>、 <code>computed</code>、 <code>watcher</code>、<code>methods</code>)等等 -&gt; 初始化 <code>Provide</code>(<code>initProvide</code>) -&gt; 初始化 <code>created</code> 钩子 -&gt; 最后判断是否有 <code>el</code> 使用 <code>$mount</code> 挂载</p> <ol start="3"><li><code>src/core/instance/state.js</code></li></ol> <p><code>initState</code>: 会对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>、<code>watcher</code> 进行初始化 =》<strong>数组的基本来源</strong></p> <p><code>initData</code>: 初始化数据 -&gt; 判断 <code>data</code> 是否是函数 -&gt; 获取 <code>data</code> 所有的 <code>key</code> 和 <code>props</code>、<code>methods</code> 判断是否有重名 -&gt; 观测数据（<code>observe(data)</code>)</p> <ol start="4"><li><code>src/core/observer/index.js</code></li></ol> <p><code>observe()</code> -&gt; 通过 <code>__ob__</code> 判断数据是否被观测 -&gt; 如果观测就返回观测的数据，若没有观测就实例化（<code>new Observer(value)</code>）</p> <ol start="5"><li><code>src/core/observer/index.js</code></li></ol> <p><code>class Observer</code> 类 -&gt; 1、给每个属性添加 <strong>ob</strong> 属性；2、判断<code>数组</code>还是<code>对象</code>；3、数组走 <code>observeArray()</code>, 对象走 <code>walk()</code>【注意：此时实例化 <code>dep</code>；<code>this.dep = new Dep()</code>】</p> <ol start="6"><li>对象情况:</li></ol> <p>循环所有的 <code>key</code>, 调用<strong>defineReactive()</strong> -&gt; <strong>Object.defineProperty()</strong></p> <p><code>get()</code> [<code>dep.depend()</code>依赖收集【如果有孩子深度观测 <code>childOb.dep.depend()</code>；若孩子是数组走 <code>dependArray()</code>（循环所有的孩子，e &amp;&amp; e.<code>__ob__</code> &amp;&amp; e.<code>__ob__</code>.dep.depend()）；如果孩子里还有数组，递归调用 <code>dependArray()</code>】]</p> <pre><code>1. src/observer/dep.js -&gt; depend() ：如果 Dep.target 存在，就添加依赖 Dep.target.addDep(this)
2. src/observer/watcher.js -&gt; addDep(dep) ：将 dep 添加到 watcher 的 newDeps 中；通过 addSub()将 watcher 添加到 Dep 的 subs 数组中（判断是否重复，相同的只能添加一次），不存在的话就将 watcher 添加到 dep 中 dep.addSub(this)
3. src/observer/dep.js -&gt; addSub(sub: Watcher)将 watcher 添加到 dep 中 this.subs.push(sub)
</code></pre> <p><code>set()</code> [<code>dep.notify()</code>触发更新]【如果孩子是数组也要进行观测 <code>childOb = observe(newVal)</code>】-&gt; <code>dep.notify()</code></p> <pre><code>1. src/observer/dep.js -&gt; notify() : 遍历 Dep 中的 subs 里所有的 watcher，循环调用 watcher 的 update 方法；subs[i].update()
2. src/observer/watcher.js -&gt; update(): 如果是同步 this.sync 调用 this.run() 【调用 watcher 中的 get 方法 this.get()获取最新 value，将 this.value 赋值给 oldValue; 将最新的 value 赋值给 this.value；调用 this.cb.call(this.vm, value, oldValue)】-&gt; 如果是异步调用 queueWatcher(this)
3. src/observer/scheduler.js -&gt; queueWatch(watcher: Watcher)方法: -&gt; nextTick(flushSchedulerQueue)
4. src/observer/scheduler.js -&gt; flushSchedulerQueue() 就是将更新队列中的 watcher 拿出来并依次调用他们的 callback，但重点在于为什么在 for 循环之前先对这些 watcher 进行了升序排列
</code></pre> <ol start="7"><li><p><code>src/platform/web/entry-runtime-with-compiler.js</code></p> <p><code>$mount()</code> 重写 <code>$mount</code> 方法 -&gt; 判断（1、是否 <code>render</code> 函数、2、是否有 <code>template</code>、3、都没有则 <code>el.outerHTML</code> ）-&gt; 将 <code>template</code> 转换成 <code>render</code> 方法【<code>compileToFunction(template)</code>】</p> <p><strong>线路图</strong>：<code>new Vue</code> =&gt; <code>_init</code> =&gt; <code>$mount</code> =&gt; <code>mountComponent</code></p> <p><code>src/instance/lifecycle.js</code>：<code>mountComponent()</code> -&gt; 挂载组件 -&gt; <code>callHook(vm, 'beforeMount')</code> -&gt; 定义 <code>updateComponent</code> -&gt; <code>new Watcher(vm, updateComponent, () =&gt; {}, true)</code> // == <code>updateComponent()</code> ;默认 <code>vue</code> 是通过 <code>watcher</code> 来进行渲染 渲染 <code>watcher</code></p></li></ol> <p><code>_render()</code> 函数返回的就是 <strong>虚拟 dom</strong>; <code>_update()</code> 方法将 <strong>虚拟节点转换成真实节点</strong>; <code>_render</code> 函数会读取 <code>data</code> 中的数据从而触发 <code>getter</code> 方法进行 <strong>依赖收集</strong>(会调用 <code>watcher</code> 中的 <code>get</code> 方法进行求值)</p> <p><strong>扩展</strong>：<code>Vue2</code> 中 <code>runtime + compiler</code> 和 <code>runtime-only</code> 的区别？</p> <ul><li><code>runtime-only</code> 相比 <code>runtime-compiler</code> 有两个优点：
<ol><li>运行效率高</li> <li>源代码量更少</li></ol></li> <li><code>runtime-compiler</code> 模式，<code>runtime-only</code> 模式在 <code>src</code> 文件里面只在 <code>main.js</code> 里面有区别：
<ol><li><code>runtime-compiler</code> 模式里的 <code>Vue</code> 实例的模板，和注册的组件，都被一个 <code>render</code> 函数替换掉了</li> <li><code>h</code> 函数是 <code>createElement</code> 的缩写-》用于创建虚拟 <code>DOM</code> 的
<img src="https://img-blog.csdnimg.cn/20200116225927903.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA2Mjgw,size_16,color_FFFFFF,t_70" alt></li></ol></li></ul> <p><strong>runtime-compiler 的步骤</strong>：<code>template</code> -&gt; <code>ast</code> -&gt; <code>render</code> -&gt; <code>virtual dom</code> -&gt; 真实 <code>dom</code></p> <p><strong>runtime-only 的步骤</strong>：<code>render</code> -&gt; <code>virtual dom</code> -&gt; 真实 <code>dom</code></p> <p><strong>问题</strong>：<code>runtime-only</code>：<code>main.js</code> 中的 <code>template</code> 被替换掉了，那组件中 <code>template</code> 还存在，他是怎么编译的呢？</p> <p><code>vue-template-compiler</code>，运行项目时，这个包会自动将组件的 <code>template</code> 转换成 <code>render</code> 函数</p> <h2 id="_4-vue2-和-vue3-组件通信方式有哪些？"><a href="#_4-vue2-和-vue3-组件通信方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 4. Vue2 和 Vue3 组件通信方式有哪些？</h2> <ul><li><p>Vue2 组件通信方式：</p> <ol><li>父 -&gt; 子：props; 子 -&gt; 父：$emit【单向数据流：props 只能从上一级组件传递到下一级组件】</li> <li>父子组件之间：$parents、$children 获取组件实例</li> <li>provide 和 inject ：父组件中通过 provide 来提供变量，然后子组件中使用 inject 来注入变量【Vue2.2.0 新增】</li> <li>ref 和 refs：如果在普通的 DOM 元素上，引用指向的是 DOM 元素；如果用在子组件上，引用就指向组件是来，可以通过实例获取组件的方法和数据等。</li> <li>EventBus：事件总线（$emit派发事件、$on 注册事件、$off 移除事件）</li> <li>$attrs 和 $listeners：新增了<strong>inheritAttrs</strong> 选项，默认值为 true【Vue2.4 新增】</li> <li>Vuex：专为 Vue.js 应用程序开发设计的状态管理</li></ol></li> <li><p>Vue3 组件通信方式：</p> <ol><li>父 -&gt; 子：props; 子 -&gt; 父：emit</li> <li>v-model 方式</li> <li>$refs 【defineExpose 暴露属性】</li> <li>provide 和 inject</li> <li>事件总线（Vue3 中移除了 Event-Bus，但是可以借助第三方工具：Vue 官方推荐：mitt 和 tiny-emitter）</li> <li>Vuex4</li> <li>Pinia</li></ol></li></ul> <h2 id="_5-说一说-nexttick-的原理？"><a href="#_5-说一说-nexttick-的原理？" aria-hidden="true" class="header-anchor">#</a> 5. 说一说 nextTick 的原理？</h2> <p><code>nextTick</code> 作用：是在下次 <code>DOM</code> 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 <code>DOM</code>。</p> <ul><li><p>再回答 <code>nextTick</code> 实现原理之前，首先要了解 <code>JS 的执行机制</code>:</p> <p><code>JS</code> 是<code>单线程</code>的，一次只能干一件事，即<strong>同步</strong>。（就是说所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，这是非常影响用户体验的）。所以有了 <strong>异步</strong> 的概念</p> <ul><li>同步任务：指排队在主线程上依次执行的任务</li> <li>异步任务：不进入主线程，而进入任务队列的任务，又分为<code>宏任务</code>和<code>微任务</code></li> <li>宏任务： 渲染事件、请求、<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>Node</code> 中的 <code>setImmediate</code> 等</li> <li>微任务： <code>Promise.then</code>、<code>MutationObserver</code>(监听 DOM)、Node 中的 <code>Process.nextTick</code> 等</li></ul> <p>当执行栈中的同步任务执行完后，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染...，如此形成循环，即<strong>事件循环(EventLoop)</strong></p></li> <li><p>Vue2 中 nextTick 源码解析：</p> <ul><li><p>源码地址：src/core/util/next-tick.js，源码版本：2.6.14</p></li> <li><p>源码的主要的两个作用：</p> <ol><li><p>一是判断当前环境能使用的最合适的 API 并保存异步函数</p> <p>主要是判断用哪个宏任务或微任务，因为宏任务耗费的时间是大于微任务的，所以成先使用微任务，判断顺序如下：</p> <ul><li><p><code>Promise</code></p></li> <li><p><code>MutationObserver</code></p></li> <li><p><code>setImmediate</code></p></li> <li><p><code>setTimeout</code></p> <p>环境判断结束就会得到一个延迟回调函数 <code>timerFunc</code>, 然后进入核心的 <code>nextTick</code></p></li></ul></li> <li><p>二是调用异步函数 执行回调队列</p> <p>nextTick 方法主要逻辑就是：</p> <ul><li>把传入的回调函数放进回调队列 <code>callbacks</code></li> <li>执行保存的异步任务 <code>timeFunc</code>，就会遍历 <code>callbacks</code> 执行相应的回调函数了</li></ul></li></ol></li></ul></li></ul> <p><strong>注意</strong>：如果没有提供回调，并且支持 Promise，就返回一个 Promise。 -&gt; this.$nextTick().then(()=&gt;{ ... })</p> <ul><li>名词解析：
<ol><li><code>isUsingMicroTask</code>：是否启用微任务开关</li> <li><code>callbacks</code>：回调队列</li> <li><code>pending</code>：异步控制开关，同一时间只能执行一次</li> <li><code>flushCallbacks()</code>：该方法负责执行队列中的全部回调；执行之前先备份并清空回调队列，是为了防止 <code>nextTick</code> 里有 <code>nextTick</code> 出现的问题</li> <li><code>timerFunc</code>：用来保存调用异步任务方法</li></ol></li> <li>Vue3 中 nextTick 源码解析：
<ul><li>源码地址：packages/runtime-core/src/scheduler.ts，源码版本：3.2.11</li> <li>vue3 中 nextTick 的队列由几个方法维护，基本执行顺序是这样的：
queueJob -&gt; queueFlush -&gt; flushJobs -&gt; nextTick 参数的 fn</li> <li>【还需探索...】</li></ul></li></ul> <p><strong>扩展</strong>： Vue3 中的 nextTick 是如何实现的？</p> <p>源码地址：packages/runtime-core/src/scheduler.ts</p> <p>可以看出 nextTick 接受一个函数为参数，同时会创建一个微任务。在我们页面调用 nextTick 的时候，会执行该函数，把我们的参数 fn 赋值给 p.then(fn)，在队列的任务完成后，fn 就执行了。由于加了几个维护队列的方法，所以执行顺序是这样的：queueJob -&gt; queueFlush -&gt; flushJobs -&gt; nextTick 参数的 fn</p> <h2 id="_6-你知道-vue-页面不刷新的情况有哪些？"><a href="#_6-你知道-vue-页面不刷新的情况有哪些？" aria-hidden="true" class="header-anchor">#</a> 6. 你知道 Vue 页面不刷新的情况有哪些？</h2> <ol><li><code>Vue</code> 无法检测实例被创建时不存在 <code>data</code> 中的属性</li> <li><code>Vue</code> 无法检测对象属性的添加和移除</li> <li><code>Vue</code> 通过数组下标（索引）修改一个数据项</li> <li><code>Vue</code> 不能直接修改数组的 <code>length</code></li> <li>在异步执行之前操作 <code>DOM</code></li> <li>循环嵌套太深，视图不更新 -&gt; 解决：<code>$forceUpdate()</code></li> <li>路由参数变化时，页面不刷新 -&gt; 解决：<code>watch</code> 监听 <code>$route</code> 和 <code>router-view</code> 添加 <code>key</code></li></ol> <h2 id="_7-keep-alive-的原理？"><a href="#_7-keep-alive-的原理？" aria-hidden="true" class="header-anchor">#</a> 7. keep-alive 的原理？</h2> <p><code>keep-alive</code> 是一个<strong>抽象组件</strong>：它自身不会渲染一个 <code>DOM</code> 元素，也不会出现在父组件链中；使用 <code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p> <p><strong>总的来说</strong>：keep-alive 用于保存组件的渲染状态，防止组件多次渲染。</p> <ul><li>keep-alive 用法：
<ol><li>在动态组件中的应用<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>whiteList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:exclude</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>blackList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:max</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>amount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>currentComponent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li>在 vue-router 中的应用<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>whiteList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:exclude</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>blackList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:max</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>amount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol></li></ul> <p><strong>其中</strong>：<code>include</code> 定义缓存白名单，<code>keep-alive</code> 会缓存命中的组件；<code>exclude</code> 定义缓存黑名单，被命中的组件将不会被缓存；<code>max</code> 定义缓存组件上限，超出上限使用 <code>LRU</code> 的策略置换缓存数据。</p> <ul><li><p>缓存淘汰策略 <code>LRU</code>（最近最少使用）</p></li> <li><p>源码解析过程：</p> <ol><li><p>路径：src/core/components/keep-alive.js</p></li> <li><p><code>abstract</code> 属性：<code>true</code>，判断当前组件虚拟 <code>dom</code> 是否渲染成真实 <code>dom</code> 的关键</p></li> <li><p><code>props</code> 属性：</p> <ul><li><code>include</code>：缓存白名单</li> <li><code>exclude</code>：缓存黑名单</li> <li><code>max</code>：缓存的组件数量</li></ul></li> <li><p><code>keep-alive</code> 在它生命周期内定义了三个钩子函数：</p> <ul><li><p><code>created</code>：初始化两个对象分别缓存 <code>VNode</code>(虚拟 <code>DOM</code>)<code>cache</code> 和 <code>VNode</code> 对应的键集合 <code>keys</code></p></li> <li><p><code>destroyed</code>：删除 <code>this.cache</code> 中缓存的 <code>VNode</code> 实例</p> <p><strong>扩展</strong>：为什么不直接将 <code>this.cache</code> 置为 <code>null</code>，而是遍历调用 <code>pruneCacheEntry</code> 函数删除？
删除缓存的 <code>VNode</code> 还要对应组件实例的 <code>destroy</code> 钩子函数</p></li> <li><p><code>mounted</code>：对 <code>include</code> 和 <code>exclude</code> 参数进行监听，然后实时地更新（删除）<code>this.cache</code> 对象数据</p></li> <li><p><code>render</code>：</p> <ol><li>第一步：获取 <code>keep-alive</code> 包裹着的第一个子组件对象及其组件名</li> <li>第二步：根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则执行第三步</li> <li>第三步：根据组件 ID 和 tag 生成缓存 Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置（更新 <code>key</code> 的位置是实现 <code>LRU</code> 置换策略的关键），否则执行第四步</li> <li>第四步：在 <code>this.cache</code> 对象中存储该组件实例并保存 <code>key</code> 值，之后检查缓存的实例数量是否超过 max 设置值，超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）</li> <li>第五步：最后并且很重要，将该组件实例的 <code>keepAlive</code> 属性值设置为 <code>true</code></li></ol></li></ul></li></ol></li> <li><p>新增两个钩子函数：<code>activated</code>、<code>deactivated</code></p></li></ul> <blockquote><p>常见问题：</p></blockquote> <ul><li><p><code>keep-alive</code> 不会生成真正的 <code>DOM</code> 节点，<code>Vue</code> 是如何做到的？</p> <p><code>Vue</code> 在<strong>初始化生命周期</strong>的时候，为组件实例建立父子关系会根据 <code>abstract</code> 属性决定是否忽略某个组件。在 <code>keep-alive</code> 中，设置了 <code>abstract: true</code>，那 <code>Vue</code> 就会跳过该组件实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/instance/lifecycle.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
  <span class="token punctuation">}</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>keep-alive</code> 包裹的组件是如何使用缓存的？</p> <p>在 <code>patch</code> 阶段，会执行 <code>createComponent</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// src/core/vdom/patch.js</span>
<span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>hook<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
      <span class="token function">insert</span><span class="token punctuation">(</span>parentElem<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> refElem<span class="token punctuation">)</span> <span class="token comment">// 将缓存的DOM(vnode.elem) 插入父元素中</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>在首次加载被包裹组建时，由 <code>keep-alive.js</code> 中的 <code>render</code> 函数可知，<code>vnode.componentInstance</code> 的值是 <code>undefined</code>，<code>keepAlive</code> 的值是 <code>true</code>，因为 <code>keep-alive</code> 组件作为父组件，它的 <code>render</code> 函数会先于被包裹组件执行；那么只执行到 i(vnode,false)，后面的逻辑不执行</li> <li>再次访问被包裹组件时，<code>vnode.componentInstance</code> 的值就是已经缓存的组件实例，那么会执行 <code>insert(parentElm, vnode.elm, refElm)</code>逻辑，这样就直接把上一次的 DOM 插入到父元素中</li></ol></li></ul> <h2 id="_8-vue3-中的-composition-api-和-vue2-中的-options-api-有什么不同？"><a href="#_8-vue3-中的-composition-api-和-vue2-中的-options-api-有什么不同？" aria-hidden="true" class="header-anchor">#</a> 8. Vue3 中的 Composition API 和 Vue2 中的 Options API 有什么不同？</h2> <ul><li>通常使用 <code>Vue2</code> 开发的项目，普遍会存在以下问题：
<ol><li>代码的可读性随着组件变大而变差</li> <li>每一种代码复用的方式，都存在缺点</li> <li><code>TypeScript</code> 支持有限</li></ol></li> <li><code>mixins</code> 的缺陷：
<ol><li>命名冲突</li> <li>数据来源不清楚</li></ol></li> <li>两者的主要区别：
<ol><li>在逻辑组织和逻辑复用方面，<code>Composition API</code> 是优于 <code>Options API</code></li> <li>因为 <code>Composition API</code> 几乎是函数，会有更好的类型推断</li> <li><code>Composition API</code> 对 <code>tree-shaking</code> 友好，代码也更容易压缩</li> <li><code>Composition API</code> 中见不到 <code>this</code> 的使用，减少了 <code>this</code> 指向不明的情况</li> <li>如果是小型组件，可以继续使用 <code>Options API</code>，也是十分友好的</li></ol></li></ul> <h2 id="_9-spa-单页面的理解以及优缺点？ssr-了解吗？"><a href="#_9-spa-单页面的理解以及优缺点？ssr-了解吗？" aria-hidden="true" class="header-anchor">#</a> 9. SPA 单页面的理解以及优缺点？SSR 了解吗？</h2> <p><code>SPA</code>（ <code>single-page application</code> ）仅在 <code>Web</code> 页面初始化时加载相应的 <code>HTML</code>、<code>JavaScript</code> 和 <code>CSS</code>。一旦页面加载完成，<code>SPA</code> 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用<code>路由机制</code>实现 <code>HTML</code> 内容的变换，<code>UI</code> 与用户的交互，避免页面的重新加载。</p> <ul><li><p>优点：</p> <ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li> <li>基于上面一点，<code>SPA</code> 相对对服务器压力小</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li></ol></li> <li><p>缺点：</p> <ol><li><code>初次加载耗时多</code>：为实现单页 <code>Web</code> 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li> <li><code>前进后退路由管理</code>：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li> <li><code>SEO 难度较大</code>：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势</li></ol></li> <li><p><code>SSR</code> 服务端渲染 <code>Nuxt.js</code></p> <ul><li>优点：
<ol><li>更利于 <code>SEO</code></li> <li>更利于首屏渲染</li></ol></li> <li>缺点：
<ol><li>服务端压力较大</li> <li>开发条件受限（<code>created</code> 和 <code>beforeCreate</code> 之外的生命周期钩子不可用）</li> <li>学习成本相对较高（除了对 <code>webpack</code>、<code>Vue</code> 要熟悉，还需要掌握 <code>node</code>、<code>Express</code> 相关技术）</li></ol></li></ul></li></ul> <h2 id="_10-set、delete-的实现原理？"><a href="#_10-set、delete-的实现原理？" aria-hidden="true" class="header-anchor">#</a> 10. set、delete 的实现原理？</h2> <ul><li><p><code>set</code> 的实现原理？</p> <ul><li>路径：src/core/instance/observer/index.js -&gt; set(target, key, val)</li> <li>大致流程：核心方法：<code>defineReactive(ob.value, key, val)</code> <ol><li>判断目标值是否为有效值，不是有效值直接停止</li> <li>判断是否为数组，并且 <code>key</code> 值是否为有效的 <code>key</code> 值
如果是数组，就选择数组的长度和 <code>key</code> 值取较大值作为数组的新的 <code>length</code> 值，并且替换目标值 <code>splice</code> 方法，重写了，所以执行 <code>splice</code>，会双向数据绑定</li> <li>如果目标值是对象，并且 <code>key</code> 值是目标值存在的有效 <code>key</code> 值，并且不是原型上的 <code>key</code> 值
判断目标值是否为响应式的<strong>ob</strong>
如果是 vue 实例，直接不行
如果不是响应式的数据，就是普通的修改对象操作
如果是响应式数据，那就通过 <code>Object.defineProperty</code> 进行数据劫持</li> <li>通知 <code>dom</code> 更新 <code>ob.dep.notify()</code></li></ol></li></ul></li> <li><p><code>delete</code> 的实现原理？</p> <ul><li>路径：src/core/instance/observer/index.js -&gt; del(target, key)</li> <li>大致流程：核心逻辑：delete target[key]
<ol><li>非生产环境下, 不允许删除一个原始数据类型, 或者 <code>undefined</code>, <code>null</code></li> <li>如果 <code>target</code> 是数组, 并且 <code>key</code> 是一个合法索引，通过数组的 <code>splice</code> 方法删除值, 并且还能触发数据的响应（数组拦截器截取到变化到元素, 通知依赖更新数据）</li> <li><code>target._isVue</code>: 不允许删除 <code>Vue</code> 实例对象上的属性;（<code>ob &amp;&amp; ob.vmCount</code>）: 不允许删除根数据对象的属性，触发不了响应</li> <li>如果属性压根不在对象上, 什么都不做处理</li> <li>走到这一步说明, <code>target</code> 是对象, 并且 <code>key</code> 在 <code>target</code> 上, 直接使用 <code>delete</code> 删除</li> <li>如果 <code>ob</code> 不存在, 说明 <code>target</code> 本身不是响应式数据 return；</li> <li>存在 <code>ob</code>, 通过 <code>ob</code> 里面存储的 <code>Dep</code> 实例的 <code>notify</code> 方法通知依赖更新 <code>ob.dep.notify()</code></li></ol></li></ul></li></ul> <p><strong>扩展</strong>：<code>$delete</code> 和 <code>delete</code> 的区别？</p> <ol><li><code>delete</code> 是 <code>js</code> 原生方法，由于语言限制，此操作无法设置<strong>回调</strong>来响应</li> <li><code>$delete</code> 是 <code>vue</code> 提供的实例方法，核心就是在删除后通知了依赖更新</li></ol> <h2 id="_11-vue-源码设计用了哪些设计模式？"><a href="#_11-vue-源码设计用了哪些设计模式？" aria-hidden="true" class="header-anchor">#</a> 11. Vue 源码设计用了哪些设计模式？</h2> <ul><li><p>单例模式：整个程序有且仅有一个实例</p> <p><code>new 多次，只有一个实例</code>、<code>vuex</code> 和 <code>vue-router</code> 的插件注册方法 <code>install</code> 判断如果系统存在实例就直接返回掉</p></li> <li><p>工场模式：传入参数就可以创建实例</p> <p><code>虚拟 DOM</code> 根据 <code>参数的不同</code> 返回基础<code>标签的 Vnode</code> 和<code>组件 Vnode</code></p></li> <li><p>发布订阅模式：<code>eventBus</code>、<code>vue 事件机制</code></p></li> <li><p>观察者模式：<code>watch</code> 和 <code>dep</code>(响应式数据原理)</p></li> <li><p>代理模式：<code>_data</code> 属性、<code>proxy</code>、防抖、节流</p></li> <li><p>中介者模式：<code>vuex</code></p></li> <li><p>策略模式</p></li> <li><p>外观模式</p></li></ul> <p><strong>扩展</strong>：<code>发布 / 订阅模式</code> 和 <code>观察者模式</code> 的区别是什么？</p> <ul><li>在观察者模式中，被观察者通常会维护一个观察者列表。当被观察者的状态发生改变时，就会通知观察者</li> <li>在发布订阅模式中，具体发布者会动态维护一个订阅者的列表：可在运行时根据程序需要开始或停止发布给对应订阅者的事件通知</li></ul> <p>区别在于发布者本身并不维护订阅列表（它不会像观察者一样主动维护一个列表），它会将工作委派给具体发布者（相当于秘书，任何人想知道我的事情，直接问我的秘书就可以了）；订阅者在接收到发布者的消息后，会委派具体的订阅者来进行相关的处理</p> <h2 id="_12-vue-中常见的性能优化方式"><a href="#_12-vue-中常见的性能优化方式" aria-hidden="true" class="header-anchor">#</a> 12. Vue 中常见的性能优化方式?</h2> <ul><li>编码优化
<ol><li>尽量不要将所有的数据都放在 <code>data</code> 中，<code>data</code> 中的数据都会增加 <code>getter</code> 和 <code>setter</code>，会收集对应的 <code>watcher</code></li> <li><code>vue</code> 在 <code>v-for</code> 时给每项元素绑定事件尽量用 <code>事件代理</code></li> <li>拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )</li> <li><code>v-if</code> 当值为 <code>false</code> 时内部指令不会执行,具有阻断功能，很多情况下使用 <code>v-if</code> 替代 <code>v-show</code></li> <li>合理使用 <code>路由懒加载</code>、<code>异步组件</code></li> <li><code>Object.freeze</code> 冻结数据</li></ol></li> <li>用户体验
<ol><li><code>app-skeleton</code> 骨架屏</li> <li><code>pwa</code> <code>service worker</code>【<code>web worker</code>， <code>shared worker</code> 的区别？】</li></ol></li> <li>加载性能优化
<ol><li>第三方模块按需导入 ( <code>babel-plugin-component</code> )</li> <li>滚动到可视区域动态加载 ( <code>vue-virtual-scroll-list</code> )</li> <li>图片懒加载 (<code>vue-lazyload</code>)</li></ol></li> <li>SEO 优化
<ol><li>预渲染插件 <code>prerender-spa-plugin</code></li> <li>服务端渲染 <code>ssr</code></li></ol></li> <li>打包优化
<ol><li>使用 <code>cdn</code> 的方式加载第三方模块</li> <li>多线程打包 <code>happypack</code>、<code>parallel-webpack</code></li> <li>控制包文件大小（<code>tree shaking</code> / <code>splitChunksPlugin</code>）</li> <li>使用 <code>DllPlugin</code> 提高打包速度</li></ol></li> <li>缓存/压缩
<ol><li>客户端缓存/服务端缓存</li> <li>服务端 <code>gzip</code> 压缩</li></ol></li></ul> <p><strong>扩展</strong>：按需加载的实现原理？</p> <p>其实就是在 <code>visitor</code> 对象上设置响应的方法（节点类型），然后去处理符合要求的节点，将节点上对应的属性更改为目标代码上响应的值</p> <p><code>babel</code> 插件 -&gt; 函数会有个 <code>babelTypes</code> 参数(包含 <code>types</code>) -&gt; 规定返回一个 <code>visitor</code> 对象（然后在 <code>visitor</code> 中编写获取各个节点的方法）</p> <p><code>Identifier</code>：负责处理所有节点类型为 <code>Identifier</code> 的 <code>AST</code> 节点</p> <p><code>VariableDeclaration</code>：处理变量声明关键字</p> <p><code>import</code> 对应的 <code>ImportDeclaration</code> 的节点</p> <p><code>Vue.use(ElementUI)</code>对应于 <code>ExpressionStatement</code> 类型的节点</p> <h2 id="_13-vue2-和-vue3-中计算属性的区别"><a href="#_13-vue2-和-vue3-中计算属性的区别" aria-hidden="true" class="header-anchor">#</a> 13. Vue2 和 Vue3 中计算属性的区别?</h2> <p><code>Vue3</code> 中计算属性也要收集依赖。而 <code>Vue2</code> 中计算属性不具备收集依赖的</p> <ul><li><code>computed</code> 设计的初衷是: 为了使模板中的逻辑运算更简单。它有两大优势:
<ol><li>使模板中的逻辑更加清晰，方便代码管理</li> <li>计算之后的值会被缓存起来，依赖的 <code>data</code> 值改变后会重新计算</li></ol></li></ul> <blockquote><p>问题 1：<code>Vue2</code> 中 <code>computed</code> 是如何初始化的？</p></blockquote> <p><code>Vue()</code> -&gt; <code>this.\_init()</code> -&gt; <code>initState()</code> -&gt; <code>initComputed()</code></p> <ul><li><code>initComputed()</code>做了哪些事？
<ol><li>首先使用 <code>Object.create(null)</code>; 创建一个空对象, 分别赋值给 <code>watchers</code>; 和 <code>vm._computedWatchers</code></li> <li><code>const isSSR = isServerRendering()</code>; 判断是否是服务器端渲染</li> <li>使用 <code>for in</code> 循环遍历 <code>computed</code>, 判断用户写的 <code>computed</code> 是函数还是对象 <code>const userDef = computed[key]</code> ; <code>const getter = typeof userDef === 'function' ? userDef : userDef.get</code></li> <li>会根据 <code>computed</code> 中的 <code>key</code> 来实例化 <code>watcher</code>，因此我们可以理解为其实 <code>computed</code> 就是 <code>watcher</code> 的实现, 通过一个<code>发布订阅</code>模式来监听的。给<code>Watch</code>方法传递了四个参数, 分别为<code>VM实列</code>, 上面我们获取到的<code>getter方法</code>, <code>noop</code> 是一个回调函数。<code>computedWatcherOptions</code>参数我们在源码初始化该值为：<code>const computedWatcherOptions = { lazy: true }</code></li> <li>如果 <code>computed</code>中的<code>key</code>没有在<code>vｍ</code>中, 则通过<code>defineComputed</code>挂载上去。第一次执行的时候, <code>vm</code>中没有该属性的</li> <li>在 <code>defineComputed</code>方法中首先执行 <code>const shouldCache = !isServerRendering()</code>; 判断是不是服务器端渲染。该参数的作用是否需要被缓存数据, 为 <code>true</code> 是需要被缓存的。也就是说我们的这里的 <code>computed</code> 只要不是服务器端渲染的话, 默认会缓存数据的。</li> <li>接着会判断　<code>userDef</code>　是否是一个函数, 如果是函数的话，说明是我们的<code>computed</code>的用法。因此　<code>sharedPropertyDefinition.get = createComputedGetter(key);</code> 的返回值。<strong>重新定义 getter</strong></li> <li><code>Object.defineProperty(target, key, sharedPropertyDefinition)</code>; 使用<code>Object.defineProperty</code>来监听对象属性值的变化;只要我们的<code>data</code>对象中的某个属性发生改变的话, 我们的<code>reversedMsg</code>方法中依赖了该属性的话, 也会调用<code>sharedPropertyDefinition</code>方法中的<code>get/set</code>方法的。</li></ol></li></ul> <p><strong>重点</strong>：但是在我们的页面第一次初始化的时候, 我们要如何初始化执行<code>computed</code>中的对应方法呢？</p> <ol><li><p>[initMixin]中的<code>\_init()</code> -&gt; <code>vm.$mount(vm.$options.el)</code>该代码的作用是对我们的页面中的模板进行编译操作。</p></li> <li><p>[entry-runtime-with-compiler.js] 中重写<code>\$mount</code> -&gt; <code>mount.call(this, el, hydrating);</code></p></li> <li><p>[runtime/index.js]中定义 <code>Vue.prototype.$mount</code> -&gt; <code>mountComponent(this, el, hydrating)</code></p></li> <li><p>[instance/lifecycle.js]中会<code>new</code> 一个<code>Watcher</code>进行实列化了,此时<code>this.lazy</code>为<code>false</code>,执行<code>this.get()</code>函数, 也就是说执行了 <code>this.getter.call(vm, vm)</code>方法</p></li> <li><p>最后回到[instance/state.js] -&gt; <code>createComputedGetter()</code> -&gt; <code>return watcher.value</code></p></li></ol> <blockquote><p><code>Vue3</code> 中 <code>computed</code> 的实现原理？</p></blockquote> <ol><li>[reactivity/computed.ts] -&gt; <code>computed(getterOrOptions)</code> 参数有可能是函数有可能包含<code>get</code>和<code>set</code>方法的对象</li> <li>如果是函数，就把 <code>getterOrOptions</code> 赋值给 <code>getter</code>,<code>setter</code> 提示警告不让修改。如果对象，就把 <code>getterOrOptions.get</code> 赋值给 <code>getter</code>，<code>getterOrOptions.set</code>赋值给<code>setter</code></li> <li><code>return new ComputedRefImpl(getter, setter)</code></li></ol> <p><strong>重点</strong>：<code>ComputedRefImpl</code>的实现？</p> <ol><li>在构造函数中创建一个 <code>effect</code>，响应式的计算属性。将 <code>getter</code> 作为 <code>effect</code> 的回调函数，并传入 <code>lazy: true</code> 默认不执行和 <code>scheduler</code> 函数的选项</li> <li>在类中定义<code>get value()</code>, <code>set value(newValue)</code>访问器。用来获取和设置。在 <code>get value()</code>中如果 <code>this.\_dirty</code> 为真(默认不执行，脏的)时，将会将用户的返回值返回 <code>this.\_value = this.effect()</code>；并将 <code>this.\_dirty=false</code>,下次调用的时候不重新执行。最后返回 <code>return this.\_value</code>;在设置值时，<code>set value()</code>会执行 <code>this.setter(newValue)</code>。</li></ol> <p>如果 <code>scheduler</code>存在就执行<code>scheduler</code>，不存在就执行<code>effect</code></p> <p><strong>注意</strong>：当计算属性直接在 <code>effect</code> 中访问的时候，我们需要监听 <code>value</code> 属性，做<strong>依赖收集</strong> <code>track(this, 'value')</code></p> <h2 id="_14-vue-和-react-的区别"><a href="#_14-vue-和-react-的区别" aria-hidden="true" class="header-anchor">#</a> 14. Vue 和 React 的区别?</h2> <h2 id="_15-你知道-vue2-的模板编译原理吗？和-vue3-做了哪些改进？"><a href="#_15-你知道-vue2-的模板编译原理吗？和-vue3-做了哪些改进？" aria-hidden="true" class="header-anchor">#</a> 15. 你知道 Vue2 的模板编译原理吗？和 Vue3 做了哪些改进？</h2> <h2 id="_16-有写过自定义指令吗？自定义指令的应用场景？"><a href="#_16-有写过自定义指令吗？自定义指令的应用场景？" aria-hidden="true" class="header-anchor">#</a> 16. 有写过自定义指令吗？自定义指令的应用场景？</h2> <h2 id="_17-前端路由的原理？"><a href="#_17-前端路由的原理？" aria-hidden="true" class="header-anchor">#</a> 17. 前端路由的原理？</h2> <h2 id="_18-说一下-vue2-中-diff-算法？vue3-做了哪些改进？"><a href="#_18-说一下-vue2-中-diff-算法？vue3-做了哪些改进？" aria-hidden="true" class="header-anchor">#</a> 18. 说一下 Vue2 中 Diff 算法？Vue3 做了哪些改进？</h2> <p><code>虚拟 DOM</code> 是一个 <code>JS 对象</code>. 虚拟 <code>DOM</code> 算法 = 虚拟 <code>DOM</code> + <code>Diff</code> 算法</p> <ul><li><p>使用虚拟 <code>DOM</code> 算法的损耗计算： 总损耗 = 虚拟 DOM 增删改 +（与 Diff 算法效率有关）真实 DOM 差异增删改 +（较少的节点）排版与重绘</p></li> <li><p>直接操作真实 DOM 的损耗计算： 总损耗 = 真实 DOM 完全增删改 +（可能较多的节点）排版与重绘</p></li> <li><p>Diff 算法的目的是什么？
为了减少 DOM 操作的性能开销，我们要尽可能的复用 DOM 元素。所以我们需要判断出是否有节点需要移动，应该如何移动以及找出那些需要被添加或删除的节点。</p></li></ul> <p><strong>diff 算法</strong>: 是一种通过<code>同层</code>的树节点进行比较的高效算法, diff 整体策略为：<code>深度优先</code>，<code>同层比较</code>. 其有两个特点：</p> <ol><li>比较只会在同层级进行, 不会跨层级比较</li> <li>在 diff 比较的过程中，循环从两边向中间比较</li></ol> <blockquote><p>原理分析 源码位置：src/core/vdom/patch.js</p></blockquote> <p>当数据发生改变时，<code>set</code> 方法会调用 <code>dep.notify</code> 通知所有订阅者 <code>Watcher</code>，订阅者就会调用 <code>patch</code> 给真实的 <code>DOM</code> 打补丁，更新相应的视图</p> <p><code>el</code>: 真的的 <code>DOM</code>，<code>oldVnode</code>: 旧节点，<code>newVnode</code>: 新节点</p> <ul><li><p>对比流程：</p> <ol><li><code>set</code> -&gt; <code>dep.notify</code> -&gt; <code>patch(oldVnode, newVnode)</code> -&gt; <code>isSameVnode()</code></li> <li>不是, 直接替换</li> <li>是走 <code>patchVnode</code> <ul><li><ol><li><code>oldVnode</code> 有子节点, <code>newVnode</code> 没有</li></ol></li> <li><ol start="2"><li><code>oldVnode</code> 没有子节点, <code>newVnode</code> 有</li></ol></li> <li><ol start="3"><li>都是文本节点</li></ol></li> <li><ol start="4"><li>都有子节点</li></ol></li></ul></li> <li><code>updateChildren</code></li></ol></li> <li><p><code>sameVnode</code> 方法判断是否为 <code>同一类型</code> 的节点。如何才算同一类型的节点？<code>sameVnode(oldVnode, newVnode)</code> 几种情况：</p> <ol><li><code>key</code> 值是否一样</li> <li><code>tagName</code> 标签名是否一样</li> <li><code>isComment</code> 是否都是注释节点</li> <li>是否都定义了 <code>data(class, style)</code> 是否一样</li> <li><code>sameInputType()</code> 当前节点为 <code>input</code> 时，<code>type</code> 必须相同</li></ol></li> <li><p><code>patchVnode</code> 函数做了哪些事情?</p> <ol><li>获取对应的<code>真实 DOM</code> -&gt; <code>el</code></li> <li>判断 <code>newVnode</code> 和 <code>oldVnode</code> 是否指向 <code>同一个对象</code>，如果是，直接返回</li> <li>如果他们都有文本节点并且不相同，那么将 <code>el</code> 的文本节点设置为 <code>newVnode</code> 的文本节点</li> <li>如果 <code>oldVnode</code> 有子节点而新节点没有，则删除 <code>el</code> 的子节点</li> <li>如果 <code>oldVnode</code> 没有子节点而新节点有，则将 <code>newVnode</code> 的子节点<strong>真实化</strong>之后添加到 <code>el</code></li> <li>如果两者都有子节点，则执行 <code>updateChildren</code> 函数比较子节点</li></ol></li> <li><p>updateChildren 函数五种比较情况：</p> <ol><li>旧头 &amp; 新头</li> <li>旧头 &amp; 新尾</li> <li>旧尾 &amp; 新头</li> <li>旧尾 &amp; 新尾</li> <li>如果以上逻辑都不匹配，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中 <code>可以复用</code> 的位置</li></ol></li></ul> <h2 id="_19-描述一下-vue2-以及-vue3-组件的渲染和更新的过程？"><a href="#_19-描述一下-vue2-以及-vue3-组件的渲染和更新的过程？" aria-hidden="true" class="header-anchor">#</a> 19. 描述一下 Vue2 以及 Vue3 组件的渲染和更新的过程？</h2> <h2 id="_20-简述一下-vuex-工作原理？"><a href="#_20-简述一下-vuex-工作原理？" aria-hidden="true" class="header-anchor">#</a> 20. 简述一下 Vuex 工作原理？</h2> <h2 id="_21-vue-中事件绑定原理？"><a href="#_21-vue-中事件绑定原理？" aria-hidden="true" class="header-anchor">#</a> 21. Vue 中事件绑定原理？</h2> <h2 id="_22-vue2-和-vue3-中-v-model-的实现原理？"><a href="#_22-vue2-和-vue3-中-v-model-的实现原理？" aria-hidden="true" class="header-anchor">#</a> 22. Vue2 和 Vue3 中 v-model 的实现原理？</h2> <h2 id="_23-vue3-0-是如何变得更快的？"><a href="#_23-vue3-0-是如何变得更快的？" aria-hidden="true" class="header-anchor">#</a> 23. Vue3.0 是如何变得更快的？</h2> <ul><li><code>diff</code> 方法优化
<ol><li><code>Vue2.x</code> 中的虚拟 <code>dom</code> 是进行全量的对比</li> <li><code>Vue3.0</code> 中新增了静态标记（<code>PatchFlag</code>）
在与上次虚拟节点进行对比的时候，只对比带有 <code>patch flag</code> 的节点，并且可以通过 <code>flag</code> 的信息得知当前节点要对比的具体内容。</li></ol></li> <li><code>hoistStatic</code> 静态提升
<ol><li><code>Vue2.x</code> : 无论元素是否参与更新，每次都会重新创建</li> <li><code>Vue3.0</code> : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用</li></ol></li> <li><code>cacheHandlers</code> 事件侦听器缓存
默认情况下 <code>onClick</code> 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可</li></ul> <h2 id="vue-基本原理"><a href="#vue-基本原理" aria-hidden="true" class="header-anchor">#</a> Vue 基本原理</h2> <blockquote><p>数据双向绑定，需要三大模块：</p></blockquote> <ol><li><code>Observer</code>: 能够对数据对象的所有数据进行监听，如有变动可拿到最新值并通知订阅者。</li> <li><code>Compile</code>: 对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li> <li><code>Watcher</code>: 作为连接 <code>Observer</code> 和 <code>Compiler</code> 的乔辽，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。</li></ol> <ul><li><p><code>Observer</code> 的核心是通过 <code>Object.defineProperty()</code> 来监听数据的变动，这个函数内部可以定义 <code>setter</code> 和 <code>getter</code>，每当数据发生变化，就会触发 <code>setter</code>。这时候 <code>Observer</code> 就要通知订阅者。订阅者就是 <code>Watcher</code></p></li> <li><p><code>Watcher</code> 订阅者作为 <code>Observer</code> 和 <code>Compiler</code> 之间通信的桥梁，主要做的事情是：</p> <ul><li>在自身实例化时往属性订阅器(<code>dep</code>)里面添加自己</li> <li>自身必须有一个 <code>update()</code> 方法</li> <li>待属性变动 <code>dep.notify()</code> 通知时，能调用自身的 <code>update()</code> 方法，并触发 <code>Compiler</code> 中绑定的回调</li></ul></li> <li><p><code>Compiler</code> 主要做的是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li></ul> <h2 id="vue-生命周期"><a href="#vue-生命周期" aria-hidden="true" class="header-anchor">#</a> Vue 生命周期</h2> <blockquote><p>每个 <code>Vue</code> 实例在被创建之前都要经过一系列的初始化过程,这个过程就是 vue 的生命周期。下面是官方文档提供的一张图:</p></blockquote> <p><img src="https://image-static.segmentfault.com/174/175/1741752219-59c9b774a4ccf_articlex" alt></p> <p>每个 Vue 组件完整的生命周期都会有很多钩子函数，例如：</p> <ul><li>beforeCreate</li> <li>created</li> <li>beforeMount</li> <li>mounted</li> <li>beforeUpdate</li> <li>updated</li> <li>beforeDestroy</li> <li>destroyed</li></ul> <p><strong>注意</strong>：<code>Vue</code> 为了结合<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>组件，提供了两个额外的钩子函数</p> <ul><li><code>activated</code></li> <li><code>deactivated</code></li></ul> <blockquote><p>下面我们通过详细的代码来分析<code>Vue</code>组件生命周期</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>X-UA-Compatible<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>ie=edge<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>vue生命周期学习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>https://cdn.bootcss.com/vue/2.4.2/vue.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        msg<span class="token punctuation">:</span> <span class="token string">'Vue的生命周期'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'------beforeCreate创建前状态------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'------created创建完毕状态------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">beforeMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'------beforeMount挂载前状态------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'------mounted 挂载结束状态------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span> <span class="token comment">//已被初始化</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeUpdate 更新前状态===============》'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'updated 更新完成状态===============》'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeDestroy 销毁前状态===============》'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'destroyed 销毁完成状态===============》'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'el     : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'data   : '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'%c%s'</span><span class="token punctuation">,</span> <span class="token string">'color:red'</span><span class="token punctuation">,</span> <span class="token string">'msg: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可以看到一个<code>Vue</code>实例在创建到渲染会执行四个钩子函数</p> <ol><li>在<code>beforeCreate</code>和<code>created</code>阶段</li></ol> <p>进行初始化事件，进行数据的观测，可以看到在 created 的时候数据已经和 data 属性进行绑定
<strong>注意</strong>：此时还获取不到<code>dom</code></p> <ol start="2"><li>在<code>created</code>和<code>beforeMount</code>阶段</li></ol> <p>主要做以下事情：
判断对象是否有<code>el</code>选项；若有，则继续向下编译；若没有<code>el</code>选项，则停止编译，也就意味着停止了生命周期，直到在该<code>vue</code>实例上调用<code>vm.$mount(el)</code>。
<strong>注意</strong>：要注意<code>template</code>选项的有无对生命周期的影响 1)、若<code>vue</code>实例对象中有<code>template</code>参数选项，则将其作为模板编译成<code>render函数</code>。 2)、若没有<code>template</code>选项，则将外部 HTML 作为模板编译。 3)、<code>template</code>中的模板优先级要高于<code>outer HTML</code>的优先级。
<strong>注意</strong>：优先级</p> <div class="language-js extra-class"><pre class="language-js"><code>render函数 <span class="token operator">&gt;</span> template <span class="token operator">&gt;</span> outer <span class="token constant">HTML</span>
</code></pre></div><ol start="3"><li>在<code>beforeMount</code>和<code>mounted</code>阶段</li></ol> <p>此时<code>vue实例</code>对象添加<code>$el</code>，并且替换掉挂在的<code>DOM</code>元素。<strong>注意</strong>：<code>beforeMount</code>之前<code>el</code>上还是<code>undefined</code>。</p> <ol start="4"><li>在<code>mounted</code>阶段</li></ol> <p>在<code>beforeMount</code>时，此时还是<code>虚拟DOM</code>存在；在<code>mounted</code>阶段，就可以看到<code>真实的DOM</code>;<strong>注意</strong>：此时经常是调接口的地方。</p> <ol start="5"><li>在<code>beforeUpdate</code>和<code>updated</code>阶段</li></ol> <p>当组件的<code>data</code>选项里数据发生变化，会触发对应组件重新渲染，系统会先后调用<code>beforeUpdate</code>和<code>updated</code>钩子函数。</p> <ol start="6"><li>在<code>beforeDestroy</code>和<code>destroyed</code>阶段</li></ol> <p><code>beforeDestroy</code>钩子函数在实例销毁之前调用。此时，实例仍然完全可用。
<code>destroyed</code>钩子函数在<code>Vue 实例</code>销毁后调用。调用后，<code>Vue 实例</code>指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <h2 id="vue-组件间通信"><a href="#vue-组件间通信" aria-hidden="true" class="header-anchor">#</a> Vue 组件间通信</h2> <h2 id="vuex-的原理及理解"><a href="#vuex-的原理及理解" aria-hidden="true" class="header-anchor">#</a> Vuex 的原理及理解</h2> <h2 id="vue-router-的原理及理解"><a href="#vue-router-的原理及理解" aria-hidden="true" class="header-anchor">#</a> Vue-Router 的原理及理解</h2> <blockquote><p>问题： vue-router 中路由方法 pushState 和 replaceState 能否触发 popState 事件？</p></blockquote> <p>答案是：<strong>不能</strong></p> <p>pushState 和 replaceState 是 HTML5 新接口，可以改变网址(存在跨域限制)而不刷新页面，这个强大的特性后来用到了单页面应用如：vue-router，react-router-dom 中。</p> <p><strong>注意</strong>: 仅改变网址,网页不会真的跳转,也不会获取到新的内容,本质上网页还停留在原页面</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> title<span class="token punctuation">,</span> targetURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
@状态对象：传给目标路由的信息<span class="token punctuation">,</span>可为空
@页面标题：目前所有浏览器都不支持<span class="token punctuation">,</span>填空字符串即可
@可选url：目标url，不会检查url是否存在，且不能跨域。如不传该项<span class="token punctuation">,</span>即给当前url添加data

window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> title<span class="token punctuation">,</span> targetURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
@类似于pushState<span class="token punctuation">,</span>但是会直接替换掉当前url<span class="token punctuation">,</span>而不会在history中留下记录
</code></pre></div><p><strong>总结</strong>：<code>popstate</code> 事件会在点击 <code>后退</code>、<code>前进</code> 按钮(或调用 <code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法)时触发</p> <h2 id="vue-组件间生命周期的调用顺序"><a href="#vue-组件间生命周期的调用顺序" aria-hidden="true" class="header-anchor">#</a> Vue 组件间生命周期的调用顺序</h2> <h2 id="vue-如何监听数组"><a href="#vue-如何监听数组" aria-hidden="true" class="header-anchor">#</a> Vue 如何监听数组</h2> <h2 id="provide-与-inject-用法"><a href="#provide-与-inject-用法" aria-hidden="true" class="header-anchor">#</a> Provide 与 inject 用法</h2> <h2 id="eventbus"><a href="#eventbus" aria-hidden="true" class="header-anchor">#</a> EventBus</h2> <h2 id="watch-高级用法"><a href="#watch-高级用法" aria-hidden="true" class="header-anchor">#</a> Watch 高级用法</h2> <h2 id="路由懒加载"><a href="#路由懒加载" aria-hidden="true" class="header-anchor">#</a> 路由懒加载</h2> <h2 id="vue-的优缺点"><a href="#vue-的优缺点" aria-hidden="true" class="header-anchor">#</a> Vue 的优缺点</h2> <h2 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" aria-hidden="true" class="header-anchor">#</a> Assets 和 Static 的区别</h2> <h2 id="vue-路由钩子函数"><a href="#vue-路由钩子函数" aria-hidden="true" class="header-anchor">#</a> Vue 路由钩子函数</h2> <h2 id="vue-v-model-原理"><a href="#vue-v-model-原理" aria-hidden="true" class="header-anchor">#</a> Vue v-model 原理</h2> <p>内部会根据标签的不同解析出，不同的语法</p> <ul><li>如： 文本框会被解析成 value + input 事件</li> <li>如： 复选框会被解析成 checked + change 事件</li> <li>...</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/chapter16/js.html" class="prev">
          JS 部分
        </a></span> <span class="next"><a href="/chapter16/react.html">
          React 部分
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.c45b4ff4.js" defer></script><script src="/assets/js/76.e4dddf5f.js" defer></script>
  </body>
</html>
