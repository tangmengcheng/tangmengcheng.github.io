<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前置知识 | 技术博客文章总结</title>
    <meta name="description" content="Welcome to come to my blog">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.c45b4ff4.js" as="script"><link rel="preload" href="/assets/js/10.9cdf722f.js" as="script"><link rel="prefetch" href="/assets/js/100.9b45b75e.js"><link rel="prefetch" href="/assets/js/101.95c4d653.js"><link rel="prefetch" href="/assets/js/102.09cdc274.js"><link rel="prefetch" href="/assets/js/103.985d4863.js"><link rel="prefetch" href="/assets/js/104.66cfb550.js"><link rel="prefetch" href="/assets/js/105.78c4c309.js"><link rel="prefetch" href="/assets/js/106.34be9d25.js"><link rel="prefetch" href="/assets/js/107.0df352d3.js"><link rel="prefetch" href="/assets/js/108.901d6014.js"><link rel="prefetch" href="/assets/js/109.76339f5d.js"><link rel="prefetch" href="/assets/js/11.d22cc24d.js"><link rel="prefetch" href="/assets/js/110.c6e9ec88.js"><link rel="prefetch" href="/assets/js/111.d390a797.js"><link rel="prefetch" href="/assets/js/112.cf502784.js"><link rel="prefetch" href="/assets/js/113.aa449169.js"><link rel="prefetch" href="/assets/js/114.fc2133ce.js"><link rel="prefetch" href="/assets/js/115.523542e3.js"><link rel="prefetch" href="/assets/js/116.c3507815.js"><link rel="prefetch" href="/assets/js/117.23b5b1f0.js"><link rel="prefetch" href="/assets/js/118.5df8c262.js"><link rel="prefetch" href="/assets/js/119.8e1342c2.js"><link rel="prefetch" href="/assets/js/12.636890c7.js"><link rel="prefetch" href="/assets/js/120.01f21153.js"><link rel="prefetch" href="/assets/js/121.7b546d27.js"><link rel="prefetch" href="/assets/js/122.bd8c0286.js"><link rel="prefetch" href="/assets/js/123.f4f16ed2.js"><link rel="prefetch" href="/assets/js/124.ab5935d4.js"><link rel="prefetch" href="/assets/js/125.b29cf321.js"><link rel="prefetch" href="/assets/js/126.ddf1b9eb.js"><link rel="prefetch" href="/assets/js/127.4d63b823.js"><link rel="prefetch" href="/assets/js/128.f63c61cb.js"><link rel="prefetch" href="/assets/js/129.e74fb4b4.js"><link rel="prefetch" href="/assets/js/13.74a454d8.js"><link rel="prefetch" href="/assets/js/130.05f02f04.js"><link rel="prefetch" href="/assets/js/131.bac5f9b9.js"><link rel="prefetch" href="/assets/js/132.a98fffcf.js"><link rel="prefetch" href="/assets/js/133.5b34ebb6.js"><link rel="prefetch" href="/assets/js/14.ffe8d211.js"><link rel="prefetch" href="/assets/js/15.1bcc034f.js"><link rel="prefetch" href="/assets/js/16.87d6c8f3.js"><link rel="prefetch" href="/assets/js/17.576aa97e.js"><link rel="prefetch" href="/assets/js/18.8c80ffa6.js"><link rel="prefetch" href="/assets/js/19.bd2abc77.js"><link rel="prefetch" href="/assets/js/2.0379b669.js"><link rel="prefetch" href="/assets/js/20.56b31195.js"><link rel="prefetch" href="/assets/js/21.81d1d011.js"><link rel="prefetch" href="/assets/js/22.b52a1bed.js"><link rel="prefetch" href="/assets/js/23.76785e7d.js"><link rel="prefetch" href="/assets/js/24.4bcce340.js"><link rel="prefetch" href="/assets/js/25.b2de599f.js"><link rel="prefetch" href="/assets/js/26.944ed78e.js"><link rel="prefetch" href="/assets/js/27.0bbcee1a.js"><link rel="prefetch" href="/assets/js/28.223ed5b6.js"><link rel="prefetch" href="/assets/js/29.b88c0c25.js"><link rel="prefetch" href="/assets/js/3.b3231975.js"><link rel="prefetch" href="/assets/js/30.5754e2d0.js"><link rel="prefetch" href="/assets/js/31.038ca76a.js"><link rel="prefetch" href="/assets/js/32.7f0c55a6.js"><link rel="prefetch" href="/assets/js/33.7fd80664.js"><link rel="prefetch" href="/assets/js/34.8dcb3109.js"><link rel="prefetch" href="/assets/js/35.8b1fdc43.js"><link rel="prefetch" href="/assets/js/36.cf886fc0.js"><link rel="prefetch" href="/assets/js/37.f7abfe5d.js"><link rel="prefetch" href="/assets/js/38.f63c0deb.js"><link rel="prefetch" href="/assets/js/39.9b06b340.js"><link rel="prefetch" href="/assets/js/4.c1de1412.js"><link rel="prefetch" href="/assets/js/40.490eed30.js"><link rel="prefetch" href="/assets/js/41.b5abbdbc.js"><link rel="prefetch" href="/assets/js/42.1f6e4a3a.js"><link rel="prefetch" href="/assets/js/43.5e85acae.js"><link rel="prefetch" href="/assets/js/44.11b7ef0a.js"><link rel="prefetch" href="/assets/js/45.9774ff29.js"><link rel="prefetch" href="/assets/js/46.2cf4bc5b.js"><link rel="prefetch" href="/assets/js/47.bc79b4ef.js"><link rel="prefetch" href="/assets/js/48.0d80c17f.js"><link rel="prefetch" href="/assets/js/49.4fcabf82.js"><link rel="prefetch" href="/assets/js/5.1d97952d.js"><link rel="prefetch" href="/assets/js/50.7d65f488.js"><link rel="prefetch" href="/assets/js/51.2545cb57.js"><link rel="prefetch" href="/assets/js/52.36a2cca1.js"><link rel="prefetch" href="/assets/js/53.64484c50.js"><link rel="prefetch" href="/assets/js/54.52e5411a.js"><link rel="prefetch" href="/assets/js/55.4f773e83.js"><link rel="prefetch" href="/assets/js/56.a5437204.js"><link rel="prefetch" href="/assets/js/57.24dd7861.js"><link rel="prefetch" href="/assets/js/58.86388619.js"><link rel="prefetch" href="/assets/js/59.c9912d49.js"><link rel="prefetch" href="/assets/js/6.210e38ca.js"><link rel="prefetch" href="/assets/js/60.b29d00e8.js"><link rel="prefetch" href="/assets/js/61.13ff4966.js"><link rel="prefetch" href="/assets/js/62.8efcf596.js"><link rel="prefetch" href="/assets/js/63.5fa9582a.js"><link rel="prefetch" href="/assets/js/64.bbd14fec.js"><link rel="prefetch" href="/assets/js/65.bae7fd4f.js"><link rel="prefetch" href="/assets/js/66.8e3958d7.js"><link rel="prefetch" href="/assets/js/67.dac9beaa.js"><link rel="prefetch" href="/assets/js/68.1c7432eb.js"><link rel="prefetch" href="/assets/js/69.363a3505.js"><link rel="prefetch" href="/assets/js/7.1b6e0d8a.js"><link rel="prefetch" href="/assets/js/70.e4e45ab1.js"><link rel="prefetch" href="/assets/js/71.e941d084.js"><link rel="prefetch" href="/assets/js/72.6c657f6c.js"><link rel="prefetch" href="/assets/js/73.910ec668.js"><link rel="prefetch" href="/assets/js/74.92f12f63.js"><link rel="prefetch" href="/assets/js/75.984c2f19.js"><link rel="prefetch" href="/assets/js/76.e4dddf5f.js"><link rel="prefetch" href="/assets/js/77.1304118a.js"><link rel="prefetch" href="/assets/js/78.36d67468.js"><link rel="prefetch" href="/assets/js/79.bebe2f90.js"><link rel="prefetch" href="/assets/js/8.23102c69.js"><link rel="prefetch" href="/assets/js/80.4f2da588.js"><link rel="prefetch" href="/assets/js/81.666e12e9.js"><link rel="prefetch" href="/assets/js/82.00e1d25e.js"><link rel="prefetch" href="/assets/js/83.6f17555a.js"><link rel="prefetch" href="/assets/js/84.71aca979.js"><link rel="prefetch" href="/assets/js/85.5da240e9.js"><link rel="prefetch" href="/assets/js/86.e9b29015.js"><link rel="prefetch" href="/assets/js/87.0c138ef2.js"><link rel="prefetch" href="/assets/js/88.d122fecd.js"><link rel="prefetch" href="/assets/js/89.ccb42cfb.js"><link rel="prefetch" href="/assets/js/9.7477a4ab.js"><link rel="prefetch" href="/assets/js/90.620b4440.js"><link rel="prefetch" href="/assets/js/91.a231af75.js"><link rel="prefetch" href="/assets/js/92.0bb536ea.js"><link rel="prefetch" href="/assets/js/93.a8d3b09d.js"><link rel="prefetch" href="/assets/js/94.4e3d0336.js"><link rel="prefetch" href="/assets/js/95.263fdc93.js"><link rel="prefetch" href="/assets/js/96.2886b194.js"><link rel="prefetch" href="/assets/js/97.d085eef0.js"><link rel="prefetch" href="/assets/js/98.eaf95a18.js"><link rel="prefetch" href="/assets/js/99.fbafbf7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术博客文章总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue.js</a></div> <a href="https://github.com/tangmengcheng/technology.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Vue 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React 全家桶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Webpack</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/chapter18/" class="sidebar-link">Webpack核心技术点</a></li><li><a href="/chapter18/basic.html" class="sidebar-link">基础篇</a></li><li><a href="/chapter18/config.html" class="sidebar-link">配置篇</a></li><li><a href="/chapter18/self-source.html" class="sidebar-link">源码篇</a></li><li><a href="/chapter18/interview.html" class="sidebar-link">面试题</a></li><li><a href="/chapter18/webpack.html" class="active sidebar-link">Webpack 打包原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/chapter18/hmr.html" class="sidebar-link">Webpack 热更新原理</a></li><li><a href="/chapter18/plugin.html" class="sidebar-link">Webpack 插件工作流程</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6+</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>H5</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS3</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端设计模式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>面试总结</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级进阶</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>源码手写</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级面试题汇总</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h3 id="前置知识"><a href="#前置知识" aria-hidden="true" class="header-anchor">#</a> 前置知识</h3> <ul><li><p><code>Tapable</code> 包本质上是为我们更方面创建自定义事件和触发自定义事件的库，类似于<code>Nodejs</code>中的 <code>EventEmitter Api</code>。</p> <p><code>Webpack</code> 中的插件机制就是基于 <code>Tapable</code> 实现与打包流程解耦，插件的所有形式都是基于<code>Tapable</code>实现。</p></li> <li><p><code>Webpack Node Api</code></p> <p>在前端日常使用的 npm run build 命令也是通过环境变量调用 bin 脚本去调用 Node Api 去执行编译打包。</p></li></ul> <ul><li><code>Babel</code> Webpack 内部的 AST 分析同样依赖于 Babel 进行处理</li></ul> <h3 id="大致流程"><a href="#大致流程" aria-hidden="true" class="header-anchor">#</a> 大致流程</h3> <p><img src="/assets/img/1648666199110.dddf00bd.jpg" alt></p> <p>整体我们将会从上边 5 个方面来分析 <code>Webpack</code> 打包流程:</p> <ol><li>初始化参数阶段
这一步会从我们配置的 <code>webpack.config.js</code> 中读取到对应的配置参数和 <code>shell</code> 命令中传入的参数进行合并得到最终打包配置参数。</li> <li>开始编译准备阶段
这一步我们会通过调用 <code>webpack()</code> 方法返回一个 <code>compiler</code> 方法，创建我们的 <code>compiler</code> 对象，并且注册各个 <code>Webpack Plugin</code>。找到配置入口中的 <code>entry</code> 代码，调用 <code>compiler.run()</code> 方法进行编译。</li> <li>模块编译阶段
从入口模块进行分析，调用匹配文件的 <code>loaders</code> 对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作。</li> <li>完成编译阶段
在递归完成后，每个引用模块通过 <code>loaders</code> 处理完成同时得到模块之间的相互依赖关系。</li> <li>输出文件阶段
整理模块依赖关系，同时将处理后的文件输出到 <code>output</code> 的磁盘目录中。</li></ol> <blockquote><p>接下来让我们详细的去探索每一步究竟发生了什么。</p></blockquote> <h3 id="创建目录"><a href="#创建目录" aria-hidden="true" class="header-anchor">#</a> 创建目录</h3> <p>使用 <code>tree</code> 命令查看目录结构:</p> <p>├── core // 存放将要实现的 <code>webpack</code> 核心代码
├── example // 存放实例项目
│ └── src
│ ├── entry1.js // 第一个入口文件
│ ├── entry2.js // 第二个入口文件
│ ├── index.js
│ └── webpack.config.js // 配置文件
├── loaders // 存放我们的自定义 <code>loader</code>
├── package.json
└── plugins // 存放我们的自定义 <code>plugin</code></p> <h4 id="初始化参数阶段"><a href="#初始化参数阶段" aria-hidden="true" class="header-anchor">#</a> 初始化参数阶段</h4> <ul><li><code>webpack</code>传递打包参数有两种方式：
<ol><li><code>cli命令行</code>传递参数 <code>webpack --mode=production</code></li> <li><code>webpack.config.js</code>传递参数</li></ol></li></ul> <ol><li><p>步骤一、实现合并参数阶段</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/index.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../example/webpack.config'</span><span class="token punctuation">)</span>

<span class="token comment">// 步骤1: 初始化参数 根据配置文件和shell参数合成参数</span>

<span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/webpack.js</span>
<span class="token keyword">function</span> <span class="token function">webpack</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 合并参数 得到合并后的参数 mergeOptions</span>
  <span class="token keyword">const</span> mergeOptions <span class="token operator">=</span> <span class="token function">_mergeOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 合并参数</span>
<span class="token keyword">function</span> <span class="token function">_mergeOptions</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// process.argv.slice(2) ['--mode=production']</span>
  <span class="token keyword">const</span> shellOptions <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">option<span class="token punctuation">,</span> argv</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> parseKey <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
      option<span class="token punctuation">[</span>parseKey<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shellOptions<span class="token punctuation">)</span> <span class="token comment">// { mode: production }</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>options<span class="token punctuation">,</span>
    <span class="token operator">...</span>shellOptions<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> webpack
</code></pre></div><p><strong>总结</strong>：合并参数的逻辑，是<code>将外部传入的对象</code>和<code>执行 shell 时的传入参数</code>进行最终合并。</p></li></ol> <h4 id="编译阶段"><a href="#编译阶段" aria-hidden="true" class="header-anchor">#</a> 编译阶段</h4> <ul><li><p>在得到最终的配置参数之后，我们需要在 <code>webpack()</code> 函数中做以下几件事情:</p> <ol><li>通过参数创建 <code>compiler</code> 对象。我们看到官方案例中通过调用 <code>webpack(options)</code> 方法返回的是一个 <code>compiler</code> 对象。并且同时调用 <code>compiler.run()</code> 方法启动的代码进行打包。</li> <li>注册我们定义的 <code>webpack plugin</code> 插件。</li> <li>根据传入的配置对象寻找对应的打包入口文件。</li></ol></li></ul> <ol><li><p>步骤一、 创建 <code>compiler</code> 对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/index.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../example/webpack.config'</span><span class="token punctuation">)</span>

<span class="token comment">// 步骤1: 初始化参数 根据配置文件和shell参数合成参数</span>
<span class="token comment">// 步骤2: 调用Webpack(options) 初始化compiler对象</span>
<span class="token comment">// webpack()方法会返回一个compiler对象</span>
<span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token comment">// 调用run方法进行打包</span>
compiler<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> stats</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">'err'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/webpack.js</span>
<span class="token keyword">function</span> <span class="token function">webpack</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 合并参数 得到合并后的参数 mergeOptions</span>
  <span class="token keyword">const</span> mergeOptions <span class="token operator">=</span> <span class="token function">_mergeOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
  <span class="token comment">// 创建compiler对象</span>
  <span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Compiler</span><span class="token punctuation">(</span>mergeOptions<span class="token punctuation">)</span>

  <span class="token keyword">return</span> compiler
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Compiler类进行核心编译实现</span>
<span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token punctuation">}</span>

  <span class="token comment">// run方法启动编译 , 同时run方法接受外部传递的callback</span>

  <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Compiler
</code></pre></div><ul><li>总结：
<ol><li><code>core/index.js</code> 作为打包命令的入口文件，这个文件引用了我们自己实现的 <code>webpack</code> 同时引用了外部的 <code>webpack.config.js(options)</code>。调用 <code>webpack(options).run()</code> 开始编译。</li> <li><code>core/webpack.js</code> 这个文件目前处理了参数的合并以及传入合并后的参数 <code>new Compiler(mergeOptions)</code>，同时返回创建的 <code>Compiler</code> 实例对象。</li> <li><code>core/compiler</code>，此时我们的 <code>compiler</code> 仅仅是作为一个基础的骨架，存在一个 <code>run()</code> 启动方法。</li></ol></li></ul></li> <li><p>编写 <code>Plugin</code></p> <p>在编写 <code>Plugin</code> 前，我们需要先来完善一下 <code>compiler</code> 方法:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> SyncHook <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'tapable'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
    <span class="token comment">// 创建plugin hooks</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 开始编译时的钩子</span>
      run<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 输出 asset 到 output 目录之前执行 (写入文件之前)</span>
      emit<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 在 compilation 完成时执行 全部完成编译执行</span>
      done<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// run方法启动编译</span>
  <span class="token comment">// 同时run方法接受外部传递的callback</span>
  <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Compiler
</code></pre></div><p>我们在 <code>Compiler</code> 这个类的构造函数中创建了一个属性 <code>hooks</code>，它的值是三个属性 <code>run</code>、<code>emit</code>、<code>done</code>。</p> <p>可以简单将 <code>SyncHook()</code> 方法理解称为一个 <code>Emitter Event</code> 类。当我们通过 <code>new SyncHook()</code> 返回一个对象实例后，我们可以通过 <code>this.hook.run.tap('name',callback)</code> 方法为这个对象上添加事件监听，然后在通过 <code>this.hook.run.call()</code> 执行所有 <code>tap</code> 注册的事件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/webpack.js</span>
<span class="token keyword">function</span> <span class="token function">webpack</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 合并参数 得到合并后的参数 mergeOptions</span>
  <span class="token keyword">const</span> mergeOptions <span class="token operator">=</span> <span class="token function">_mergeOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
  <span class="token comment">// 创建compiler对象</span>
  <span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Compiler</span><span class="token punctuation">(</span>mergeOptions<span class="token punctuation">)</span>

  <span class="token comment">// 加载插件</span>
  <span class="token function">_loadPlugin</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>plugins<span class="token punctuation">,</span> compiler<span class="token punctuation">)</span>

  <span class="token keyword">return</span> compiler
<span class="token punctuation">}</span>

<span class="token comment">// 加载插件</span>
<span class="token keyword">function</span> <span class="token function">_loadPlugin</span><span class="token punctuation">(</span><span class="token parameter">plugins<span class="token punctuation">,</span> compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>plugins <span class="token operator">&amp;&amp;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>plugins<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    plugins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">plugin</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">plugin</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在创建完成 <code>compiler</code> 对象后，调用了 <code>_loadPlugin</code> 方法进行<strong>注册插件</strong>。<code>任何一个 webpack 插件都是一个类(当然类本质上都是 function 的语法糖)，每个插件都必须存在一个 apply 方法。这个apply方法会接受一个compiler对象。</code></p> <p><strong>本质</strong>：就是操作 <code>compiler</code> 对象从而影响打包结果进行。webpack 插件本质上就是通过发布订阅的模式，通过 compiler 上监听事件。然后再打包编译过程中触发监听的事件从而添加一定的逻辑影响打包结果。</p> <div class="language-js extra-class"><pre class="language-js"><code>webpack5 <span class="token operator">/</span> plugins <span class="token operator">/</span> PluginA<span class="token punctuation">.</span>js
<span class="token keyword">class</span> <span class="token class-name">PluginA</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'PluginA'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'PluginA'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>寻找 entry 入口</li></ol> <p>当我们创建 compiler 后，调用 run 方法，会先触发开始编译的 plugin，然后确认人口</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/compiler.js</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> SyncHook <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'tapable'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> toUnixPath <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./utils'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token comment">// Compiler类进行核心编译实现</span>
<span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
    <span class="token comment">// 相对路径跟context参数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>rootPath <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>context <span class="token operator">||</span> <span class="token function">toUnixPath</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 创建plugin hooks</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 开始编译时的钩子</span>
      run<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 输出asset到output目录之前（写文件之前）</span>
      emit<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 在compilation完成时只需，全部编译完成</span>
      done<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// run方法启动编译 , 同时run方法接受外部传递的callback</span>

  <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用run方法时，触发开始编译的plugin</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取入口配置对象</span>
    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取入口文件路径</span>
  <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> entry <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> entry<span class="token punctuation">:</span> optionsEntry <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> optionsEntry <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      entry<span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">]</span> <span class="token operator">=</span> optionsEntry <span class="token comment">// 默认解析成main</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      entry <span class="token operator">=</span> optionsEntry
    <span class="token punctuation">}</span>
    <span class="token comment">// 将entry变成绝对路径</span>
    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> entry<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 转换为绝对路径的同时统一路径分隔符为 /</span>
        entry<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toUnixPath</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>rootPath<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> entry
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Compiler
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// utils.js</span>
<span class="token comment">// 统一路径分隔符，主要是为了后续生成模块ID方便</span>
<span class="token keyword">function</span> <span class="token function">toUnixPath</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\/g</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h4 id="模块编译阶段"><a href="#模块编译阶段" aria-hidden="true" class="header-anchor">#</a> 模块编译阶段</h4> <ul><li>编译阶段的准备工作:
<ol><li>通过 <code>hooks.tap</code> 注册 <code>webpack</code> 插件</li> <li><code>getEntry</code> 方法获得各个入口的对象</li></ol></li></ul> <p>接下来让我们继续完善 <code>compiler.js</code></p> <ul><li><p>在模块编译阶段，我们需要做的事件:</p> <ol><li>根据入口文件路径分析入口文件，对于入口文件进行匹配对应的 loader 进行处理入口文件。</li> <li>将 loader 处理完成的入口文件使用 webpack 进行编译。</li> <li>分析入口文件依赖，重复上边两个步骤编译对应依赖。</li> <li>如果嵌套文件存在依赖文件，递归调用依赖模块进行编译。</li> <li>递归编译完成后，组装一个个包含多个模块的 chunk。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
    <span class="token comment">// 创建plugin hooks</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 开始编译时的钩子</span>
      run<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 输出 asset 到 output 目录之前执行 (写入文件之前)</span>
      emit<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 在 compilation 完成时执行 全部完成编译执行</span>
      done<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 保存所有入口模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 保存所有依赖模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 所有的代码块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>chunks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次产出的文件对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>assets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次编译所有产出的文件名</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过给 <code>compiler</code> 构造函数中添加一些列属性来保存关于编译阶段生成的对应资源/模块对象。</p></li></ul> <ol><li><p>根据入口文件路径分析入口文件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存所有入口模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 保存所有依赖模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 所有的代码块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>chunks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次产出的文件对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>assets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次编译所有产出的文件名</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用run方法时，触发开始编译的plugin</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取入口配置对象</span>
    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 编译入口文件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildEntryModule</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">buildEntryModule</span><span class="token punctuation">(</span><span class="token parameter">entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entryName</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> entryPath <span class="token operator">=</span> entry<span class="token punctuation">[</span>entryName<span class="token punctuation">]</span> <span class="token comment">// 绝对路径</span>
      <span class="token keyword">const</span> entryObj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildModule</span><span class="token punctuation">(</span>entryName<span class="token punctuation">,</span> entryPath<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entryObj<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">buildModule</span><span class="token punctuation">(</span><span class="token parameter">moduleName<span class="token punctuation">,</span> modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>单个入口编译完成后，我们会在 <code>buildModule</code> 方法中返回一个对象。这个对象就是我们编译入口文件后的对象。</p></li> <li><p><code>buildModule</code> 模块编译方法</p> <ul><li><p>梳理一下 buildModule 方法它需要做哪些事情:</p> <ol><li><code>buildModule</code> 接受两个参数进行模块编译，第一个为 <code>模块所属的入口文件名称</code>，第二个为 <code>需要编译的模块路径</code>。</li> <li><code>buildModule</code> 方法要进行代码编译的前提就是，通过 <code>fs</code> 模块根据入口文件路径读取文件<code>源代码</code>。</li> <li>读取文件内容之后，调用所有匹配的 <code>loader</code> 对模块进行处理得到返回后的结果。</li> <li>得到 <code>loader</code> 处理后的结果后，通过 <code>babel</code> 分析 <code>loader</code> 处理后的代码，进行代码编译。(这一步编译主要是针对 <code>require</code> 语句，修改源代码中 <code>require</code> 语句的路径)。</li> <li>如果该入口文件没有依赖与任何模块(<code>require</code> 语句)，那么返回编译后的模块对象。</li> <li>如果该入口文件存在依赖的模块，<strong>递归</strong> <code>buildModule</code> 方法进行模块编译。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">buildModule</span><span class="token punctuation">(</span><span class="token parameter">moduleName<span class="token punctuation">,</span> modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 读文件原始代码</span>
    <span class="token keyword">const</span> originSourceCode <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    <span class="token comment">// moduleCode为修改后的代码</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>moduleCode <span class="token operator">=</span> originSourceCode
    <span class="token comment">// 2. 调用loader进行处理</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleLoader</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 匹配loader处理</span>
  <span class="token function">handleLoader</span><span class="token punctuation">(</span><span class="token parameter">modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> matchLoaders <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 1. 获取所有传入的loader规则</span>
    <span class="token keyword">const</span> rules <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>module<span class="token punctuation">.</span>rules
    rules<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">loader</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> testRule <span class="token operator">=</span> loader<span class="token punctuation">.</span>test
      <span class="token keyword">if</span> <span class="token punctuation">(</span>testRule<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果文件的路径被匹配</span>
        <span class="token comment">// 仅考虑loader { test:/\.js$/g, use:['babel-loader'] }, { test:/\.js$/, loader:'babel-loader' }</span>
        matchLoaders<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>loader<span class="token punctuation">.</span>loader<span class="token punctuation">)</span> <span class="token comment">// loader形式</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        matchLoaders<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>loader<span class="token punctuation">.</span>use<span class="token punctuation">)</span> <span class="token comment">// use形式</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 2. 倒叙执行loader传入源代码</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> matchLoaders<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 目前我们外部仅支持传入绝对路径的loader模式</span>
      <span class="token comment">// require引入对应loader</span>
      <span class="token keyword">const</span> loaderFn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>matchLoaders<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token comment">// 通过loader同步处理我的每一次编译的moduleCode</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>moduleCode <span class="token operator">=</span> <span class="token function">loaderFn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>moduleCode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过 <code>handleLoader</code> 函数，对于传入的文件路径匹配到对应后缀的 <code>loader</code> 后，依次倒序执行 <code>loader</code> 处理我们的代码 <code>this.moduleCode</code> 并且同步更新每次 <code>moduleCode</code>。最终，在每一个模块编译中<code>this.moduleCode</code> 都会经过对应的 <code>loader</code> 处理。</p></li></ul></li> <li><p>webpack 模块编译阶段</p> <p>经历过 loader 处理了我们的入口文件代码，并且得到了处理后的代码保存在了 this.moduleCode 中。此时，经过 loader 处理后我们就要进入 webpack 内部的编译阶段了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> toUnixPath <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./utils'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/parser'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> traverse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/traverse'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default
<span class="token keyword">const</span> generator <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/generator'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default
<span class="token keyword">const</span> t <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/types'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> tryExtensions <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./utils/index'</span><span class="token punctuation">)</span>
<span class="token comment">// Compiler类进行核心编译实现</span>
<span class="token keyword">class</span> <span class="token class-name">Compiler</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
    <span class="token comment">// 相对路径跟context参数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>rootPath <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>context <span class="token operator">||</span> <span class="token function">toUnixPath</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 创建plugin hooks</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 开始编译时的钩子</span>
      run<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 输出asset到output目录之前（写文件之前）</span>
      emit<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token comment">// 在compilation完成时只需，全部编译完成</span>
      done<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 保存所有入口模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 保存所有依赖模块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 所有的代码块对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>chunks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次产出的文件对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>assets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放本次编译所有产出的文件名</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// run方法启动编译 , 同时run方法接受外部传递的callback</span>

  <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用run方法时，触发开始编译的plugin</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取入口配置对象</span>
    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 编译入口文件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildEntryModule</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">buildEntryModule</span><span class="token punctuation">(</span><span class="token parameter">entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entryName</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> entryPath <span class="token operator">=</span> entry<span class="token punctuation">[</span>entryName<span class="token punctuation">]</span> <span class="token comment">// 绝对路径</span>
      <span class="token keyword">const</span> entryObj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildModule</span><span class="token punctuation">(</span>entryName<span class="token punctuation">,</span> entryPath<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entryObj<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">buildModule</span><span class="token punctuation">(</span><span class="token parameter">moduleName<span class="token punctuation">,</span> modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 读文件原始代码</span>
    <span class="token keyword">const</span> originSourceCode <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    <span class="token comment">// moduleCode为修改后的代码</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>moduleCode <span class="token operator">=</span> originSourceCode
    <span class="token comment">// 2. 调用loader进行处理</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleLoader</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">)</span>
    <span class="token comment">// 3. 调用webpack 进行模块编译，获得最终的module对象</span>
    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleWebpackCompiler</span><span class="token punctuation">(</span>moduleName<span class="token punctuation">,</span> modulePath<span class="token punctuation">)</span>
    <span class="token comment">// 4. 返回对象的module</span>
    <span class="token keyword">return</span> module
  <span class="token punctuation">}</span>

  <span class="token comment">// 调用webpack进行模块编译</span>
  <span class="token function">handleWebpackCompiler</span><span class="token punctuation">(</span><span class="token parameter">moduleName<span class="token punctuation">,</span> modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将当前模块相对于项目启动根目录计算出相对路径 作为模块ID</span>
    <span class="token keyword">const</span> moduleId <span class="token operator">=</span> <span class="token string">'./'</span> <span class="token operator">+</span> path<span class="token punctuation">.</span>posix<span class="token punctuation">.</span><span class="token function">relative</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>rootPath<span class="token punctuation">,</span> modulePath<span class="token punctuation">)</span>
    <span class="token comment">// 创建模块对象</span>
    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
      id<span class="token punctuation">:</span> moduleId<span class="token punctuation">,</span>
      dependencies<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 该模块所依赖模块绝对路径地址</span>
      name<span class="token punctuation">:</span> <span class="token punctuation">[</span>moduleName<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 该模块所属的入口文件</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用babel分析我们的代码</span>
    <span class="token keyword">const</span> ast <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>moduleCode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      sourceType<span class="token punctuation">:</span> <span class="token string">'module'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 深度优先 遍历语法树</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当遇到require语句时</span>
      <span class="token function-variable function">CallExpression</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">nodePath</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> node <span class="token operator">=</span> nodePath<span class="token punctuation">.</span>node
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'require'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 获得源代码中引入模块相对路径</span>
          <span class="token keyword">const</span> moduleName <span class="token operator">=</span> node<span class="token punctuation">.</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value
          <span class="token comment">// 寻找模块绝对路径 当前模块路径+require()对应相对路径</span>
          <span class="token keyword">const</span> moduleDirName <span class="token operator">=</span> path<span class="token punctuation">.</span>posix<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">)</span>
          <span class="token keyword">const</span> absolutePath <span class="token operator">=</span> <span class="token function">tryExtensions</span><span class="token punctuation">(</span>
            path<span class="token punctuation">.</span>posix<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>moduleDirName<span class="token punctuation">,</span> moduleName<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>resolve<span class="token punctuation">.</span>extensions<span class="token punctuation">,</span>
            moduleName<span class="token punctuation">,</span>
            moduleDirName
          <span class="token punctuation">)</span>
          <span class="token comment">// 生成moduleId - 针对于跟路径的模块ID 添加进入新的依赖模块路径</span>
          <span class="token keyword">const</span> moduleId <span class="token operator">=</span>
            <span class="token string">'./'</span> <span class="token operator">+</span> path<span class="token punctuation">.</span>posix<span class="token punctuation">.</span><span class="token function">relative</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>rootPath<span class="token punctuation">,</span> absolutePath<span class="token punctuation">)</span>
          <span class="token comment">// 通过babel修改源代码中的require变成__webpack_require__语句</span>
          node<span class="token punctuation">.</span>callee <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">identifier</span><span class="token punctuation">(</span><span class="token string">'__webpack_require__'</span><span class="token punctuation">)</span>
          <span class="token comment">// 修改源代码中require语句引入的模块 全部修改变为相对于跟路径来处理</span>
          node<span class="token punctuation">.</span>arguments <span class="token operator">=</span> <span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">stringLiteral</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span><span class="token punctuation">]</span>
          <span class="token comment">// 为当前模块添加require语句造成的依赖(内容为相对于根路径的模块ID)</span>
          module<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 遍历结束根据AST生成新的代码</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">generator</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
    <span class="token comment">// 为当前模块挂载新的生成的代码</span>
    module<span class="token punctuation">.</span>_source <span class="token operator">=</span> code
    <span class="token comment">// 返回当前模块对象</span>
    <span class="token keyword">return</span> module
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Compiler
</code></pre></div><p>这一步我们关于 webpack 编译的阶段就完成了。</p> <ul><li>针对于每一次文件编译，我们都会返回一个 module 对象
<ol><li>id 属性，表示当前模块针对于 this.rootPath 的相对目录。</li> <li>dependencies 属性，它是一个 Set 内部保存了该模块依赖的所有模块的模块 ID。</li> <li>name 属性,它表示该模块属于哪个入口文件。</li> <li>_source 属性，它存放模块自身经过 babel 编译后的字符串代码。</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 递归依赖深度遍历 存在依赖模块则加入</span>
module<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">dependency</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> depModule <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildModule</span><span class="token punctuation">(</span>moduleName<span class="token punctuation">,</span> dependency<span class="token punctuation">)</span>
  <span class="token comment">// 将编译后的任何依赖模块对象加入到modules对象中去</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>depModule<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>“模块编译阶段”基本已经结束了，这一步我们对于所有模块从入口文件开始进行分析。
<ol><li>从入口出发，读取入口文件内容调用匹配 loader 处理入口文件。</li> <li>通过 babel 分析依赖，并且同时将所有依赖的路径更换为相对于项目启动目录 options.context 的路径。</li> <li>入口文件中如果存在依赖的话，递归上述步骤编译依赖模块。</li> <li>将每个依赖的模块编译后的对象加入 this.modules</li> <li>将每个入口文件编译后的对象加入 this.entries。</li></ol></li></ul></li></ol> <h4 id="编译完成阶段"><a href="#编译完成阶段" aria-hidden="true" class="header-anchor">#</a> 编译完成阶段</h4> <pre><code>在将所有模块递归编译完成后，我们需要根据上述的依赖关系，组合最终输出的chunk模块。

~~~js
class Compiler {
    // ...
    buildEntryModule(entry) {
        Object.keys(entry).forEach((entryName) =&gt; {
        const entryPath = entry[entryName];
        // 调用buildModule实现真正的模块编译逻辑
        const entryObj = this.buildModule(entryName, entryPath);
        this.entries.add(entryObj);
        // 根据当前入口文件和模块的相互依赖关系，组装成为一个个包含当前入口所有依赖模块的chunk
        this.buildUpChunk(entryName, entryObj);
        });
        console.log(this.chunks, 'chunks');
    }

    // 根据入口文件和依赖模块组装chunks
    buildUpChunk(entryName, entryObj) {
        const chunk = {
        name: entryName, // 每一个入口文件作为一个chunk
        entryModule: entryObj, // entry编译后的对象
        modules: Array.from(this.modules).filter((i) =&gt;
            i.name.includes(entryName)
        ), // 寻找与当前entry有关的所有module
        };
        // 将chunk添加到this.chunks中去
        this.chunks.add(chunk);
    }
    // ...
}
~~~

chunk它们分别拥有:

1. name:当前入口文件的名称
2. entryModule: 入口文件编译后的对象。
3. modules: 该入口文件依赖的所有模块对象组成的数组，其中每一个元素的格式和entryModule是一致的。

此时编译完成我们拼装chunk的环节就圆满完成。
</code></pre> <h4 id="输出文件阶段"><a href="#输出文件阶段" aria-hidden="true" class="header-anchor">#</a> 输出文件阶段</h4> <pre><code>~~~js
run(callback) {
    // 调用run方法时，触发开始编译的plugin
    this.hooks.run.call()
    // 获取入口配置对象
    const entry = this.getEntry()
    // 编译入口文件
    this.buildEntryModule(entry)
    // 导出列表;之后将每个chunk转化称为单独的文件加入到输出列表assets中
    this.exportFile(callback);
}

exportFile(callback) {
    const output = this.options.output;
    // 根据chunks生成assets内容
    this.chunks.forEach((chunk) =&gt; {
        const parseFileName = output.filename.replace('[name]', chunk.name);
        // assets中 { 'main.js': '生成的字符串代码...' }
        this.assets.set(parseFileName, getSourceCode(chunk));
    });
    // 调用Plugin emit钩子
    this.hooks.emit.call();
    // 先判断目录是否存在 存在直接fs.write 不存在则首先创建
    if (!fs.existsSync(output.path)) {
        fs.mkdirSync(output.path);
    }
    // files中保存所有的生成文件名
    this.files = Object.keys(this.assets);
    // 将assets中的内容生成打包文件 写入文件系统中
    Object.keys(this.assets).forEach((fileName) =&gt; {
        const filePath = path.join(output.path, fileName);
        fs.writeFileSync(filePath, this.assets[fileName]);
    });
    // 结束之后触发钩子
    this.hooks.done.call();
    callback(null, {
        toJson: () =&gt; {
            return {
                entries: this.entries,
                modules: this.modules,
                files: this.files,
                chunks: this.chunks,
                assets: this.assets,
            };
        },
    });
}
~~~
</code></pre> <ul><li>exportFile 做了如下几件事:
<ol><li>首先获取配置参数的输出配置，迭代我们的 this.chunks，将 output.filename 中的[name]替换称为对应的入口文件名称。同时根据 chunks 的内容为 this.assets 中添加需要打包生成的文件名和文件内容。</li> <li>将文件写入磁盘前调用 plugin 的 emit 钩子函数。</li> <li>判断 output.path 文件夹是否存在，如果不存在，则通过 fs 新建这个文件夹。</li> <li>将本次打包生成的所有文件名(this.assets 的 key 值组成的数组)存放进入 files 中去。</li> <li>循环 this.assets，将文件依次写入对应的磁盘中去。</li> <li>所有打包流程结束，触发 webpack 插件的 done 钩子。</li> <li>同时为 NodeJs Webpack APi 呼应，调用 run 方法中外部传入的 callback 传入两个参数。</li></ol></li></ul> <p><strong>总的来说</strong>: this.assets 做的事情也比较简单，就是通过分析 chunks 得到 assets 然后输出对应的代码到磁盘中。</p> <p>this.assets 这个 Map 中每一个元素的 value 是通过调用 getSourceCode(chunk)方法来生成模块对应的代码的。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/chapter18/interview.html" class="prev">
          面试题
        </a></span> <span class="next"><a href="/chapter18/hmr.html">
          Webpack 热更新原理
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.c45b4ff4.js" defer></script><script src="/assets/js/10.9cdf722f.js" defer></script>
  </body>
</html>
