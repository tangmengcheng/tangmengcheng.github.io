(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{191:function(e,n,r){"use strict";r.r(n);var t=r(0),s=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[this._v("#")]),this._v(" promise")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const PENDING = 'PENDING'; // 等待\nconst FULFILLED = 'FULFILLED'; // 成功\nconst REJECTED = 'REJECTED'; // 失败\n\n// 该方法核心就是判断x\nconst resolvePromise = (promise2, x, resolve, reject) => {\n    // 注意一个问题：promise2未定义；因为JS执行机制，new Promise没有执行完就传promise2 肯定是没有定义\n    // 此时我们需要异步来解决，先让new Promise执行完；然后在调resolvePromise方法将promise2传入，这样就可以获取的到了\n\n    // 判断x和promise2是不是同一个人，是则就报错\n    if(promise2 === x) {\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'));\n    }\n    let called; // 内部测试的时候  会成功和失败都调用\n    //判断数据类型 typeof instanceof constructor toString\n    if(x !== null && (typeof x === 'object' || typeof x === 'function')) {\n        \n        try {\n            let then = x.then; // 取then 有可能这个then属性是通过 defineProperty定义\n            if(typeof then === 'function') { // 当前有then方法，就姑且它是一个promise\n                then.call(x, y => { // y 可能还是一个promise,递归调用，直到解析为一个普通值为止\n                    if (called) {\n                        return\n                    }\n                    called = true;\n                    resolvePromise(promise2, y, resolve, reject); // 采用成功的结果向下传递\n                }, r => {\n                    if(called) {\n                        return\n                    }\n                    called = true; // 防止多次调用成功和失败\n                    reject(r); // 采用失败的结果向下传递\n                }); // 为什么不直接用x.then;是为了保证不用再次取then的值；因为取该值有可能取不到\n            } else {\n                // {then: 1}\n                resolve(x); // 说明x 是一个普通对象，直接成功即可\n            }\n        } catch (error) {\n            if(called) {\n                return\n            }\n            called = true;\n            reject(error);\n        }\n    } else {\n        // x 不是对象或函数 肯定是一个普通值\n        resolve(x); // 直接让promise2成功\n    }\n}\n\nclass Promise {\n    constructor(executor) {\n        //不能相信用户的输入，一定要进行参数校验\n        if (typeof executor !== 'function') {\n            throw new TypeError(` Promise resolver ${executor} is not a function `);\n        }\n        this.status = PENDING;\n        \n        this.value = undefined; // 成功的值\n        this.reason = undefined; // 失败的原因\n\n        this.onResolvedCallbacks = []; // 成功的回调的数组\n        this.onRejectedCallbacks = []; // 失败的回调的数组\n        // 成功函数\n        let resolve = (value) => {\n            // 屏蔽调用；防止调resolve后又调reject\n            if(this.status === PENDING) {\n                this.value = value;\n                this.status = FULFILLED;\n                this.onResolvedCallbacks.forEach(fn => fn()); // 发布\n            }\n        }\n\n        // 失败函数\n        let reject = (reason) => {\n            if(this.status === PENDING) {\n                this.reason = reason;\n                this.status = REJECTED;\n                this.onRejectedCallbacks.forEach(fn => fn());\n            }\n        }\n\n        try {\n            executor(resolve, reject); // 默认执行器会默认执行\n        } catch (error) {\n            reject(error); // 若执行时发生了错误。等价于调用了失败态\n        }\n    }\n\n    then(onfulfilled, onrejected) { // then 目前有两个参数\n        // onfulfilled, onrejected是可选参数\n        onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : val => val;\n        \n        onrejected = typeof onrejected === 'function' ? onrejected : err => {\n            throw err;\n        }\n\n\n        let promise2 = new Promise((resolve, reject) => {\n            // 同步情况\n            if(this.status === FULFILLED) {\n                setTimeout(() => {\n                    try {\n                        let x = onfulfilled(this.value);\n                        // x可能是普通值  也可以是promise\n                        // 判断x的值 ===》 promise2的状态 看是成功还是失败\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (error) {\n                        reject(error); // 抛错的话直接调用promise2的reject方法\n                    }\n                }, 0);\n            }\n\n            if(this.status === REJECTED) {\n                setTimeout(() => {\n                    try {\n                        let x = onrejected(this.reason);\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }, 0);\n            }\n\n            // 异步情况\n            if(this.status === PENDING) {\n                // 如果是异步就先订阅好\n                this.onResolvedCallbacks.push(() => {\n                    // todo...\n                    setTimeout(() => {\n                       try {\n                           let x = onfulfilled(this.value);\n                           resolvePromise(promise2, x, resolve, reject);\n                       } catch (error) {\n                           reject(error);\n                       }\n                    }, 0);\n                })\n                this.onRejectedCallbacks.push(() => {\n                    setTimeout(() => {\n                        try {\n                            let x = onrejected(this.reason);\n                            resolvePromise(promise2, x, resolve, reject);\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }, 0);\n                });\n                // 注意：加了异步setTimeout后；若代码里直接throw new Error抛错的话，上面的异常处理捕捉不到，因为是同步的，我们加了setTimeout后该部分就变成异步的了\n                // 所以我们需要在处理异步的情况时候也要加个异常处理try catch\n            }\n        });\n        \n        return promise2;\n    }\n}\n\n// 延迟对象\nPromise.defer = Promise.deferred = function () {\n    let dfd = {};\n    dfd.promise = new Promise((resolve, reject) => {\n        dfd.resolve = resolve;\n        dfd.reject = reject;\n    })\n    return dfd;\n}\n\nmodule.exports = Promise;\n\n// 问题：1、为什么要加定时器？2、为什么在处理异步情况的时候也要加try-catch\n\n")])])])])}],!1,null,null,null);n.default=s.exports}}]);