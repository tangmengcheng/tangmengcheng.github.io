(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{228:function(_,e,t){"use strict";t.r(e);var v=t(0),o=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,e=_.$createElement,t=_._self._c||e;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"_1-请你实现一个大文件上传和断点续传？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-请你实现一个大文件上传和断点续传？","aria-hidden":"true"}},[_._v("#")]),_._v(" 1. 请你实现一个大文件上传和断点续传？")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("整体思路")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("前端")]),_._v("：核心就是利用 "),t("code",[_._v("Blob.prototype.slice")]),_._v(" 方法，和数组的 "),t("code",[_._v("slice")]),_._v(" 方法相似，文件的 "),t("code",[_._v("slice")]),_._v(" 方法可以返回 "),t("code",[_._v("原文件的某个切片")]),_._v("。预先定义好单个切片大小，将文件切分为一个个切片，然后借助 "),t("code",[_._v("http")]),_._v(" 的可并发性，同时上传多个切片。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间。由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序")]),_._v(" "),t("li",[t("strong",[_._v("后端")]),_._v("：服务端负责接受前端传输的切片，并在接收到所有切片后合并所有切片")])])]),_._v(" "),t("li",[t("p",[_._v("问题")]),_._v(" "),t("ol",[t("li",[_._v("何时合并切片？（切片什么时候传输完成）\n需求前端配合，两种实现方式："),t("strong",[_._v("第一")]),_._v("，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。"),t("strong",[_._v("第二")]),_._v("，可以额外发一个请求，主动通知服务端进行切片的合并。")]),_._v(" "),t("li",[_._v("如何合并切片？\n使用 "),t("code",[_._v("Nodejs")]),_._v(" 的 读写流（"),t("code",[_._v("readStream")]),_._v("/"),t("code",[_._v("writeStream")]),_._v("），将所有切片的流传输到最终文件的流里")])])])])])}],!1,null,null,null);e.default=o.exports}}]);