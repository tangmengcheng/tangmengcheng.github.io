(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{224:function(v,_,t){"use strict";t.r(_);var e=t(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"一、-css-选择器的优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、-css-选择器的优先级","aria-hidden":"true"}},[v._v("#")]),v._v(" 一、 CSS 选择器的优先级")]),v._v(" "),t("ol",[t("li",[v._v("!important 优先级最高 权重值为 1111")]),v._v(" "),t("li",[v._v('内联样式：如，style="" 权重值为 1000')]),v._v(" "),t("li",[v._v("ID 选择器：如，#content 权重值为 0100")]),v._v(" "),t("li",[v._v("类、伪类和属性选择器：如，.content 权重值为 0010")]),v._v(" "),t("li",[v._v("类型选择器和伪元素选择器：如，div p 权重值为 0001")]),v._v(" "),t("li",[v._v("通配符、子选择器、相邻选择器：如，* > + 权重值为 0000")]),v._v(" "),t("li",[v._v("继承的样式没有权值")])]),v._v(" "),t("h2",{attrs:{id:"二、-伪类和伪元素的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、-伪类和伪元素的区别","aria-hidden":"true"}},[v._v("#")]),v._v(" 二、 伪类和伪元素的区别")]),v._v(" "),t("ol",[t("li",[v._v("伪类本质上是为了弥补常规 CSS 选择器的不足，伪元素本质上是创建一个有内容的虚拟容器")]),v._v(" "),t("li",[v._v("CSS3 中伪类和伪元素的语法不同：伪类："),t("code",[v._v(":link")]),v._v("、"),t("code",[v._v(":hover")]),v._v(" 伪元素："),t("code",[v._v("::before")]),v._v("、"),t("code",[v._v("::after")])]),v._v(" "),t("li",[v._v("可以同时使用多个伪类，而只能同时使用一个伪元素")]),v._v(" "),t("li",[v._v("伪元素/伪对象：不存在 DOM 文档中，需要不能用 JS 来操作，仅仅是在 CSS 渲染层加入，并要添加"),t("code",[v._v("content")]),v._v("配合")]),v._v(" "),t("li",[v._v("伪类：存在 DOM 文档中")])]),v._v(" "),t("blockquote",[t("p",[v._v("伪类和伪元素的根本区别在于：他们是否创建了新的元素，这个新创建的元素就叫”伪元素“")])]),v._v(" "),t("h2",{attrs:{id:"三、css3-中定位有哪些及其区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、css3-中定位有哪些及其区别","aria-hidden":"true"}},[v._v("#")]),v._v(" 三、CSS3 中定位有哪些及其区别")]),v._v(" "),t("ul",[t("li",[v._v("absolute")])]),v._v(" "),t("h2",{attrs:{id:"四、css3-常见布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、css3-常见布局","aria-hidden":"true"}},[v._v("#")]),v._v(" 四、CSS3 常见布局")]),v._v(" "),t("h2",{attrs:{id:"五、重排重绘为什么会影响渲染，如何避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、重排重绘为什么会影响渲染，如何避免","aria-hidden":"true"}},[v._v("#")]),v._v(" 五、重排重绘为什么会影响渲染，如何避免?")]),v._v(" "),t("blockquote",[t("p",[v._v("谈谈你对重排（reflow）和重绘（repaint）的理解")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("重排：无论通过什么方式影响了元素的"),t("strong",[v._v("几何信息")]),v._v("（元素在视口内的位置和尺寸大小），浏览器需要重新计算元素在视口内的几何属性，这个过程叫"),t("strong",[v._v("重排")])])]),v._v(" "),t("li",[t("p",[v._v("重绘：通过构建渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个过程叫"),t("strong",[v._v("重绘")])])])]),v._v(" "),t("ol",[t("li",[v._v("js 尽量减少对样式的操作，能用 css 完成的就用 css")]),v._v(" "),t("li",[v._v("对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用")]),v._v(" "),t("li",[v._v("如果必须要用 js 操作样式，能合并尽量合并不要分多次操作")]),v._v(" "),t("li",[v._v("resize 事件 最好加上防抖，能尽量少触发就少触发")]),v._v(" "),t("li",[v._v("加载图片的时候，提前写好宽高")]),v._v(" "),t("li",[v._v("使用 "),t("code",[v._v("absolute")]),v._v(" 或 "),t("code",[v._v("fixed")]),v._v(" 使元素脱离文档流")]),v._v(" "),t("li",[t("strong",[v._v("开启 GPU 加速")]),v._v("：利用 CSS 属性 "),t("code",[v._v("transform")]),v._v("、"),t("code",[v._v("will-change")]),v._v("等。比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘")])])])}],!1,null,null,null);_.default=s.exports}}]);