(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{167:function(t,i,e){t.exports=e.p+"assets/img/biaozhun-box.e4ba9254.png"},168:function(t,i,e){t.exports=e.p+"assets/img/ie-box.e552b1c8.png"},201:function(t,i,e){"use strict";e.r(i);var a=[function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"深入理解css3盒模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入理解css3盒模型","aria-hidden":"true"}},[t._v("#")]),t._v(" 深入理解CSS3盒模型")]),t._v(" "),a("h2",{attrs:{id:"标准模型-和ie模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标准模型-和ie模型","aria-hidden":"true"}},[t._v("#")]),t._v(" 标准模型 和IE模型")]),t._v(" "),a("ul",[a("li",[t._v("盒模型由里向外content,padding,border,margin组成.")]),t._v(" "),a("li",[t._v("盒模型是有两种类型，一个是标准模型，一个是IE模型.\n"),a("img",{attrs:{src:e(167),alt:"标准模型"}}),t._v(" "),a("img",{attrs:{src:e(168),alt:"标准模型"}})]),t._v(" "),a("li",[t._v("由图可得：盒模型的宽高只是内容（content）的宽高，而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高.")])]),t._v(" "),a("h2",{attrs:{id:"css设置这两种模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css设置这两种模型","aria-hidden":"true"}},[t._v("#")]),t._v(" CSS设置这两种模型")]),t._v(" "),a("ul",[a("li",[t._v("通过CSS3的box-sizing属性设置两种模型")]),t._v(" "),a("li",[t._v("标准模型：box-sizing: content-box")]),t._v(" "),a("li",[t._v("IE模型： box-sizing: border-box")])]),t._v(" "),a("h2",{attrs:{id:"js如何设置获取盒模型对应的宽和高"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js如何设置获取盒模型对应的宽和高","aria-hidden":"true"}},[t._v("#")]),t._v(" JS如何设置获取盒模型对应的宽和高")]),t._v(" "),a("ul",[a("li",[t._v("通过JS获取盒模型对应的宽和高，有以下几种方法：")])]),t._v(" "),a("ol",[a("li",[t._v("dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的")]),t._v(" "),a("li",[t._v("dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。")]),t._v(" "),a("li",[t._v("window.getComputedStyle(dom).width/heigth 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。")]),t._v(" "),a("li",[t._v("dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的")]),t._v(" "),a("li",[t._v("dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。")])]),t._v(" "),a("h2",{attrs:{id:"bfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc","aria-hidden":"true"}},[t._v("#")]),t._v(" BFC")]),t._v(" "),a("ul",[a("li",[t._v("BFC全英文拼写为 Block Formatting Context 直译为“块级格式化上下文”")])]),t._v(" "),a("h3",{attrs:{id:"bfc原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc原理","aria-hidden":"true"}},[t._v("#")]),t._v(" BFC原理")]),t._v(" "),a("ol",[a("li",[t._v("内部的box会在垂直方向，一个接一个的放置")]),t._v(" "),a("li",[t._v("每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）")]),t._v(" "),a("li",[t._v("box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠")]),t._v(" "),a("li",[t._v("bfc的区域不会与浮动区域的box重叠")]),t._v(" "),a("li",[t._v("bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的")]),t._v(" "),a("li",[t._v("计算bfc高度的时候，浮动元素也会参与计算")])]),t._v(" "),a("h3",{attrs:{id:"创建bfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建bfc","aria-hidden":"true"}},[t._v("#")]),t._v(" 创建BFC")]),t._v(" "),a("ol",[a("li",[t._v("float属性不为none（脱离文档流）")]),t._v(" "),a("li",[t._v("position为absolute或fixed")]),t._v(" "),a("li",[t._v("display为inline-block,table-cell,table-caption,flex,inine-flex")]),t._v(" "),a("li",[t._v("overflow不为visible")]),t._v(" "),a("li",[t._v("根元素")])]),t._v(" "),a("h3",{attrs:{id:"bfc应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc应用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" BFC应用场景")]),t._v(" "),a("ol",[a("li",[t._v("自适应两栏布局")]),t._v(" "),a("li",[t._v("清除内部浮动")]),t._v(" "),a("li",[t._v("防止垂直margin重叠")])])])}],r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);i.default=s.exports}}]);