(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{278:function(v,_,e){"use strict";e.r(_);var o=e(0),c=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"_1-说说你对-webpack-的理解？它解决了什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-说说你对-webpack-的理解？它解决了什么问题？","aria-hidden":"true"}},[v._v("#")]),v._v(" 1. 说说你对 Webpack 的理解？它解决了什么问题？")]),v._v(" "),e("p",[e("code",[v._v("Webpack")]),v._v(" 是一个现代的 "),e("code",[v._v("JS")]),v._v(" 应用程序的静态"),e("code",[v._v("模块打包器")]),v._v("。它主要做的事情就是：分析你的项目结构，找到 "),e("code",[v._v("JavaScript")]),v._v(" 模块以及其他的一些浏览器不能直接运行的扩展语言（"),e("code",[v._v("Sass")]),v._v(" "),e("code",[v._v("TS")]),v._v(" 等）。并将其打包为合适的格式以供浏览器使用。")]),v._v(" "),e("ul",[e("li",[v._v("Webpack 的主要功能:\n"),e("ol",[e("li",[v._v("代码转换")]),v._v(" "),e("li",[v._v("文件优化")]),v._v(" "),e("li",[v._v("代码分割")]),v._v(" "),e("li",[v._v("模块合并")]),v._v(" "),e("li",[v._v("自动刷新")]),v._v(" "),e("li",[v._v("代码校验")]),v._v(" "),e("li",[v._v("自动发布等等")])])])]),v._v(" "),e("blockquote",[e("p",[v._v("早期模块化？")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("把单独的功能抽离到单独的 "),e("code",[v._v("js")]),v._v(" 文件，通过 "),e("code",[v._v("script")]),v._v(" 引入。")]),v._v(" "),e("p",[e("strong",[v._v("出现的问题")]),v._v("：模块都在全局中，大量模块污染环境，并且模块与模块之间没有依赖关系，维护困难，没有私有空间等问题")]),v._v(" "),e("p",[e("strong",[v._v("解决方案")]),v._v("：出现了 "),e("code",[v._v("命名空间")]),v._v(" 方式，规定每个模块只暴露一个全局对象，模块的内容都挂载在这个对象中; ---》还是没有解决第一种方式的 "),e("code",[v._v("依赖")]),v._v(" 等问题。再后来，使用 "),e("code",[v._v("立即执行函数")]),v._v(" 模块提供私有空间，通过 "),e("code",[v._v("参数")]),v._v(" 的形式作为依赖声明; ---》这种方式还是存在一些问题。比如：通过 script 引入模块，这些"),e("strong",[v._v("模块的加载并不受代码的控制")])]),v._v(" "),e("p",[e("strong",[v._v("理想的解决方式")]),v._v("：在页面中引入一个 "),e("code",[v._v("JS")]),v._v(" 入口文件，其余用到的模块可以通过代码控制，按需加载进来")])]),v._v(" "),e("li",[e("p",[v._v("除了 "),e("strong",[v._v("模块加载")]),v._v(" 的问题以外，还需要规定"),e("code",[v._v("模块化的规范")]),v._v("。如今流行的："),e("code",[v._v("CommonJS")]),v._v("、"),e("code",[v._v("ES Module")])]),v._v(" "),e("p",[v._v("从前后端渲染的 JSP、PHP。到前端原生 JavaScript。再到 jQuery 开发。再到目前三大框架 Vue, React, Angular 开发。也从 JavaScript 到后面的 es5,6,7,8...。再到 TypeScript。有些编写的 CSS 预处理器 less、sass 等。如今的前端变得十分复杂，所以我们开发过程中会遇到以下问题：")]),v._v(" "),e("ol",[e("li",[v._v("项目需要通过模块化的方式来开发")]),v._v(" "),e("li",[v._v("使用一些高级的特性来加快我们的开发效率，如：ES6+、TypeScript 开发脚本逻辑，通过 Less、Sass 等方式来编写 css 样式代码")]),v._v(" "),e("li",[v._v("监听文件的变化并且反映到浏览器上，提高开发效率")]),v._v(" "),e("li",[v._v("JS 代码需要模块化，HTML 和 CSS 这些资源文件有些也需要模块化")]),v._v(" "),e("li",[v._v("开发完后我们需要将代码压缩、合并以及一些优化等问题")])])])]),v._v(" "),e("p",[e("strong",[v._v("综合")]),v._v("：Webpack 恰巧可以解决以上问题！")]),v._v(" "),e("blockquote",[e("p",[v._v("扩展：webpack -> 垫片 Shimming")])]),v._v(" "),e("p",[v._v("比如，我们使用 "),e("code",[v._v("jQuery")]),v._v(" 中的$符号时，浏览器不认识("),e("code",[v._v("$ is not defined")]),v._v(")。我们可以使用 "),e("code",[v._v("webpack")]),v._v(" 内置插件 "),e("code",[v._v("ProvidePlugin({\\$: 'jquery'})")]),v._v("。模块中使用了"),e("code",[v._v("$")]),v._v("就自动引入"),e("code",[v._v("jquery")]),v._v("，并将"),e("code",[v._v("jquery")]),v._v("赋值给"),e("code",[v._v("$")]),v._v(".这种方式就叫垫片 "),e("code",[v._v("Shimming")])]),v._v(" "),e("h2",{attrs:{id:"_2-webpack-的构建流程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack-的构建流程？","aria-hidden":"true"}},[v._v("#")]),v._v(" 2. Webpack 的构建流程？")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("初始化参数")]),v._v("：解析 "),e("code",[v._v("webpack")]),v._v(" 配置参数，合并 "),e("code",[v._v("shell")]),v._v(" 传入和 "),e("code",[v._v("webpack.config.js")]),v._v(" 文件配置的参数, 形成最后的配置结果")]),v._v(" "),e("li",[e("strong",[v._v("开始编译")]),v._v("：上一步得到的参数初始化 "),e("code",[v._v("Compiler")]),v._v(" 对象，注册所有配置的插件，插件会监听 "),e("code",[v._v("webpack")]),v._v(" 构建生命周期的事件节点，做出相应的反应。然后执行 "),e("code",[v._v("run")]),v._v(" 方法开始执行编译")]),v._v(" "),e("li",[e("strong",[v._v("确认入口")]),v._v("：根据配置的 "),e("code",[v._v("entry")]),v._v(" 入口，开始解析文件构建 "),e("code",[v._v("AST")]),v._v("（抽象语法树），找出依赖，递归下去")]),v._v(" "),e("li",[e("strong",[v._v("编译模块")]),v._v("：递归中根据文件类型和 "),e("code",[v._v("loader")]),v._v(" 配置，调用所有配置的 "),e("code",[v._v("loader")]),v._v(" 对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理")]),v._v(" "),e("li",[e("strong",[v._v("完成模块编译并输出资源")]),v._v("：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据 "),e("code",[v._v("entry")]),v._v(" 或分包配置生成代码块 "),e("code",[v._v("chunk")])]),v._v(" "),e("li",[e("strong",[v._v("输出完成")]),v._v("：输出所有的 "),e("code",[v._v("chunk")]),v._v(" 到文件系统")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://ask.qcloudimg.com/http-save/yehe-7229962/kl8mmit2al.png?imageView2/2/w/1620",alt:""}})]),v._v(" "),e("h2",{attrs:{id:"_3-常见的-loader、plugin-有哪些？能手写吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-常见的-loader、plugin-有哪些？能手写吗？","aria-hidden":"true"}},[v._v("#")]),v._v(" 3. 常见的 Loader、Plugin 有哪些？能手写吗？")]),v._v(" "),e("blockquote",[e("p",[v._v("Plugin 的理解")])]),v._v(" "),e("p",[e("code",[v._v("Plugin")]),v._v(" 就是一个扩展器，它比 "),e("code",[v._v("Loader")]),v._v(" 更加灵活，因为它可以接触到 "),e("code",[v._v("Webpack")]),v._v(" 编译器。在 "),e("code",[v._v("Webpack")]),v._v(" 运行的生命周期中会广播出许多的事件，"),e("code",[v._v("Plugin")]),v._v(" 可以监听这些事件，在合适的时机通过 "),e("code",[v._v("Webpack")]),v._v(" 提供的 "),e("code",[v._v("API")]),v._v(" 改变输出结果。这样 "),e("code",[v._v("Plugin")]),v._v(" 就可以通过一些 hook 函数来拦截 "),e("code",[v._v("Webpack")]),v._v(" 的执行，做一些 "),e("code",[v._v("Webpack")]),v._v(" 打包之外的事情。像："),e("code",[v._v("打包优化")]),v._v("、"),e("code",[v._v("资源管理")]),v._v("、"),e("code",[v._v("注入环境变量")]),v._v("等等。")]),v._v(" "),e("p",[v._v("插件实例上都会有个 "),e("code",[v._v("apply")]),v._v(" 方法，并将 "),e("code",[v._v("compiler")]),v._v(" 作为其参数。（类似于："),e("code",[v._v("Vue")]),v._v(" 插件都有个 "),e("code",[v._v("install")]),v._v(" 方法）")]),v._v(" "),e("p",[v._v("在开发 "),e("code",[v._v("Plugin")]),v._v(" 时最常用的两个对象 "),e("code",[v._v("Compiler")]),v._v(" 和 "),e("code",[v._v("Compilation")]),v._v("，它们都继承自"),e("code",[v._v("Tapable")]),v._v("，是 "),e("code",[v._v("Plugin")]),v._v(" 和 "),e("code",[v._v("Webpack")]),v._v(" 之间的桥梁。类似于 "),e("code",[v._v("react-redux")]),v._v(" 是连接 "),e("code",[v._v("React")]),v._v(" 和 "),e("code",[v._v("Redux")]),v._v(" 的桥梁。（"),e("code",[v._v("Tapable")]),v._v(" 有同步钩子和异步钩子（"),e("code",[v._v("异步串行钩子")]),v._v(" 和 "),e("code",[v._v("异步并行钩子")]),v._v("））")]),v._v(" "),e("p",[v._v("注册钩子的方式：同步（"),e("code",[v._v("tap")]),v._v(" 注册 -》 "),e("code",[v._v("call")]),v._v(" 执行）；异步（"),e("code",[v._v("tap -》call")]),v._v("、"),e("code",[v._v("tapAsync -》callAsync")]),v._v("、"),e("code",[v._v("tapPromise -》promise")]),v._v("）")]),v._v(" "),e("p",[v._v("通过 "),e("code",[v._v("schema-utils")]),v._v(" 验证 "),e("code",[v._v("options")]),v._v(" 的合法性")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("常见的 "),e("code",[v._v("Plugin")]),v._v(":")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("html-webpack-plugin")]),v._v("：可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件")]),v._v(" "),e("li",[e("strong",[v._v("extract-text-webpack-plugin")]),v._v("：将 js 文件中引用的样式单独抽离成 css 文件（webpack4 推荐使用 mini-css-extract-plugin）\n"),e("ul",[e("li",[v._v("两者有啥区别？\n"),e("ol",[e("li",[v._v("后者：更容易使用、异步加载、而且只针对 CSS，并且不重复编译，性能更好")]),v._v(" "),e("li",[v._v("该插件一般在（生产环境）使用。代替 loaders 中的 style-loader，暂时不支持 HMR")])])])])]),v._v(" "),e("li",[e("strong",[v._v("clean-webpack-plugin")]),v._v(": 清理每次打包的文件")]),v._v(" "),e("li",[e("strong",[v._v("speed-measure-webpack-plugin")]),v._v(": 可以看每个 Loader 和 Plugin 执行耗时（webpack5 使用 speed-measure-webpack5-plugin）")]),v._v(" "),e("li",[e("strong",[v._v("webpack-bundle-analyzer")]),v._v(": 可视化 Webpack 输出文件的体积")]),v._v(" "),e("li",[e("strong",[v._v("copy-webpack-plugin")]),v._v("：拷贝插件")]),v._v(" "),e("li",[e("strong",[v._v("friendly-errors-webpack-plugin")]),v._v("： 识别某些类别的 webpack 错误，并清理，聚合和优先级，以提供更好的开发人员体验\n"),e("ul",[e("li",[v._v("webpack 中提供了 stats 选项显示打包信息（只展示错误信息、都展示等等）")])])]),v._v(" "),e("li",[e("strong",[v._v("optimize-css-assets-webpack-plugin")]),v._v("：压缩 css")]),v._v(" "),e("li",[e("strong",[v._v("purgecss-webpack-plugin")]),v._v(": 去除无用的 css")]),v._v(" "),e("li",[e("strong",[v._v("uglifyJs-webpack-plugin")]),v._v("：压缩 js\n（压缩 es6 的代码不是很友好；并且是单线程压缩代码，打包时间慢，所以开发环境将其关闭，生产环境打开（parallelUglifyPlugin 开启多个子进程打包，每个子进程还是 UglifyJS 打包，但并行执行）-》webpack4 推荐用 terser-webpack-plugin（开启 parallel 参数【一般是电脑的 CPU 核数减 1】，使用进程压缩）；此插件 webpack5 中内置了）")]),v._v(" "),e("li",[e("strong",[v._v("compression-webpack-plugin")]),v._v("：（生产环境可采用）gzip 压缩 JS 和 CSS【需要后台配置 nginx】")]),v._v(" "),e("li",[e("strong",[v._v("HotModuleReplacementPlugin")]),v._v("：热更新（自带的）")]),v._v(" "),e("li",[e("strong",[v._v("happypack")]),v._v("：开启多进程打包，提高打包速度（不维护了）")]),v._v(" "),e("li",[e("strong",[v._v("ProvidePlugin")]),v._v("：自动加载模块，代替 require 和 import（自带的）")]),v._v(" "),e("li",[e("strong",[v._v("DefinePlugin")]),v._v("：定义全局变量（浏览器获取的值，需使用 JSON.stringify 包裹）")]),v._v(" "),e("li",[e("strong",[v._v("IgnorePlugin")]),v._v("：忽略或排除（moment 不用全部加载，只加载中文）")]),v._v(" "),e("li",[e("strong",[v._v("DllPlugin")]),v._v("：动态链接库，配合 DllReferencePlugin 一起使用（自带的）")])])])]),v._v(" "),e("blockquote",[e("p",[v._v("Loader 的理解")])]),v._v(" "),e("p",[v._v("就是一个 "),e("code",[v._v("代码转码器")]),v._v("，对各种资源进行转换。它的特点：单一原则，每个 "),e("code",[v._v("loader")]),v._v(" 只做对应的事情。它的执行顺序："),e("code",[v._v("从右到左")]),v._v("，"),e("code",[v._v("从下到上")]),v._v("。有几种分类："),e("code",[v._v("pr")]),v._v("e、"),e("code",[v._v("normal")]),v._v("（默认）、"),e("code",[v._v("inline")]),v._v("、"),e("code",[v._v("post")]),v._v("。"),e("code",[v._v("Loader")]),v._v(" 就是一个函数，接受原始资源作为"),e("code",[v._v("参数")]),v._v("，输出进行转换后的内容。")]),v._v(" "),e("p",[e("code",[v._v("loader")]),v._v(" 的执行分为两个阶段："),e("code",[v._v("Pitch")]),v._v(" 阶段和 "),e("code",[v._v("Normal")]),v._v(" 阶段。"),e("code",[v._v("loader")]),v._v(" 会先执行 "),e("code",[v._v("pitch")]),v._v("，然后获取资源再执行 "),e("code",[v._v("normal loader")]),v._v("。如果 "),e("code",[v._v("pitch")]),v._v(" 有返回值时，就不会走之后的 "),e("code",[v._v("loader")]),v._v("，并将返回值返回给之前的 "),e("code",[v._v("loader")]),v._v("。这就是为什么 "),e("code",[v._v("pitch")]),v._v(" 有 "),e("strong",[v._v("熔断")]),v._v(" 的作用！")]),v._v(" "),e("p",[e("code",[v._v("loader-utils")]),v._v(" 中 "),e("code",[v._v("getOptions(this)")]),v._v(" 方法用来获取 "),e("code",[v._v("loader")]),v._v(" 中 "),e("code",[v._v("options")]),v._v(" 的配置")]),v._v(" "),e("p",[e("code",[v._v("schema-utils")]),v._v(" 中 "),e("code",[v._v("validate")]),v._v(" 方法用来验证 "),e("code",[v._v("loader")]),v._v(" 中 "),e("code",[v._v("options")]),v._v(" 的配置是否合法 "),e("code",[v._v("{type: 'object', properties: {}, additionalProperties: true}")])]),v._v(" "),e("p",[e("code",[v._v("loader")]),v._v(" 分为"),e("strong",[v._v("同步")]),v._v("（"),e("code",[v._v("return")]),v._v(" 或 "),e("code",[v._v("this.callback(null, source, map, meta)")]),v._v("两种方式）和 "),e("strong",[v._v("异步")]),v._v("（"),e("code",[v._v("this.async()")]),v._v("）")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("常见的 Loader:")]),v._v(" "),e("ol",[e("li",[v._v("file-loader：")]),v._v(" "),e("li",[v._v("url-loader：")]),v._v(" "),e("li",[v._v("babel-loader：")]),v._v(" "),e("li",[v._v("css-loader：")]),v._v(" "),e("li",[v._v("style-loader：")]),v._v(" "),e("li",[v._v("eslint-loader：")]),v._v(" "),e("li",[v._v("cache-loader：")]),v._v(" "),e("li",[v._v("less-loader、sass-loader、styles-loader：")]),v._v(" "),e("li",[v._v("image-webpack-loader：压缩图片")]),v._v(" "),e("li",[v._v("postcss-loader、autoprefixer-loader")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Compiler")]),v._v(" 上有哪些钩子？\nenvironment、run、make、emit、afterEmit、done、thisCompilation(初始化 compilation 时调用) 等等")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Compilation")]),v._v(" 上有哪些钩子？")])])]),v._v(" "),e("h2",{attrs:{id:"_4-如何提高-webpack-的构建速度？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何提高-webpack-的构建速度？","aria-hidden":"true"}},[v._v("#")]),v._v(" 4. 如何提高 Webpack 的构建速度？")]),v._v(" "),e("p",[v._v("优化"),e("code",[v._v("webpack")]),v._v("构建的方式有很多，主要可以从"),e("code",[v._v("优化搜索时间")]),v._v("、"),e("code",[v._v("缩小文件搜索范围")]),v._v("、"),e("code",[v._v("减少不必要的编译")]),v._v("等方面入手：")]),v._v(" "),e("ul",[e("li",[v._v("多线程/多实例构建："),e("code",[v._v("HappyPack")]),v._v("(不维护了)、"),e("code",[v._v("thread-loader")])]),v._v(" "),e("li",[v._v("优化 "),e("code",[v._v("loader")]),v._v(" 的配置\n"),e("ol",[e("li",[e("code",[v._v("include")]),v._v(" 和 "),e("code",[v._v("exclude")])]),v._v(" "),e("li",[v._v("配置 "),e("code",[v._v("babel-loader")]),v._v(" 时，可以配置 "),e("code",[v._v("cacheDirectory")]),v._v(" 开启缓存")])])]),v._v(" "),e("li",[v._v("合理的使用 "),e("code",[v._v("resolve.extensions")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("extensions")]),v._v(': [".js",".json"]')])])]),v._v(" "),e("li",[v._v("优化 "),e("code",[v._v("resolve.modules")]),v._v(" "),e("ol",[e("li",[v._v("用于配置 "),e("code",[v._v("webpack")]),v._v(" 去哪些目录下寻找第三方模块。默认值为"),e("code",[v._v("['node_modules']")]),v._v("，配置了可以减少查找路径")])])]),v._v(" "),e("li",[v._v("优化 "),e("code",[v._v("resolve.alias")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("\"@\":path.resolve(\\_\\_dirname,'./src')")]),v._v(" 减少查找过程")])])]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("DllPlugin")]),v._v(" 插件\n"),e("ol",[e("li",[v._v("打包成一个 "),e("code",[v._v("Dll")]),v._v(" 库，"),e("code",[v._v("webpack.DllPlugin()")]),v._v(" -> 生成 "),e("code",[v._v("mainfest.json")]),v._v(" 文件")]),v._v(" "),e("li",[v._v("引入 "),e("code",[v._v("Dll")]),v._v(" 库，"),e("code",[v._v("webpack.DllReferencePlugin()")])])])]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("cache-loader")]),v._v(" "),e("ol",[e("li",[v._v("针对一些开销较大的 "),e("code",[v._v("loader")]),v._v(" 前添加 "),e("code",[v._v("cache-loader")]),v._v("，将其结果缓存到磁盘里，显著提升二次构建速度（保存和读取这些缓存文件会有一些时间开销，只针对一些开销大的 "),e("code",[v._v("loader")]),v._v("）")]),v._v(" "),e("li",[e("code",[v._v("use")]),v._v(": "),e("code",[v._v("['cache-loader', ...loaders]")])])])]),v._v(" "),e("li",[e("code",[v._v("terser")]),v._v(" 开启多线程\n"),e("ol",[e("li",[v._v("使用多进程并行运行来提高构建速度")]),v._v(" "),e("li",[e("code",[v._v("optimization")]),v._v(": "),e("code",[v._v("{ minimizer: [new TerserPlugin({ parallel: true })] }")])])])]),v._v(" "),e("li",[v._v("合理使用 "),e("code",[v._v("sourceMap")])])]),v._v(" "),e("h2",{attrs:{id:"_5-webpack4-和-webpack5-有哪些区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-webpack4-和-webpack5-有哪些区别？","aria-hidden":"true"}},[v._v("#")]),v._v(" 5. Webpack4 和 Webpack5 有哪些区别？")]),v._v(" "),e("ul",[e("li",[e("p",[e("strong",[v._v("压缩代码")])]),v._v(" "),e("p",[v._v("内部自带 "),e("code",[v._v("terser-webpack-plugin")]),v._v(" 插件（生产环境自动开启压缩）【"),e("code",[v._v("webpack4")]),v._v(" 需要独立安装】")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// webpack5开发环境启动压缩")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" TerserPlugin "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'terser-webpack-plugini'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\nmodule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  optimization"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    usedExports"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 只导出被使用的模块")]),v._v("\n    minimize"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 启动压缩")]),v._v("\n    minimizer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("TerserPlugin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),e("p",[e("strong",[v._v("扩展")]),v._v("：开发模块开启 "),e("code",[v._v("Tree Shaking")]),v._v(" 的方式？【生产环境自动开启】")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("optimization.sideEffects: true")]),v._v("; // 开启\n（"),e("code",[v._v("package.json")]),v._v(" 里也要配置："),e("code",[v._v("'sideEffects: false | true | []'")]),v._v("）")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Tree-shaking")]),v._v(" 机制的原理？")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("treeShaking")]),v._v(" 也叫"),e("code",[v._v("摇树优化")]),v._v("，是指在打包中去除那些引入了，但是在代码中没有被用到的"),e("code",[v._v("死代码")]),v._v("。从而来优化打包体积。"),e("code",[v._v("生产环境默认开启")])]),v._v(" "),e("li",[v._v("它可以在"),e("code",[v._v("代码不运行")]),v._v("的状态下，分析出"),e("code",[v._v("不需要的代码")])]),v._v(" "),e("li",[v._v("利用"),e("code",[v._v("es6模块")]),v._v("的规范\n"),e("code",[v._v("ES6 Module")]),v._v(" 引入进行"),e("code",[v._v("静态分析")]),v._v("，故而"),e("code",[v._v("编译的时候正确判断到底加载了那些模块")])]),v._v(" "),e("li",[e("code",[v._v("Tree-shaking")]),v._v(" 的实现：\n"),e("ol",[e("li",[v._v("先"),e("strong",[v._v("标记")]),v._v("出模块导出值中哪些没有被用过")]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("Terser")]),v._v(" 删掉这些没被用到的导出语句")]),v._v(" "),e("li",[v._v("标记过程大致可划分为三个步骤：\n"),e("ol",[e("li",[e("code",[v._v("Make 阶段")]),v._v("，收集模块导出变量并记录到模块依赖关系图 "),e("code",[v._v("ModuleGraph")]),v._v(" 变量中")]),v._v(" "),e("li",[e("code",[v._v("Seal 阶段")]),v._v("，遍历 "),e("code",[v._v("ModuleGraph")]),v._v(" 标记模块导出变量有没有被使用")]),v._v(" "),e("li",[e("code",[v._v("生成产物时")]),v._v("，若变量没有被其它模块使用则删除对应的导出语句")])])])])])]),v._v(" "),e("p",[e("strong",[v._v("扩展")]),v._v("："),e("code",[v._v("CSS")]),v._v(" 可以 "),e("code",[v._v("Tree-Shaking")]),v._v(" 吗？")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("webpack")]),v._v(" 中 "),e("code",[v._v("Tree-Shaking")]),v._v(" 是通过 "),e("code",[v._v("uglifyJSPlugin")]),v._v(" 来 "),e("code",[v._v("Tree-Shaking JS")]),v._v(" 的。"),e("code",[v._v("CSS")]),v._v(" 需要使用 "),e("code",[v._v("Purify-CSS")]),v._v("["),e("strong",[v._v("不在维护")]),v._v("]，使用 "),e("code",[v._v("purgecss-webpack-plugin")]),v._v("，"),e("code",[v._v("mini-css-extract-plugin")]),v._v(" 提取 css 插件配合使用。")])])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("缓存配置")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("webpack4")]),v._v(" 通过 "),e("code",[v._v("hard-source-webpack-plugin")]),v._v(" 缓存")]),v._v(" "),e("li",[e("code",[v._v("webpack5")]),v._v(" 内置了 "),e("code",[v._v("cache")]),v._v(" 缓存机制")])]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 使用持久化缓存")]),v._v("\n  cache"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    type"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'filesystem'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n    cacheDirectory"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" path"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("join")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("__dirname"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'node_modules/.cache/webpack'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),e("p",[e("strong",[v._v("扩展")]),v._v("：什么是长缓存？")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("webpack")]),v._v(" 中可以在 "),e("code",[v._v("output")]),v._v(" 选项中指定 "),e("code",[v._v("hash")]),v._v(", 通过 "),e("code",[v._v("HashedModuleIdsPlugin")]),v._v(" 或者 "),e("code",[v._v("NamedModulesPlugin")]),v._v(" 来生成唯一的 "),e("code",[v._v("moduleId")]),v._v("，保证没有改动的文件 "),e("code",[v._v("hash")]),v._v(" 值不变")]),v._v(" "),e("p",[e("strong",[v._v("注意")]),v._v("："),e("code",[v._v("cache")]),v._v(" 在开发模式默认设置成 "),e("code",[v._v("type: memory")]),v._v("; 【生产模块把 "),e("code",[v._v("cache")]),v._v(" 给禁用掉了】")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("启动服务的差别")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("webpack4")]),v._v(" 启动服务 -> "),e("code",[v._v("webpack-dev-server")])]),v._v(" "),e("li",[e("code",[v._v("webpack5")]),v._v(" 启动服务使用内置的 "),e("code",[v._v("webpack serve")]),v._v(" 启动")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("输出代码")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("webpack4")]),v._v(" 只能输出 "),e("code",[v._v("es5")]),v._v(" 的代码")]),v._v(" "),e("li",[e("code",[v._v("webpack5")]),v._v(" 新增属性 "),e("code",[v._v("output.ecmaVersion")]),v._v("，可以生成 "),e("code",[v._v("es5")]),v._v(" 和 "),e("code",[v._v("es6")]),v._v(" 的代码")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("代码分割")])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("webpack4")]),v._v(" 将超过 "),e("code",[v._v("30kb")]),v._v(" 文件单独提为一个 "),e("code",[v._v("chunk")]),v._v("（"),e("code",[v._v("minSize: 30000")]),v._v("）")]),v._v(" "),e("li",[e("code",[v._v("webpack5")]),v._v(" 可以区分是 "),e("code",[v._v("js")]),v._v(" 还是 "),e("code",[v._v("css")]),v._v("，精准划分（"),e("code",[v._v("minSize: {javascript: 30000, css: 50000}")]),v._v("）")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("模块联邦")]),v._v(" "),e("code",[v._v("Module Federation")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("devtool 差别")])]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("webpack4")]),v._v(" 有 13 种")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("webpack5")]),v._v(" 有 26 种")]),v._v(" "),e("p",[e("strong",[v._v("扩展")]),v._v("："),e("code",[v._v("webpack4")]),v._v(" 一般开发环境配置 "),e("code",[v._v("cheap-eval-module-source-map")]),v._v("，在生产用 "),e("code",[v._v("none")]),v._v("；webpack5 使用 "),e("code",[v._v("eval-cheap-module-source-map")])])])])])]),v._v(" "),e("h2",{attrs:{id:"_6-grunt、gulp、webpack、rollup、vite-的比较？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-grunt、gulp、webpack、rollup、vite-的比较？","aria-hidden":"true"}},[v._v("#")]),v._v(" 6. Grunt、Gulp、Webpack、Rollup、Vite 的比较？")]),v._v(" "),e("p",[e("strong",[v._v("模块化管理工具")]),v._v(" 和 "),e("strong",[v._v("自动化构建工具")]),v._v(" 是不同的。两者主要的侧重点不一样。"),e("strong",[v._v("自动化构建工具")]),v._v(" 则侧重于 "),e("strong",[v._v("前端开发的整个过程")]),v._v(" 的控制管理（像流水线）。而"),e("strong",[v._v("模块化管理工具")]),v._v("更侧重于 "),e("strong",[v._v("模块打包")]),v._v("。可以把开发中的所有资源（图片、js、css 文件等）都当成 "),e("strong",[v._v("模块")])]),v._v(" "),e("ul",[e("li",[e("p",[e("strong",[v._v("Webpack")]),v._v(": 是当前最流行的 "),e("code",[v._v("模块化管理工具")]),v._v(" 和 "),e("code",[v._v("打包工具")]),v._v("。其通过 loader 的转换，可以将任何形式的资源都当成模块。它还可以将各个模块通过其 "),e("strong",[v._v("依赖关系")]),v._v(" 打包成符合生产环境部署的前端资源。它还可以将应用程序分解成可管理的代码块，可以按需加载")]),v._v(" "),e("p",[e("strong",[v._v("打包原理")]),v._v("：解析各个模块的依赖关系，使用 loader 转换文件，使用 plugin 注入钩子，打包合并模块，最终生成 bundle 文件，使用 express 开启本地服务器，浏览器请求的是 bundle 文件")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("优点")]),v._v("：\n"),e("ol",[e("li",[v._v("基本之前 gulp 可以操作的，webpack 都可以做")]),v._v(" "),e("li",[v._v("同时支持"),e("code",[v._v("热更新")]),v._v("、"),e("code",[v._v("tree-shaking")]),v._v("、"),e("code",[v._v("Scope Hoisting")]),v._v("、"),e("code",[v._v("动态加载")]),v._v("、"),e("code",[v._v("代码拆分")]),v._v("、"),e("code",[v._v("文件指纹")]),v._v("、"),e("code",[v._v("代码压缩")]),v._v("、"),e("code",[v._v("静态资源处理")]),v._v("等")]),v._v(" "),e("li",[v._v("支持多种打包方式")])])]),v._v(" "),e("li",[e("strong",[v._v("缺点")]),v._v("：\n"),e("ol",[e("li",[v._v("各个模块之间的依赖关系过于复杂 会导致打包速度很慢")]),v._v(" "),e("li",[v._v("使用热更新时，改动一个模块，其他有依赖关系的模块也会重新打包")]),v._v(" "),e("li",[v._v("不支持打包出 esm 格式的代码（打包后的代码再次被引用时 tree shaking 困难），打包后亢余代码较多")])])])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Vite")]),v._v("：和 webpack 差不多，vite 是当下新型的 "),e("code",[v._v("模块化管理工具")]),v._v(" 和 "),e("code",[v._v("打包工具")]),v._v("。它本地启动速度比 webpack 快了很多。但是 vite 还完成没有替换 webpack 的能力，不管是从社区还是从能力来说，vite 本身还是太过脆弱，它的产生和火热完成依赖于 vue 本身的热度")]),v._v(" "),e("p",[e("strong",[v._v("打包原理")]),v._v("：就是启动一个 "),e("code",[v._v("koa")]),v._v(" 服务器拦截由浏览器请求的 ESM 的请求，通过请求的路径找到目录下对应的文件做一定的处理，最终以 ESM 的格式返回给客户端")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-e3852ed76ec402c75f06c8d6ec8921d1_720w.jpg",alt:""}})]),v._v(" "),e("p",[e("code",[v._v("Vite1.x")]),v._v(" 使用 "),e("code",[v._v("koa")]),v._v(", "),e("code",[v._v("Vite2.x")]),v._v(" 使用 "),e("code",[v._v("connect")])]),v._v(" "),e("p",[v._v("Vite 作为一个基于浏览器原生的 ESM 的构建工具，它省略了开发环境的打包过程，利用浏览器去解析 import，在服务端按需编译返回。同时，开发环境模块热更新也非常快，不会随着模块的增多而变慢。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Vite 的主要特性：")]),v._v(" "),e("ol",[e("li",[v._v("Instant Server Start —— 即时服务启动")]),v._v(" "),e("li",[v._v("Lightning Fast HMR —— 闪电般快速的热更新")]),v._v(" "),e("li",[v._v("Rich Features —— 丰富的功能")]),v._v(" "),e("li",[v._v("Optimized Build —— 经过优化的构建")]),v._v(" "),e("li",[v._v("Universal Plugin Interface —— 通用的 Plugin 接口")]),v._v(" "),e("li",[v._v("Fully Typed APIs —— 类型齐全的 API")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("项目的开发浏览器要支持 "),e("code",[v._v("es module")]),v._v(", 要求浏览器比较新【"),e("code",[v._v("@vitejs/plugin-legacy")]),v._v("a】插件打包出一个兼容性比较好的版本")]),v._v(" "),e("li",[v._v("生产环境使用 rollup 打包会造成开大环境与生产环境不一致")]),v._v(" "),e("li",[v._v("生态没有 "),e("code",[v._v("webpack")]),v._v(" 丰富")]),v._v(" "),e("li",[v._v("很多第三方 SDK 没有产出 ems 格式的代码，这就需要我们自己去做一些兼容")])]),v._v(" "),e("p",[v._v("对于一些 没有产出 esm 的模块，如何去兼容呢？")]),v._v(" "),e("p",[v._v("业界是有一些如 "),e("code",[v._v("lebab")]),v._v(" 的方法可以将 "),e("code",[v._v("commjs")]),v._v(" 代码快速转化为 "),e("code",[v._v("esm")]),v._v(" 的，但是对于一些格式不规范的代码，可能还是需要单独处理。")])])]),v._v(" "),e("p",[v._v("构建工具的发展：Browserify -> Gulp -> Parcel -> Webpack -> Rollup -> (后来的非打包)Snowpack 和 Vite")]),v._v(" "),e("p",[e("strong",[v._v("注意")]),v._v("：在 "),e("code",[v._v("Vite")]),v._v(" 中约定若 "),e("code",[v._v("path")]),v._v(" 的请求路径满足 "),e("code",[v._v("/^\\/@modules\\//")]),v._v(" 格式时，被认为是一个 "),e("code",[v._v("node_modules")]),v._v(" 模块。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。")]),v._v(" "),e("ol",[e("li",[v._v("服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。")]),v._v(" "),e("li",[v._v("客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。")])])]),v._v(" "),e("li",[e("p",[v._v("Vite 的实现核心：")]),v._v(" "),e("ol",[e("li",[v._v("实现静态服务功能 -> "),e("code",[v._v("koa-static")])]),v._v(" "),e("li",[v._v("解析 import 语法 重写路径 -> "),e("code",[v._v("es-module-lexer")]),v._v(" parse 方法")]),v._v(" "),e("li",[v._v("解析 以/@modules 文件开头的内容 找到对应的结果，设置响应类型 type='js'返回给客户端")]),v._v(" "),e("li",[v._v("处理 html 不存在 process")]),v._v(" "),e("li",[v._v("解析.vue 文件")])])])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Rollup")]),v._v("：是下一代 ES6 "),e("strong",[v._v("模块打包工具")]),v._v("，可以将我们按照 ESM（ES2015 Module）规范编写的源码构建输出如下格式：")]),v._v(" "),e("ol",[e("li",[v._v("IIFE：自执行函数，可通过 script 标签加载")]),v._v(" "),e("li",[v._v("AMD：通过 requirejs 加载")]),v._v(" "),e("li",[v._v("CommonJS：Node 默认的模块规范，可通过 webpack 加载")]),v._v(" "),e("li",[v._v("UMD：兼容 IIFE、AMD、CJS 三种模块规范")]),v._v(" "),e("li",[v._v("ESM：ES2015 Module 规范，可用 webpack，rollup 加载")])]),v._v(" "),e("ul",[e("li",[e("p",[e("strong",[v._v("优点")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("支持动态导入")]),v._v(" "),e("li",[v._v("支持 tree-shaking。仅加载模块里用得到的函数以减少文件大小")]),v._v(" "),e("li",[v._v("Scope Hoisting。rollup 可以将所有的小文件生成到一个大文件中，所有代码都在同一个函数作用域里；不会像 webpack 那样用很多函数来包装模块")]),v._v(" "),e("li",[v._v("没有其他冗余代码, 执行很快。除了必要的 "),e("code",[v._v("cjs")]),v._v(", "),e("code",[v._v("umd")]),v._v(" 头外，bundle 代码基本和源码差不多，也没有奇怪的 "),e("code",[v._v("__webpack_require__")]),v._v(", "),e("code",[v._v("Object.defineProperty")]),v._v(" 之类的东西")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("不支持热更新功能")]),v._v(" "),e("li",[v._v("对于 commonjs 模块，需要额外的插件将其转化为 es2015 供 rollup 处理")]),v._v(" "),e("li",[v._v("无法公共代码拆分")])])])]),v._v(" "),e("p",[e("strong",[v._v("适用场景")]),v._v("：开发第三方库、生成单一的 umd 文件的场景")]),v._v(" "),e("p",[e("strong",[v._v("比较 Webpack")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("Rollup 目前还不支持代码拆分（Code Splitting）和模块的热更新（HMR）")]),v._v(" "),e("li",[v._v("一般，对于应用开发使用 Webpack，对于类库开发使用 Rollup")]),v._v(" "),e("li",[v._v("需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 CommonJS 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup")]),v._v(" "),e("li",[v._v("React 已经将构建工具从 Webpack 换成了 Rollup")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Gulp")]),v._v("：是基于 "),e("strong",[v._v("流")]),v._v(" 的 "),e("strong",[v._v("前端自动化构建工具")]),v._v("，采用代码优于配置的策略，更容易学习和使用，它让简单的任务简单，复杂的任务复杂")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("优点")]),v._v("：\n"),e("ol",[e("li",[v._v("gulp 文档简单，学习成本低，使用也比较简单")]),v._v(" "),e("li",[v._v("对大量源文件可以进行流式处理，借助插件，可以对文件类型进行多种操作处理")])])]),v._v(" "),e("li",[e("strong",[v._v("缺点")]),v._v("：\n"),e("ol",[e("li",[v._v("不支持 tree-shaking、热更新、代码拆分等")]),v._v(" "),e("li",[v._v("gulp 对 js 模块化方案无能为力，只是对静态资源做流式处理，处理之后并未做有效的优化整合")])])])]),v._v(" "),e("p",[e("strong",[v._v("适用场景")]),v._v("：静态资源密集操作型场景，主要用于 css、图片等静态资源的处理操作")]),v._v(" "),e("p",[e("strong",[v._v("比较 grunt")]),v._v(":")]),v._v(" "),e("ol",[e("li",[v._v("易用，Gulp 相比于 Grunt 更简洁，而且遵循代码优于配置策略，维护 Gulp 更像是写代码")]),v._v(" "),e("li",[v._v("高效，Gulp 核心设计是基于 Unix 的"),e("strong",[v._v("流")]),v._v("的概念，通过"),e("strong",[v._v("管道")]),v._v("连接，不需要写中间文件")]),v._v(" "),e("li",[v._v("易学，Gulp 的核心 API 只有 5 个，之后可以通过管道流组合自己想要的任务")]),v._v(" "),e("li",[v._v("流：使用 Grunt 的 I/O 过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。而使用 Gulp 的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次 I/O 的过程，流程更清晰，更纯粹")]),v._v(" "),e("li",[v._v("代码优于配置：维护 Gulp 更像是写代码，而且 Gulp 遵循 CommonJS 规范，因此跟写 Node 程序没有区别")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Grunt")]),v._v("：是一套 "),e("strong",[v._v("前端自动化工具")]),v._v("，帮助处理反复重复的任务。一般用于：编译、压缩、合并文件，简单语法检查等")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("特点")]),v._v("：\n"),e("ol",[e("li",[v._v("Grunt 有一个完成的社区，插件丰富")]),v._v(" "),e("li",[v._v("它简单易学，你可以随便安装插件并配置它们")])])])])])]),v._v(" "),e("p",[v._v("Webpack 的定位是模块打包器，而 Gulp/Grunt 属于构建工具")]),v._v(" "),e("h2",{attrs:{id:"_7-了解热更新原理吗？它是如何做到的？说说其原理？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-了解热更新原理吗？它是如何做到的？说说其原理？","aria-hidden":"true"}},[v._v("#")]),v._v(" 7. 了解热更新原理吗？它是如何做到的？说说其原理？")]),v._v(" "),e("p",[v._v("开启了 express 应用，添加了对 webpack 编译的监听，添加了和浏览器的 websocket 长连接，当文件变化触发 webpack 进行编译并完成后，会通过 socket 告诉浏览器准备刷新。而为了减少刷新的代价，就是"),e("strong",[v._v("不用刷新页面")]),v._v("，而是"),e("strong",[v._v("刷新某个模块")]),v._v("，webpack-dev-server 可以支持热更新，通过生成文件的 hash 来对比需要更新的模块，浏览器再进行热替换")]),v._v(" "),e("p",[e("strong",[v._v("扩展")]),v._v("：hash、chunkhash、contenthash 三者的区别？")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("hash 一般是结合 CDN 缓存来使用的")]),v._v(" "),e("ol",[e("li",[v._v("hash：是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都公用相同的 hash 值（每一次构建都会生成新的 hash 值（不管文件是否有改动）-》导致没有办法实现缓存效果）")]),v._v(" "),e("li",[v._v("chunkhash：和 hash 不一样，它根据不同的入口文件（entry）进行依赖文件解析，构建对于的 chunk，生成对应的哈希值。-》（同一个 chunk 的一个依赖改变了，其他的依赖哈希值也会变）")]),v._v(" "),e("li",[v._v("contenthash：针对的是对应的内容是否改变")])])]),v._v(" "),e("li",[e("p",[v._v("如何避免相同的随机值？\nwebpack 在"),e("code",[v._v("计算hash后分割chunk")]),v._v("。"),e("code",[v._v("产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("扩展")]),v._v("：CDN 原理？")]),v._v(" "),e("ol",[e("li",[v._v("用户输入域名，首先经过 dns 解析，请求 cname 指向的那台 cdn 专用的 dns 服务器")]),v._v(" "),e("li",[v._v("dns 服务器返回全局负载均衡的服务器 IP 给用户")]),v._v(" "),e("li",[v._v("用户请求全局负载均衡服务器，服务器根据 IP 返回所在区域的负载均衡服务器 IP 给用户")]),v._v(" "),e("li",[v._v("用户请求区域负载均衡服务器，服务器根据 IP 选择距离最近的，负载比较合适的一台缓存服务器 IP 给用户。（当没有对应内容时，会去上一级缓存服务器去找，直到找到资源所在的服务器，并且缓存在缓存服务器中，供下次访问）")])])])]),v._v(" "),e("p",[v._v("域名 -> dns 解析 -> 全局负载均衡的服务器 -> 所在区域的负载均衡服务器 -> 缓存服务器")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("CDN 回溯")]),v._v("：就是 "),e("code",[v._v("CDN")]),v._v(" 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程")])]),v._v(" "),e("h2",{attrs:{id:"_8-sourcemap-有哪些？对应的作用是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-sourcemap-有哪些？对应的作用是什么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 8. sourceMap 有哪些？对应的作用是什么？")]),v._v(" "),e("h2",{attrs:{id:"_9-babel-的原理？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-babel-的原理？","aria-hidden":"true"}},[v._v("#")]),v._v(" 9. Babel 的原理？")]),v._v(" "),e("p",[e("code",[v._v("Babel")]),v._v(" 是 "),e("code",[v._v("JS")]),v._v(" 语法转换器（将一些高级语法转换成浏览器可以识别的低级语法）")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("Babel")]),v._v(" 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("解析")]),v._v("（Parse） ：将源代码转换成更加抽象的表示方法（例如"),e("code",[v._v("抽象语法树")]),v._v("）。包括 "),e("code",[v._v("词法分析")]),v._v(" 和 "),e("code",[v._v("语法分析")]),v._v("。词法分析主要把"),e("code",[v._v("字符流")]),v._v("源代码（"),e("code",[v._v("Char Stream")]),v._v("）转换成"),e("code",[v._v("令牌流")]),v._v("（ "),e("code",[v._v("Token Stream")]),v._v("）。语法分析主要是将 "),e("code",[v._v("令牌流")]),v._v(" 转换成 "),e("code",[v._v("抽象语法树")]),v._v("（"),e("code",[v._v("Abstract Syntax Tree")]),v._v("，AST）。")]),v._v(" "),e("li",[e("code",[v._v("转换")]),v._v("（Transform） ：通过 "),e("code",[v._v("Babel")]),v._v(" 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。")]),v._v(" "),e("li",[e("code",[v._v("生成")]),v._v("（Generate） ：将 AST 转换成"),e("code",[v._v("字符串形式")]),v._v("的"),e("code",[v._v("低版本")]),v._v("代码，同时也能创建 Source Map 映射。")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Babel 的原理")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("使用 "),e("code",[v._v("babylon")]),v._v(" 将 "),e("code",[v._v("源代码")]),v._v(" 进行 "),e("code",[v._v("解析")]),v._v(" -> 得到 "),e("code",[v._v("AST")])]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("babel-traverse")]),v._v(" 对 "),e("code",[v._v("AST")]),v._v(" 树进行遍历转义 -> 得到新的 "),e("code",[v._v("AST")]),v._v(" 树")]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("babel-generator")]),v._v(" 通过 "),e("code",[v._v("AST")]),v._v(" 树生成 "),e("code",[v._v("ES5")]),v._v(" 代码")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("Babel 的包构成")]),v._v("：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("babel-core")]),v._v(": "),e("code",[v._v("babel")]),v._v(" 的核心库，提供一下 babel 转义 API，如 "),e("code",[v._v("babel.transform")]),v._v(" 等，用于对代码进行转译。（"),e("code",[v._v("webpack")]),v._v(" 的 "),e("code",[v._v("babel-loader")]),v._v(" 是调用这些 API 来完成转译的）")]),v._v(" "),e("li",[e("code",[v._v("babylon")]),v._v("："),e("code",[v._v("js")]),v._v(" 的词法解析器")]),v._v(" "),e("li",[e("code",[v._v("babel-traverse")]),v._v("：用于对 "),e("code",[v._v("AST")]),v._v(" 的遍历")]),v._v(" "),e("li",[e("code",[v._v("babel-generator")]),v._v(": 根据 "),e("code",[v._v("AST")]),v._v(" 生成代码")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("工具包和功能包")]),v._v("：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("babel-cli")]),v._v("："),e("code",[v._v("babel")]),v._v(" 的命令行工具，通过命令行对 js 代码进行转译")]),v._v(" "),e("li",[e("code",[v._v("babel-register")]),v._v("：通过绑定 "),e("code",[v._v("node.js")]),v._v(" 的 "),e("code",[v._v("require")]),v._v(" 来自动转译 "),e("code",[v._v("require")]),v._v(" 引用的 "),e("code",[v._v("js")]),v._v(" 代码文件")]),v._v(" "),e("li",[e("code",[v._v("babel-types")]),v._v("：用于检验、构建和改变 AST 树的节点")]),v._v(" "),e("li",[e("code",[v._v("babel-polyfill")]),v._v("：JS 标准新增的原生对象和 API 的 shim，实现上仅仅是 "),e("code",[v._v("core-js")]),v._v(" 和 "),e("code",[v._v("regenerator-runtime")]),v._v(" 两个包的封装")]),v._v(" "),e("li",[e("code",[v._v("babel-runtime")]),v._v("：功能类似 "),e("code",[v._v("babel-polyfill")]),v._v("，一般用于 "),e("code",[v._v("library")]),v._v(" 或 "),e("code",[v._v("plugin")]),v._v(" 中，因为它不会污染全局作用域")])])])]),v._v(" "),e("p",[e("strong",[v._v("扩展")]),v._v("："),e("code",[v._v("babel-runtime")]),v._v(" 和 "),e("code",[v._v("babel-polyfill")]),v._v(" 的区别？")]),v._v(" "),e("p",[e("code",[v._v("babel")]),v._v(" 默认只转译"),e("code",[v._v("新的 JS 语法")]),v._v("，而不转译"),e("code",[v._v("新的 API")]),v._v("（如："),e("code",[v._v("Iterator")]),v._v("、"),e("code",[v._v("Set")]),v._v("、"),e("code",[v._v("Generator")]),v._v("、"),e("code",[v._v("Proxy")]),v._v("、"),e("code",[v._v("Symbol")]),v._v(" 等全局对象），以及一些定义在全局对象上的方法（如："),e("code",[v._v("Object.assign")]),v._v("）都不会转译。如果想使用这些新的对象和方法，则需要为当前环境提供一个 "),e("code",[v._v("polyfill")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("babel-polyfill")]),v._v("，它会加载整个 "),e("code",[v._v("polyfill")]),v._v(" 库，解决了 "),e("code",[v._v("babel")]),v._v(" 不转译"),e("code",[v._v("新 API")]),v._v(" 的问题。并且在代码中 "),e("code",[v._v("插入一些帮助函数")])]),v._v(" "),e("p",[e("strong",[v._v("缺点")]),v._v("：直接在代码中插入帮助函数，会导致"),e("code",[v._v("污染了全局环境")]),v._v("；并且全部引入，打包后会有很多 "),e("code",[v._v("重复的代码")]),v._v("，导致编译后的代码体积变大")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("babel-runtime")]),v._v("："),e("code",[v._v("babel")]),v._v(" 为了解决以上问题，提供了单独的包，用以提供编译模块的工具函数。启用 "),e("code",[v._v("babel-plugin-transform-runtime")]),v._v("（它会帮我自动动态 "),e("code",[v._v("require @babel/runtime")]),v._v(" 中的内容）后，"),e("code",[v._v("babel")]),v._v(" 就会使用 "),e("code",[v._v("babel-runtime")]),v._v(" 下的工具函数；"),e("strong",[v._v("这样可以避免自行引入 polyfill 时导致的污染全局命名空间的问题")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("babel-runtime")]),v._v(" 适合在组件，类库项目中使用，而 "),e("code",[v._v("babel-polyfill")]),v._v(" 适合在业务项目中使用")])])]),v._v(" "),e("p",[e("strong",[v._v("扩展")]),v._v("："),e("code",[v._v("babel-runtime")]),v._v(" 为什么适合 "),e("code",[v._v("JavaScript")]),v._v(" 库和工具包的实现？")]),v._v(" "),e("ol",[e("li",[v._v("避免 "),e("code",[v._v("babel")]),v._v(" 编译的工具函数在每个模块里重复出现，减小库和工具包的体积")]),v._v(" "),e("li",[v._v("在没有使用 "),e("code",[v._v("babel-runtime")]),v._v(" 之前，库和工具包一般不会直接引入 "),e("code",[v._v("polyfill")]),v._v("。否则像 "),e("code",[v._v("Promise")]),v._v(" 这样的全局对象会污染全局命名空间。在使用 "),e("code",[v._v("babel-runtime")]),v._v(" 后，库和工具只要在 "),e("code",[v._v("package.json")]),v._v(" 中增加依赖 "),e("code",[v._v("babel-runtime")]),v._v("，交给 "),e("code",[v._v("babel-runtime")]),v._v(" 去引入 "),e("code",[v._v("polyfill")]),v._v(" 就行了")])]),v._v(" "),e("p",[e("strong",[v._v("注意")]),v._v("：具体项目还是需要使用 "),e("code",[v._v("babel-polyfill")]),v._v("，只使用 "),e("code",[v._v("babel-runtime")]),v._v(" 的话，实例方法不能正常工作（例如 "),e("code",[v._v('"foobar".includes("foo")')]),v._v("）")]),v._v(" "),e("h2",{attrs:{id:"_10-module、chunk、bundle-分别是什么意思，有何区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-module、chunk、bundle-分别是什么意思，有何区别？","aria-hidden":"true"}},[v._v("#")]),v._v(" 10. module、chunk、bundle 分别是什么意思，有何区别？")]),v._v(" "),e("ul",[e("li",[v._v("对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 "),e("strong",[v._v("module")])]),v._v(" "),e("li",[v._v("当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 "),e("strong",[v._v("chunk")]),v._v(" 文件，webpack 会对这个 chunk 文件进行一些操作")]),v._v(" "),e("li",[v._v("webpack 处理好 chunk 文件后，最后会输出 "),e("strong",[v._v("bundle")]),v._v(" 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行")])]),v._v(" "),e("p",[e("strong",[v._v("总结")]),v._v("：我们直接写出来的是 "),e("code",[v._v("module")]),v._v("，"),e("code",[v._v("webpack")]),v._v(" 处理时是 "),e("code",[v._v("chunk")]),v._v("，最后生成浏览器可以直接运行的 "),e("code",[v._v("bundle")])]),v._v(" "),e("h2",{attrs:{id:"_11-webpack-optimize-有配置过吗-可以简单说说吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-webpack-optimize-有配置过吗-可以简单说说吗","aria-hidden":"true"}},[v._v("#")]),v._v(" 11. Webpack optimize 有配置过吗?可以简单说说吗?")])])}],!1,null,null,null);_.default=c.exports}}]);